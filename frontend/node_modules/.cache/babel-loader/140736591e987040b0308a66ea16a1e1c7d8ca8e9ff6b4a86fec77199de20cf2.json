{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nSymbol.dispose ??= Symbol('dispose');\nSymbol.asyncDispose ??= Symbol('asyncDispose');\n/**\n * @internal\n */\nexport const disposeSymbol = Symbol.dispose;\n/**\n * @internal\n */\nexport const asyncDisposeSymbol = Symbol.asyncDispose;\n/**\n * @internal\n */\nexport class DisposableStack {\n  #disposed = false;\n  #stack = [];\n  /**\n   * Returns a value indicating whether the stack has been disposed.\n   */\n  get disposed() {\n    return this.#disposed;\n  }\n  /**\n   * Alias for `[Symbol.dispose]()`.\n   */\n  dispose() {\n    this[disposeSymbol]();\n  }\n  /**\n   * Adds a disposable resource to the top of stack, returning the resource.\n   * Has no effect if provided `null` or `undefined`.\n   *\n   * @param value - A `Disposable` object, `null`, or `undefined`.\n   * `null` and `undefined` will not be added, but will be returned.\n   * @returns The provided `value`.\n   */\n  use(value) {\n    if (value && typeof value[disposeSymbol] === 'function') {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n  /**\n   * Adds a non-disposable resource and a disposal callback to the top of the stack.\n   *\n   * @param value - A resource to be disposed.\n   * @param onDispose - A callback invoked to dispose the provided value.\n   * Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt(value, onDispose) {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose(value);\n      }\n    });\n    return value;\n  }\n  /**\n   * Add a disposal callback to the top of the stack to be invoked when stack is disposed.\n   * @param onDispose - A callback to invoke when this object is disposed.\n   */\n  defer(onDispose) {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose();\n      }\n    });\n  }\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   * @returns The new `DisposableStack`.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move() {\n    if (this.#disposed) {\n      throw new ReferenceError('A disposed stack can not use anything new');\n    }\n    const stack = new DisposableStack();\n    stack.#stack = this.#stack;\n    this.#stack = [];\n    this.#disposed = true;\n    return stack;\n  }\n  /**\n   * Disposes each resource in the stack in last-in-first-out (LIFO) manner.\n   */\n  [disposeSymbol]() {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    const errors = [];\n    for (const resource of this.#stack.reverse()) {\n      try {\n        resource[disposeSymbol]();\n      } catch (e) {\n        errors.push(e);\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      let suppressed = null;\n      for (const error of errors.reverse()) {\n        if (suppressed === null) {\n          suppressed = error;\n        } else {\n          suppressed = new SuppressedError(error, suppressed);\n        }\n      }\n      throw suppressed;\n    }\n  }\n  [Symbol.toStringTag] = 'DisposableStack';\n}\n/**\n * @internal\n */\nexport class AsyncDisposableStack {\n  #disposed = false;\n  #stack = [];\n  /**\n   * Returns a value indicating whether the stack has been disposed.\n   */\n  get disposed() {\n    return this.#disposed;\n  }\n  /**\n   * Alias for `[Symbol.asyncDispose]()`.\n   */\n  async dispose() {\n    await this[asyncDisposeSymbol]();\n  }\n  /**\n   * Adds a AsyncDisposable resource to the top of stack, returning the resource.\n   * Has no effect if provided `null` or `undefined`.\n   *\n   * @param value - A `AsyncDisposable` object, `null`, or `undefined`.\n   * `null` and `undefined` will not be added, but will be returned.\n   * @returns The provided `value`.\n   */\n  use(value) {\n    if (value) {\n      const asyncDispose = value[asyncDisposeSymbol];\n      const dispose = value[disposeSymbol];\n      if (typeof asyncDispose === 'function') {\n        this.#stack.push(value);\n      } else if (typeof dispose === 'function') {\n        this.#stack.push({\n          [asyncDisposeSymbol]: async () => {\n            value[disposeSymbol]();\n          }\n        });\n      }\n    }\n    return value;\n  }\n  /**\n   * Adds a non-disposable resource and a disposal callback to the top of the stack.\n   *\n   * @param value - A resource to be disposed.\n   * @param onDispose - A callback invoked to dispose the provided value.\n   * Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt(value, onDispose) {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose(value);\n      }\n    });\n    return value;\n  }\n  /**\n   * Add a disposal callback to the top of the stack to be invoked when stack is disposed.\n   * @param onDispose - A callback to invoke when this object is disposed.\n   */\n  defer(onDispose) {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose();\n      }\n    });\n  }\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   * @returns The new `AsyncDisposableStack`.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move() {\n    if (this.#disposed) {\n      throw new ReferenceError('A disposed stack can not use anything new');\n    }\n    const stack = new AsyncDisposableStack();\n    stack.#stack = this.#stack;\n    this.#stack = [];\n    this.#disposed = true;\n    return stack;\n  }\n  /**\n   * Disposes each resource in the stack in last-in-first-out (LIFO) manner.\n   */\n  async [asyncDisposeSymbol]() {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    const errors = [];\n    for (const resource of this.#stack.reverse()) {\n      try {\n        await resource[asyncDisposeSymbol]();\n      } catch (e) {\n        errors.push(e);\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      let suppressed = null;\n      for (const error of errors.reverse()) {\n        if (suppressed === null) {\n          suppressed = error;\n        } else {\n          suppressed = new SuppressedError(error, suppressed);\n        }\n      }\n      throw suppressed;\n    }\n  }\n  [Symbol.toStringTag] = 'AsyncDisposableStack';\n}\n/**\n * @internal\n * Represents an error that occurs when multiple errors are thrown during\n * the disposal of resources. This class encapsulates the primary error and\n * any suppressed errors that occurred subsequently.\n */\nexport class SuppressedError extends Error {\n  #error;\n  #suppressed;\n  constructor(error, suppressed, message = 'An error was suppressed during disposal') {\n    super(message);\n    this.name = 'SuppressedError';\n    this.#error = error;\n    this.#suppressed = suppressed;\n  }\n  /**\n   * The primary error that occurred during disposal.\n   */\n  get error() {\n    return this.#error;\n  }\n  /**\n   * The suppressed error i.e. the error that was suppressed\n   * because it occurred later in the flow after the original error.\n   */\n  get suppressed() {\n    return this.#suppressed;\n  }\n}","map":{"version":3,"names":["Symbol","dispose","asyncDispose","disposeSymbol","asyncDisposeSymbol","DisposableStack","disposed","stack","use","value","push","adopt","onDispose","defer","move","ReferenceError","errors","resource","reverse","e","length","suppressed","error","SuppressedError","toStringTag","AsyncDisposableStack","Error","constructor","message","name"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/util/disposable.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\ndeclare global {\n  interface SymbolConstructor {\n    /**\n     * A method that is used to release resources held by an object. Called by\n     * the semantics of the `using` statement.\n     */\n    readonly dispose: unique symbol;\n\n    /**\n     * A method that is used to asynchronously release resources held by an\n     * object. Called by the semantics of the `await using` statement.\n     */\n    readonly asyncDispose: unique symbol;\n  }\n\n  interface Disposable {\n    [Symbol.dispose](): void;\n  }\n\n  interface AsyncDisposable {\n    [Symbol.asyncDispose](): PromiseLike<void>;\n  }\n}\n\n(Symbol as any).dispose ??= Symbol('dispose');\n(Symbol as any).asyncDispose ??= Symbol('asyncDispose');\n\n/**\n * @internal\n */\nexport const disposeSymbol: typeof Symbol.dispose = Symbol.dispose;\n\n/**\n * @internal\n */\nexport const asyncDisposeSymbol: typeof Symbol.asyncDispose =\n  Symbol.asyncDispose;\n\n/**\n * @internal\n */\nexport class DisposableStack {\n  #disposed = false;\n  #stack: Disposable[] = [];\n\n  /**\n   * Returns a value indicating whether the stack has been disposed.\n   */\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  /**\n   * Alias for `[Symbol.dispose]()`.\n   */\n  dispose(): void {\n    this[disposeSymbol]();\n  }\n\n  /**\n   * Adds a disposable resource to the top of stack, returning the resource.\n   * Has no effect if provided `null` or `undefined`.\n   *\n   * @param value - A `Disposable` object, `null`, or `undefined`.\n   * `null` and `undefined` will not be added, but will be returned.\n   * @returns The provided `value`.\n   */\n  use<T extends Disposable | null | undefined>(value: T): T {\n    if (value && typeof value[disposeSymbol] === 'function') {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n\n  /**\n   * Adds a non-disposable resource and a disposal callback to the top of the stack.\n   *\n   * @param value - A resource to be disposed.\n   * @param onDispose - A callback invoked to dispose the provided value.\n   * Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt<T>(value: T, onDispose: (value: T) => void): T {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose(value);\n      },\n    });\n    return value;\n  }\n\n  /**\n   * Add a disposal callback to the top of the stack to be invoked when stack is disposed.\n   * @param onDispose - A callback to invoke when this object is disposed.\n   */\n  defer(onDispose: () => void): void {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose();\n      },\n    });\n  }\n\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   * @returns The new `DisposableStack`.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move(): DisposableStack {\n    if (this.#disposed) {\n      throw new ReferenceError('A disposed stack can not use anything new');\n    }\n    const stack = new DisposableStack();\n    stack.#stack = this.#stack;\n    this.#stack = [];\n    this.#disposed = true;\n    return stack;\n  }\n\n  /**\n   * Disposes each resource in the stack in last-in-first-out (LIFO) manner.\n   */\n  [disposeSymbol](): void {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    const errors: unknown[] = [];\n    for (const resource of this.#stack.reverse()) {\n      try {\n        resource[disposeSymbol]();\n      } catch (e) {\n        errors.push(e);\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      let suppressed = null;\n      for (const error of errors.reverse()) {\n        if (suppressed === null) {\n          suppressed = error;\n        } else {\n          suppressed = new SuppressedError(error, suppressed);\n        }\n      }\n      throw suppressed;\n    }\n  }\n\n  readonly [Symbol.toStringTag] = 'DisposableStack';\n}\n\n/**\n * @internal\n */\nexport class AsyncDisposableStack {\n  #disposed = false;\n  #stack: AsyncDisposable[] = [];\n\n  /**\n   * Returns a value indicating whether the stack has been disposed.\n   */\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  /**\n   * Alias for `[Symbol.asyncDispose]()`.\n   */\n  async dispose(): Promise<void> {\n    await this[asyncDisposeSymbol]();\n  }\n\n  /**\n   * Adds a AsyncDisposable resource to the top of stack, returning the resource.\n   * Has no effect if provided `null` or `undefined`.\n   *\n   * @param value - A `AsyncDisposable` object, `null`, or `undefined`.\n   * `null` and `undefined` will not be added, but will be returned.\n   * @returns The provided `value`.\n   */\n  use<T extends AsyncDisposable | Disposable | null | undefined>(value: T): T {\n    if (value) {\n      const asyncDispose = (value as AsyncDisposable)[asyncDisposeSymbol];\n      const dispose = (value as Disposable)[disposeSymbol];\n\n      if (typeof asyncDispose === 'function') {\n        this.#stack.push(value as AsyncDisposable);\n      } else if (typeof dispose === 'function') {\n        this.#stack.push({\n          [asyncDisposeSymbol]: async () => {\n            (value as Disposable)[disposeSymbol]();\n          },\n        });\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Adds a non-disposable resource and a disposal callback to the top of the stack.\n   *\n   * @param value - A resource to be disposed.\n   * @param onDispose - A callback invoked to dispose the provided value.\n   * Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt<T>(value: T, onDispose: (value: T) => Promise<void>): T {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose(value);\n      },\n    });\n    return value;\n  }\n\n  /**\n   * Add a disposal callback to the top of the stack to be invoked when stack is disposed.\n   * @param onDispose - A callback to invoke when this object is disposed.\n   */\n  defer(onDispose: () => Promise<void>): void {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose();\n      },\n    });\n  }\n\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   * @returns The new `AsyncDisposableStack`.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move(): AsyncDisposableStack {\n    if (this.#disposed) {\n      throw new ReferenceError('A disposed stack can not use anything new');\n    }\n    const stack = new AsyncDisposableStack();\n    stack.#stack = this.#stack;\n    this.#stack = [];\n    this.#disposed = true;\n    return stack;\n  }\n\n  /**\n   * Disposes each resource in the stack in last-in-first-out (LIFO) manner.\n   */\n  async [asyncDisposeSymbol](): Promise<void> {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    const errors: unknown[] = [];\n    for (const resource of this.#stack.reverse()) {\n      try {\n        await resource[asyncDisposeSymbol]();\n      } catch (e) {\n        errors.push(e);\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      let suppressed = null;\n      for (const error of errors.reverse()) {\n        if (suppressed === null) {\n          suppressed = error;\n        } else {\n          suppressed = new SuppressedError(error, suppressed);\n        }\n      }\n      throw suppressed;\n    }\n  }\n\n  readonly [Symbol.toStringTag] = 'AsyncDisposableStack';\n}\n\n/**\n * @internal\n * Represents an error that occurs when multiple errors are thrown during\n * the disposal of resources. This class encapsulates the primary error and\n * any suppressed errors that occurred subsequently.\n */\nexport class SuppressedError extends Error {\n  #error: unknown;\n  #suppressed: unknown;\n\n  constructor(\n    error: unknown,\n    suppressed: unknown,\n    message = 'An error was suppressed during disposal',\n  ) {\n    super(message);\n    this.name = 'SuppressedError';\n    this.#error = error;\n    this.#suppressed = suppressed;\n  }\n\n  /**\n   * The primary error that occurred during disposal.\n   */\n  get error(): unknown {\n    return this.#error;\n  }\n\n  /**\n   * The suppressed error i.e. the error that was suppressed\n   * because it occurred later in the flow after the original error.\n   */\n  get suppressed(): unknown {\n    return this.#suppressed;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}