{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { spawnSync, spawn } from 'node:child_process';\nimport { createReadStream } from 'node:fs';\nimport { mkdir, readdir } from 'node:fs/promises';\nimport * as path from 'node:path';\nimport { Stream } from 'node:stream';\nimport debug from 'debug';\nconst debugFileUtil = debug('puppeteer:browsers:fileUtil');\n/**\n * @internal\n */\nexport async function unpackArchive(archivePath, folderPath) {\n  if (!path.isAbsolute(folderPath)) {\n    folderPath = path.resolve(process.cwd(), folderPath);\n  }\n  if (archivePath.endsWith('.zip')) {\n    const extractZip = await import('extract-zip');\n    await extractZip.default(archivePath, {\n      dir: folderPath\n    });\n  } else if (archivePath.endsWith('.tar.bz2')) {\n    await extractTar(archivePath, folderPath, 'bzip2');\n  } else if (archivePath.endsWith('.dmg')) {\n    await mkdir(folderPath);\n    await installDMG(archivePath, folderPath);\n  } else if (archivePath.endsWith('.exe')) {\n    // Firefox on Windows.\n    const result = spawnSync(archivePath, [`/ExtractDir=${folderPath}`], {\n      env: {\n        __compat_layer: 'RunAsInvoker'\n      }\n    });\n    if (result.status !== 0) {\n      throw new Error(`Failed to extract ${archivePath} to ${folderPath}: ${result.output}`);\n    }\n  } else if (archivePath.endsWith('.tar.xz')) {\n    await extractTar(archivePath, folderPath, 'xz');\n  } else {\n    throw new Error(`Unsupported archive format: ${archivePath}`);\n  }\n}\nfunction createTransformStream(child) {\n  const stream = new Stream.Transform({\n    transform(chunk, encoding, callback) {\n      if (!child.stdin.write(chunk, encoding)) {\n        child.stdin.once('drain', callback);\n      } else {\n        callback();\n      }\n    },\n    flush(callback) {\n      if (child.stdout.destroyed) {\n        callback();\n      } else {\n        child.stdin.end();\n        child.stdout.on('close', callback);\n      }\n    }\n  });\n  child.stdin.on('error', e => {\n    if ('code' in e && e.code === 'EPIPE') {\n      // finished before reading the file finished (i.e. head)\n      stream.emit('end');\n    } else {\n      stream.destroy(e);\n    }\n  });\n  child.stdout.on('data', data => {\n    return stream.push(data);\n  }).on('error', e => {\n    return stream.destroy(e);\n  });\n  child.once('close', () => {\n    return stream.end();\n  });\n  return stream;\n}\n/**\n * @internal\n */\nexport const internalConstantsForTesting = {\n  xz: 'xz',\n  bzip2: 'bzip2'\n};\n/**\n * @internal\n */\nasync function extractTar(tarPath, folderPath, decompressUtilityName) {\n  const tarFs = await import('tar-fs');\n  return await new Promise((fulfill, reject) => {\n    function handleError(utilityName) {\n      return error => {\n        if ('code' in error && error.code === 'ENOENT') {\n          error = new Error(`\\`${utilityName}\\` utility is required to unpack this archive`, {\n            cause: error\n          });\n        }\n        reject(error);\n      };\n    }\n    const unpack = spawn(internalConstantsForTesting[decompressUtilityName], ['-d'], {\n      stdio: ['pipe', 'pipe', 'inherit']\n    }).once('error', handleError(decompressUtilityName)).once('exit', code => {\n      debugFileUtil(`${decompressUtilityName} exited, code=${code}`);\n    });\n    const tar = tarFs.extract(folderPath);\n    tar.once('error', handleError('tar'));\n    tar.once('finish', fulfill);\n    createReadStream(tarPath).pipe(createTransformStream(unpack)).pipe(tar);\n  });\n}\n/**\n * @internal\n */\nasync function installDMG(dmgPath, folderPath) {\n  const {\n    stdout\n  } = spawnSync(`hdiutil`, ['attach', '-nobrowse', '-noautoopen', dmgPath]);\n  const volumes = stdout.toString('utf8').match(/\\/Volumes\\/(.*)/m);\n  if (!volumes) {\n    throw new Error(`Could not find volume path in ${stdout}`);\n  }\n  const mountPath = volumes[0];\n  try {\n    const fileNames = await readdir(mountPath);\n    const appName = fileNames.find(item => {\n      return typeof item === 'string' && item.endsWith('.app');\n    });\n    if (!appName) {\n      throw new Error(`Cannot find app in ${mountPath}`);\n    }\n    const mountedPath = path.join(mountPath, appName);\n    spawnSync('cp', ['-R', mountedPath, folderPath]);\n  } finally {\n    spawnSync('hdiutil', ['detach', mountPath, '-quiet']);\n  }\n}","map":{"version":3,"names":["spawnSync","spawn","createReadStream","mkdir","readdir","path","Stream","debug","debugFileUtil","unpackArchive","archivePath","folderPath","isAbsolute","resolve","process","cwd","endsWith","extractZip","default","dir","extractTar","installDMG","result","env","__compat_layer","status","Error","output","createTransformStream","child","stream","Transform","transform","chunk","encoding","callback","stdin","write","once","flush","stdout","destroyed","end","on","e","code","emit","destroy","data","push","internalConstantsForTesting","xz","bzip2","tarPath","decompressUtilityName","tarFs","Promise","fulfill","reject","handleError","utilityName","error","cause","unpack","stdio","tar","extract","pipe","dmgPath","volumes","toString","match","mountPath","fileNames","appName","find","item","mountedPath","join"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/@puppeteer/browsers/src/fileUtil.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {ChildProcessByStdio} from 'node:child_process';\nimport {spawnSync, spawn} from 'node:child_process';\nimport {createReadStream} from 'node:fs';\nimport {mkdir, readdir} from 'node:fs/promises';\nimport * as path from 'node:path';\nimport type {Readable, Transform, Writable} from 'node:stream';\nimport {Stream} from 'node:stream';\n\nimport debug from 'debug';\n\nconst debugFileUtil = debug('puppeteer:browsers:fileUtil');\n\n/**\n * @internal\n */\nexport async function unpackArchive(\n  archivePath: string,\n  folderPath: string,\n): Promise<void> {\n  if (!path.isAbsolute(folderPath)) {\n    folderPath = path.resolve(process.cwd(), folderPath);\n  }\n  if (archivePath.endsWith('.zip')) {\n    const extractZip = await import('extract-zip');\n    await extractZip.default(archivePath, {dir: folderPath});\n  } else if (archivePath.endsWith('.tar.bz2')) {\n    await extractTar(archivePath, folderPath, 'bzip2');\n  } else if (archivePath.endsWith('.dmg')) {\n    await mkdir(folderPath);\n    await installDMG(archivePath, folderPath);\n  } else if (archivePath.endsWith('.exe')) {\n    // Firefox on Windows.\n    const result = spawnSync(archivePath, [`/ExtractDir=${folderPath}`], {\n      env: {\n        __compat_layer: 'RunAsInvoker',\n      },\n    });\n    if (result.status !== 0) {\n      throw new Error(\n        `Failed to extract ${archivePath} to ${folderPath}: ${result.output}`,\n      );\n    }\n  } else if (archivePath.endsWith('.tar.xz')) {\n    await extractTar(archivePath, folderPath, 'xz');\n  } else {\n    throw new Error(`Unsupported archive format: ${archivePath}`);\n  }\n}\n\nfunction createTransformStream(\n  child: ChildProcessByStdio<Writable, Readable, null>,\n): Transform {\n  const stream = new Stream.Transform({\n    transform(chunk, encoding, callback) {\n      if (!child.stdin.write(chunk, encoding)) {\n        child.stdin.once('drain', callback);\n      } else {\n        callback();\n      }\n    },\n\n    flush(callback) {\n      if (child.stdout.destroyed) {\n        callback();\n      } else {\n        child.stdin.end();\n        child.stdout.on('close', callback);\n      }\n    },\n  });\n\n  child.stdin.on('error', e => {\n    if ('code' in e && e.code === 'EPIPE') {\n      // finished before reading the file finished (i.e. head)\n      stream.emit('end');\n    } else {\n      stream.destroy(e);\n    }\n  });\n\n  child.stdout\n    .on('data', data => {\n      return stream.push(data);\n    })\n    .on('error', e => {\n      return stream.destroy(e);\n    });\n\n  child.once('close', () => {\n    return stream.end();\n  });\n\n  return stream;\n}\n\n/**\n * @internal\n */\nexport const internalConstantsForTesting = {\n  xz: 'xz',\n  bzip2: 'bzip2',\n};\n\n/**\n * @internal\n */\nasync function extractTar(\n  tarPath: string,\n  folderPath: string,\n  decompressUtilityName: keyof typeof internalConstantsForTesting,\n): Promise<void> {\n  const tarFs = await import('tar-fs');\n  return await new Promise<void>((fulfill, reject) => {\n    function handleError(utilityName: string) {\n      return (error: Error) => {\n        if ('code' in error && error.code === 'ENOENT') {\n          error = new Error(\n            `\\`${utilityName}\\` utility is required to unpack this archive`,\n            {\n              cause: error,\n            },\n          );\n        }\n        reject(error);\n      };\n    }\n    const unpack = spawn(\n      internalConstantsForTesting[decompressUtilityName],\n      ['-d'],\n      {\n        stdio: ['pipe', 'pipe', 'inherit'],\n      },\n    )\n      .once('error', handleError(decompressUtilityName))\n      .once('exit', code => {\n        debugFileUtil(`${decompressUtilityName} exited, code=${code}`);\n      });\n\n    const tar = tarFs.extract(folderPath);\n    tar.once('error', handleError('tar'));\n    tar.once('finish', fulfill);\n    createReadStream(tarPath).pipe(createTransformStream(unpack)).pipe(tar);\n  });\n}\n\n/**\n * @internal\n */\nasync function installDMG(dmgPath: string, folderPath: string): Promise<void> {\n  const {stdout} = spawnSync(`hdiutil`, [\n    'attach',\n    '-nobrowse',\n    '-noautoopen',\n    dmgPath,\n  ]);\n\n  const volumes = stdout.toString('utf8').match(/\\/Volumes\\/(.*)/m);\n  if (!volumes) {\n    throw new Error(`Could not find volume path in ${stdout}`);\n  }\n  const mountPath = volumes[0]!;\n\n  try {\n    const fileNames = await readdir(mountPath);\n    const appName = fileNames.find(item => {\n      return typeof item === 'string' && item.endsWith('.app');\n    });\n    if (!appName) {\n      throw new Error(`Cannot find app in ${mountPath}`);\n    }\n    const mountedPath = path.join(mountPath!, appName);\n\n    spawnSync('cp', ['-R', mountedPath, folderPath]);\n  } finally {\n    spawnSync('hdiutil', ['detach', mountPath, '-quiet']);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}