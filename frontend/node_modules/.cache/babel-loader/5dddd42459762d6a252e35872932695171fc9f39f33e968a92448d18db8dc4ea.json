{"ast":null,"code":"import { headersArray, HTTPRequest, STATUS_TEXTS, handleError } from '../api/HTTPRequest.js';\nimport { debugError } from '../common/util.js';\nimport { stringToBase64 } from '../util/encoding.js';\n/**\n * @internal\n */\nexport class CdpHTTPRequest extends HTTPRequest {\n  id;\n  #client;\n  #isNavigationRequest;\n  #url;\n  #resourceType;\n  #method;\n  #hasPostData = false;\n  #postData;\n  #headers = {};\n  #frame;\n  #initiator;\n  get client() {\n    return this.#client;\n  }\n  set client(newClient) {\n    this.#client = newClient;\n  }\n  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {\n    super();\n    this.#client = client;\n    this.id = data.requestId;\n    this.#isNavigationRequest = data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#url = data.request.url + (data.request.urlFragment ?? '');\n    this.#resourceType = (data.type || 'other').toLowerCase();\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#hasPostData = data.request.hasPostData ?? false;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#initiator = data.initiator;\n    this.interception.enabled = allowInterception;\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n  url() {\n    return this.#url;\n  }\n  resourceType() {\n    return this.#resourceType;\n  }\n  method() {\n    return this.#method;\n  }\n  postData() {\n    return this.#postData;\n  }\n  hasPostData() {\n    return this.#hasPostData;\n  }\n  async fetchPostData() {\n    try {\n      const result = await this.#client.send('Network.getRequestPostData', {\n        requestId: this.id\n      });\n      return result.postData;\n    } catch (err) {\n      debugError(err);\n      return;\n    }\n  }\n  headers() {\n    return this.#headers;\n  }\n  response() {\n    return this._response;\n  }\n  frame() {\n    return this.#frame;\n  }\n  isNavigationRequest() {\n    return this.#isNavigationRequest;\n  }\n  initiator() {\n    return this.#initiator;\n  }\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  failure() {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText\n    };\n  }\n  /**\n   * @internal\n   */\n  async _continue(overrides = {}) {\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this.interception.handled = true;\n    const postDataBinaryBase64 = postData ? stringToBase64(postData) : undefined;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');\n    }\n    await this.#client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData: postDataBinaryBase64,\n      headers: headers ? headersArray(headers) : undefined\n    }).catch(error => {\n      this.interception.handled = false;\n      return handleError(error);\n    });\n  }\n  async _respond(response) {\n    this.interception.handled = true;\n    let parsedBody;\n    if (response.body) {\n      parsedBody = HTTPRequest.getResponse(response.body);\n    }\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map(item => {\n          return String(item);\n        }) : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (parsedBody?.contentLength && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(parsedBody.contentLength);\n    }\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');\n    }\n    await this.#client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: status,\n      responsePhrase: STATUS_TEXTS[status],\n      responseHeaders: headersArray(responseHeaders),\n      body: parsedBody?.base64\n    }).catch(error => {\n      this.interception.handled = false;\n      return handleError(error);\n    });\n  }\n  async _abort(errorReason) {\n    this.interception.handled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');\n    }\n    await this.#client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason: errorReason || 'Failed'\n    }).catch(handleError);\n  }\n}","map":{"version":3,"names":["headersArray","HTTPRequest","STATUS_TEXTS","handleError","debugError","stringToBase64","CdpHTTPRequest","id","client","isNavigationRequest","url","resourceType","method","hasPostData","postData","headers","frame","initiator","newClient","constructor","interceptionId","allowInterception","data","redirectChain","requestId","loaderId","type","_interceptionId","request","urlFragment","toLowerCase","_redirectChain","interception","enabled","key","value","Object","entries","fetchPostData","result","send","err","response","_response","slice","failure","_failureText","errorText","_continue","overrides","handled","postDataBinaryBase64","undefined","Error","catch","error","_respond","parsedBody","body","getResponse","responseHeaders","header","keys","Array","isArray","map","item","String","contentType","contentLength","status","responseCode","responsePhrase","base64","_abort","errorReason"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/HTTPRequest.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Frame} from '../api/Frame.js';\nimport {\n  type ContinueRequestOverrides,\n  headersArray,\n  HTTPRequest,\n  type ResourceType,\n  type ResponseForRequest,\n  STATUS_TEXTS,\n  handleError,\n} from '../api/HTTPRequest.js';\nimport {debugError} from '../common/util.js';\nimport {stringToBase64} from '../util/encoding.js';\n\nimport type {CdpHTTPResponse} from './HTTPResponse.js';\n\n/**\n * @internal\n */\nexport class CdpHTTPRequest extends HTTPRequest {\n  override id: string;\n  declare _redirectChain: CdpHTTPRequest[];\n  declare _response: CdpHTTPResponse | null;\n\n  #client: CDPSession;\n  #isNavigationRequest: boolean;\n\n  #url: string;\n  #resourceType: ResourceType;\n\n  #method: string;\n  #hasPostData = false;\n  #postData?: string;\n  #headers: Record<string, string> = {};\n  #frame: Frame | null;\n  #initiator?: Protocol.Network.Initiator;\n\n  override get client(): CDPSession {\n    return this.#client;\n  }\n\n  override set client(newClient: CDPSession) {\n    this.#client = newClient;\n  }\n\n  constructor(\n    client: CDPSession,\n    frame: Frame | null,\n    interceptionId: string | undefined,\n    allowInterception: boolean,\n    data: {\n      /**\n       * Request identifier.\n       */\n      requestId: Protocol.Network.RequestId;\n      /**\n       * Loader identifier. Empty string if the request is fetched from worker.\n       */\n      loaderId?: Protocol.Network.LoaderId;\n      /**\n       * URL of the document this request is loaded for.\n       */\n      documentURL?: string;\n      /**\n       * Request data.\n       */\n      request: Protocol.Network.Request;\n      /**\n       * Request initiator.\n       */\n      initiator?: Protocol.Network.Initiator;\n      /**\n       * Type of this resource.\n       */\n      type?: Protocol.Network.ResourceType;\n    },\n    redirectChain: CdpHTTPRequest[],\n  ) {\n    super();\n    this.#client = client;\n    this.id = data.requestId;\n    this.#isNavigationRequest =\n      data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#url = data.request.url + (data.request.urlFragment ?? '');\n    this.#resourceType = (data.type || 'other').toLowerCase() as ResourceType;\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#hasPostData = data.request.hasPostData ?? false;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#initiator = data.initiator;\n\n    this.interception.enabled = allowInterception;\n\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n\n  override url(): string {\n    return this.#url;\n  }\n\n  override resourceType(): ResourceType {\n    return this.#resourceType;\n  }\n\n  override method(): string {\n    return this.#method;\n  }\n\n  override postData(): string | undefined {\n    return this.#postData;\n  }\n\n  override hasPostData(): boolean {\n    return this.#hasPostData;\n  }\n\n  override async fetchPostData(): Promise<string | undefined> {\n    try {\n      const result = await this.#client.send('Network.getRequestPostData', {\n        requestId: this.id,\n      });\n      return result.postData;\n    } catch (err) {\n      debugError(err);\n      return;\n    }\n  }\n\n  override headers(): Record<string, string> {\n    return this.#headers;\n  }\n\n  override response(): CdpHTTPResponse | null {\n    return this._response;\n  }\n\n  override frame(): Frame | null {\n    return this.#frame;\n  }\n\n  override isNavigationRequest(): boolean {\n    return this.#isNavigationRequest;\n  }\n\n  override initiator(): Protocol.Network.Initiator | undefined {\n    return this.#initiator;\n  }\n\n  override redirectChain(): CdpHTTPRequest[] {\n    return this._redirectChain.slice();\n  }\n\n  override failure(): {errorText: string} | null {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async _continue(overrides: ContinueRequestOverrides = {}): Promise<void> {\n    const {url, method, postData, headers} = overrides;\n    this.interception.handled = true;\n\n    const postDataBinaryBase64 = postData\n      ? stringToBase64(postData)\n      : undefined;\n\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.continueRequest',\n      );\n    }\n    await this.#client\n      .send('Fetch.continueRequest', {\n        requestId: this._interceptionId,\n        url,\n        method,\n        postData: postDataBinaryBase64,\n        headers: headers ? headersArray(headers) : undefined,\n      })\n      .catch(error => {\n        this.interception.handled = false;\n        return handleError(error);\n      });\n  }\n\n  async _respond(response: Partial<ResponseForRequest>): Promise<void> {\n    this.interception.handled = true;\n\n    let parsedBody:\n      | {\n          contentLength: number;\n          base64: string;\n        }\n      | undefined;\n    if (response.body) {\n      parsedBody = HTTPRequest.getResponse(response.body);\n    }\n\n    const responseHeaders: Record<string, string | string[]> = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n\n        responseHeaders[header.toLowerCase()] = Array.isArray(value)\n          ? value.map(item => {\n              return String(item);\n            })\n          : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (parsedBody?.contentLength && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(parsedBody.contentLength);\n    }\n\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest',\n      );\n    }\n    await this.#client\n      .send('Fetch.fulfillRequest', {\n        requestId: this._interceptionId,\n        responseCode: status,\n        responsePhrase: STATUS_TEXTS[status],\n        responseHeaders: headersArray(responseHeaders),\n        body: parsedBody?.base64,\n      })\n      .catch(error => {\n        this.interception.handled = false;\n        return handleError(error);\n      });\n  }\n\n  async _abort(\n    errorReason: Protocol.Network.ErrorReason | null,\n  ): Promise<void> {\n    this.interception.handled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.failRequest',\n      );\n    }\n    await this.#client\n      .send('Fetch.failRequest', {\n        requestId: this._interceptionId,\n        errorReason: errorReason || 'Failed',\n      })\n      .catch(handleError);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}