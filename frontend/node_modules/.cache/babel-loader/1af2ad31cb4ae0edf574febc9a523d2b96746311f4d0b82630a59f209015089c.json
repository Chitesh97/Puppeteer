{"ast":null,"code":"\"use strict\";\n\n/* eslint-disable no-param-reassign */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address4 = void 0;\nconst common = __importStar(require(\"./common\"));\nconst constants = __importStar(require(\"./v4/constants\"));\nconst address_error_1 = require(\"./address-error\");\n/**\n * Represents an IPv4 address\n * @class Address4\n * @param {string} address - An IPv4 address string\n */\nclass Address4 {\n  constructor(address) {\n    this.groups = constants.GROUPS;\n    this.parsedAddress = [];\n    this.parsedSubnet = '';\n    this.subnet = '/32';\n    this.subnetMask = 32;\n    this.v4 = true;\n    /**\n     * Returns true if the address is correct, false otherwise\n     * @memberof Address4\n     * @instance\n     * @returns {Boolean}\n     */\n    this.isCorrect = common.isCorrect(constants.BITS);\n    /**\n     * Returns true if the given address is in the subnet of the current address\n     * @memberof Address4\n     * @instance\n     * @returns {boolean}\n     */\n    this.isInSubnet = common.isInSubnet;\n    this.address = address;\n    const subnet = constants.RE_SUBNET_STRING.exec(address);\n    if (subnet) {\n      this.parsedSubnet = subnet[0].replace('/', '');\n      this.subnetMask = parseInt(this.parsedSubnet, 10);\n      this.subnet = `/${this.subnetMask}`;\n      if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {\n        throw new address_error_1.AddressError('Invalid subnet mask.');\n      }\n      address = address.replace(constants.RE_SUBNET_STRING, '');\n    }\n    this.addressMinusSuffix = address;\n    this.parsedAddress = this.parse(address);\n  }\n  static isValid(address) {\n    try {\n      // eslint-disable-next-line no-new\n      new Address4(address);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /*\n   * Parses a v4 address\n   */\n  parse(address) {\n    const groups = address.split('.');\n    if (!address.match(constants.RE_ADDRESS)) {\n      throw new address_error_1.AddressError('Invalid IPv4 address.');\n    }\n    return groups;\n  }\n  /**\n   * Returns the correct form of an address\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  correctForm() {\n    return this.parsedAddress.map(part => parseInt(part, 10)).join('.');\n  }\n  /**\n   * Converts a hex string to an IPv4 address object\n   * @memberof Address4\n   * @static\n   * @param {string} hex - a hex string to convert\n   * @returns {Address4}\n   */\n  static fromHex(hex) {\n    const padded = hex.replace(/:/g, '').padStart(8, '0');\n    const groups = [];\n    let i;\n    for (i = 0; i < 8; i += 2) {\n      const h = padded.slice(i, i + 2);\n      groups.push(parseInt(h, 16));\n    }\n    return new Address4(groups.join('.'));\n  }\n  /**\n   * Converts an integer into a IPv4 address object\n   * @memberof Address4\n   * @static\n   * @param {integer} integer - a number to convert\n   * @returns {Address4}\n   */\n  static fromInteger(integer) {\n    return Address4.fromHex(integer.toString(16));\n  }\n  /**\n   * Return an address from in-addr.arpa form\n   * @memberof Address4\n   * @static\n   * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address\n   * @returns {Adress4}\n   * @example\n   * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)\n   * address.correctForm(); // '192.0.2.42'\n   */\n  static fromArpa(arpaFormAddress) {\n    // remove ending \".in-addr.arpa.\" or just \".\"\n    const leader = arpaFormAddress.replace(/(\\.in-addr\\.arpa)?\\.$/, '');\n    const address = leader.split('.').reverse().join('.');\n    return new Address4(address);\n  }\n  /**\n   * Converts an IPv4 address object to a hex string\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  toHex() {\n    return this.parsedAddress.map(part => common.stringToPaddedHex(part)).join(':');\n  }\n  /**\n   * Converts an IPv4 address object to an array of bytes\n   * @memberof Address4\n   * @instance\n   * @returns {Array}\n   */\n  toArray() {\n    return this.parsedAddress.map(part => parseInt(part, 10));\n  }\n  /**\n   * Converts an IPv4 address object to an IPv6 address group\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  toGroup6() {\n    const output = [];\n    let i;\n    for (i = 0; i < constants.GROUPS; i += 2) {\n      output.push(`${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(this.parsedAddress[i + 1])}`);\n    }\n    return output.join(':');\n  }\n  /**\n   * Returns the address as a `bigint`\n   * @memberof Address4\n   * @instance\n   * @returns {bigint}\n   */\n  bigInt() {\n    return BigInt(`0x${this.parsedAddress.map(n => common.stringToPaddedHex(n)).join('')}`);\n  }\n  /**\n   * Helper function getting start address.\n   * @memberof Address4\n   * @instance\n   * @returns {bigint}\n   */\n  _startAddress() {\n    return BigInt(`0b${this.mask() + '0'.repeat(constants.BITS - this.subnetMask)}`);\n  }\n  /**\n   * The first address in the range given by this address' subnet.\n   * Often referred to as the Network Address.\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  startAddress() {\n    return Address4.fromBigInt(this._startAddress());\n  }\n  /**\n   * The first host address in the range given by this address's subnet ie\n   * the first address after the Network Address\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  startAddressExclusive() {\n    const adjust = BigInt('1');\n    return Address4.fromBigInt(this._startAddress() + adjust);\n  }\n  /**\n   * Helper function getting end address.\n   * @memberof Address4\n   * @instance\n   * @returns {bigint}\n   */\n  _endAddress() {\n    return BigInt(`0b${this.mask() + '1'.repeat(constants.BITS - this.subnetMask)}`);\n  }\n  /**\n   * The last address in the range given by this address' subnet\n   * Often referred to as the Broadcast\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  endAddress() {\n    return Address4.fromBigInt(this._endAddress());\n  }\n  /**\n   * The last host address in the range given by this address's subnet ie\n   * the last address prior to the Broadcast Address\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  endAddressExclusive() {\n    const adjust = BigInt('1');\n    return Address4.fromBigInt(this._endAddress() - adjust);\n  }\n  /**\n   * Converts a BigInt to a v4 address object\n   * @memberof Address4\n   * @static\n   * @param {bigint} bigInt - a BigInt to convert\n   * @returns {Address4}\n   */\n  static fromBigInt(bigInt) {\n    return Address4.fromHex(bigInt.toString(16));\n  }\n  /**\n   * Returns the first n bits of the address, defaulting to the\n   * subnet mask\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  mask(mask) {\n    if (mask === undefined) {\n      mask = this.subnetMask;\n    }\n    return this.getBitsBase2(0, mask);\n  }\n  /**\n   * Returns the bits in the given range as a base-2 string\n   * @memberof Address4\n   * @instance\n   * @returns {string}\n   */\n  getBitsBase2(start, end) {\n    return this.binaryZeroPad().slice(start, end);\n  }\n  /**\n   * Return the reversed ip6.arpa form of the address\n   * @memberof Address4\n   * @param {Object} options\n   * @param {boolean} options.omitSuffix - omit the \"in-addr.arpa\" suffix\n   * @instance\n   * @returns {String}\n   */\n  reverseForm(options) {\n    if (!options) {\n      options = {};\n    }\n    const reversed = this.correctForm().split('.').reverse().join('.');\n    if (options.omitSuffix) {\n      return reversed;\n    }\n    return `${reversed}.in-addr.arpa.`;\n  }\n  /**\n   * Returns true if the given address is a multicast address\n   * @memberof Address4\n   * @instance\n   * @returns {boolean}\n   */\n  isMulticast() {\n    return this.isInSubnet(new Address4('224.0.0.0/4'));\n  }\n  /**\n   * Returns a zero-padded base-2 string representation of the address\n   * @memberof Address4\n   * @instance\n   * @returns {string}\n   */\n  binaryZeroPad() {\n    return this.bigInt().toString(2).padStart(constants.BITS, '0');\n  }\n  /**\n   * Groups an IPv4 address for inclusion at the end of an IPv6 address\n   * @returns {String}\n   */\n  groupForV6() {\n    const segments = this.parsedAddress;\n    return this.address.replace(constants.RE_ADDRESS, `<span class=\"hover-group group-v4 group-6\">${segments.slice(0, 2).join('.')}</span>.<span class=\"hover-group group-v4 group-7\">${segments.slice(2, 4).join('.')}</span>`);\n  }\n}\nexports.Address4 = Address4;","map":{"version":3,"names":["common","__importStar","require","constants","address_error_1","Address4","constructor","address","groups","GROUPS","parsedAddress","parsedSubnet","subnet","subnetMask","v4","isCorrect","BITS","isInSubnet","RE_SUBNET_STRING","exec","replace","parseInt","AddressError","addressMinusSuffix","parse","isValid","e","split","match","RE_ADDRESS","correctForm","map","part","join","fromHex","hex","padded","padStart","i","h","slice","push","fromInteger","integer","toString","fromArpa","arpaFormAddress","leader","reverse","toHex","stringToPaddedHex","toArray","toGroup6","output","bigInt","BigInt","n","_startAddress","mask","repeat","startAddress","fromBigInt","startAddressExclusive","adjust","_endAddress","endAddress","endAddressExclusive","undefined","getBitsBase2","start","end","binaryZeroPad","reverseForm","options","reversed","omitSuffix","isMulticast","groupForV6","segments","exports"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/ip-address/src/ipv4.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\n\nimport * as common from './common';\nimport * as constants from './v4/constants';\nimport { AddressError } from './address-error';\n\n/**\n * Represents an IPv4 address\n * @class Address4\n * @param {string} address - An IPv4 address string\n */\nexport class Address4 {\n  address: string;\n  addressMinusSuffix?: string;\n  groups: number = constants.GROUPS;\n  parsedAddress: string[] = [];\n  parsedSubnet: string = '';\n  subnet: string = '/32';\n  subnetMask: number = 32;\n  v4: boolean = true;\n\n  constructor(address: string) {\n    this.address = address;\n\n    const subnet = constants.RE_SUBNET_STRING.exec(address);\n\n    if (subnet) {\n      this.parsedSubnet = subnet[0].replace('/', '');\n      this.subnetMask = parseInt(this.parsedSubnet, 10);\n      this.subnet = `/${this.subnetMask}`;\n\n      if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {\n        throw new AddressError('Invalid subnet mask.');\n      }\n\n      address = address.replace(constants.RE_SUBNET_STRING, '');\n    }\n\n    this.addressMinusSuffix = address;\n\n    this.parsedAddress = this.parse(address);\n  }\n\n  static isValid(address: string): boolean {\n    try {\n      // eslint-disable-next-line no-new\n      new Address4(address);\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /*\n   * Parses a v4 address\n   */\n  parse(address: string) {\n    const groups = address.split('.');\n\n    if (!address.match(constants.RE_ADDRESS)) {\n      throw new AddressError('Invalid IPv4 address.');\n    }\n\n    return groups;\n  }\n\n  /**\n   * Returns the correct form of an address\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  correctForm(): string {\n    return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');\n  }\n\n  /**\n   * Returns true if the address is correct, false otherwise\n   * @memberof Address4\n   * @instance\n   * @returns {Boolean}\n   */\n  isCorrect = common.isCorrect(constants.BITS);\n\n  /**\n   * Converts a hex string to an IPv4 address object\n   * @memberof Address4\n   * @static\n   * @param {string} hex - a hex string to convert\n   * @returns {Address4}\n   */\n  static fromHex(hex: string): Address4 {\n    const padded = hex.replace(/:/g, '').padStart(8, '0');\n    const groups = [];\n    let i;\n\n    for (i = 0; i < 8; i += 2) {\n      const h = padded.slice(i, i + 2);\n\n      groups.push(parseInt(h, 16));\n    }\n\n    return new Address4(groups.join('.'));\n  }\n\n  /**\n   * Converts an integer into a IPv4 address object\n   * @memberof Address4\n   * @static\n   * @param {integer} integer - a number to convert\n   * @returns {Address4}\n   */\n  static fromInteger(integer: number): Address4 {\n    return Address4.fromHex(integer.toString(16));\n  }\n\n  /**\n   * Return an address from in-addr.arpa form\n   * @memberof Address4\n   * @static\n   * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address\n   * @returns {Adress4}\n   * @example\n   * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)\n   * address.correctForm(); // '192.0.2.42'\n   */\n  static fromArpa(arpaFormAddress: string): Address4 {\n    // remove ending \".in-addr.arpa.\" or just \".\"\n    const leader = arpaFormAddress.replace(/(\\.in-addr\\.arpa)?\\.$/, '');\n\n    const address = leader.split('.').reverse().join('.');\n\n    return new Address4(address);\n  }\n\n  /**\n   * Converts an IPv4 address object to a hex string\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  toHex(): string {\n    return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(':');\n  }\n\n  /**\n   * Converts an IPv4 address object to an array of bytes\n   * @memberof Address4\n   * @instance\n   * @returns {Array}\n   */\n  toArray(): number[] {\n    return this.parsedAddress.map((part) => parseInt(part, 10));\n  }\n\n  /**\n   * Converts an IPv4 address object to an IPv6 address group\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  toGroup6(): string {\n    const output = [];\n    let i;\n\n    for (i = 0; i < constants.GROUPS; i += 2) {\n      output.push(\n        `${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(\n          this.parsedAddress[i + 1],\n        )}`,\n      );\n    }\n\n    return output.join(':');\n  }\n\n  /**\n   * Returns the address as a `bigint`\n   * @memberof Address4\n   * @instance\n   * @returns {bigint}\n   */\n  bigInt(): bigint {\n    return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join('')}`);\n  }\n\n  /**\n   * Helper function getting start address.\n   * @memberof Address4\n   * @instance\n   * @returns {bigint}\n   */\n  _startAddress(): bigint {\n    return BigInt(`0b${this.mask() + '0'.repeat(constants.BITS - this.subnetMask)}`);\n  }\n\n  /**\n   * The first address in the range given by this address' subnet.\n   * Often referred to as the Network Address.\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  startAddress(): Address4 {\n    return Address4.fromBigInt(this._startAddress());\n  }\n\n  /**\n   * The first host address in the range given by this address's subnet ie\n   * the first address after the Network Address\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  startAddressExclusive(): Address4 {\n    const adjust = BigInt('1');\n    return Address4.fromBigInt(this._startAddress() + adjust);\n  }\n\n  /**\n   * Helper function getting end address.\n   * @memberof Address4\n   * @instance\n   * @returns {bigint}\n   */\n  _endAddress(): bigint {\n    return BigInt(`0b${this.mask() + '1'.repeat(constants.BITS - this.subnetMask)}`);\n  }\n\n  /**\n   * The last address in the range given by this address' subnet\n   * Often referred to as the Broadcast\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  endAddress(): Address4 {\n    return Address4.fromBigInt(this._endAddress());\n  }\n\n  /**\n   * The last host address in the range given by this address's subnet ie\n   * the last address prior to the Broadcast Address\n   * @memberof Address4\n   * @instance\n   * @returns {Address4}\n   */\n  endAddressExclusive(): Address4 {\n    const adjust = BigInt('1');\n    return Address4.fromBigInt(this._endAddress() - adjust);\n  }\n\n  /**\n   * Converts a BigInt to a v4 address object\n   * @memberof Address4\n   * @static\n   * @param {bigint} bigInt - a BigInt to convert\n   * @returns {Address4}\n   */\n  static fromBigInt(bigInt: bigint): Address4 {\n    return Address4.fromHex(bigInt.toString(16));\n  }\n\n  /**\n   * Returns the first n bits of the address, defaulting to the\n   * subnet mask\n   * @memberof Address4\n   * @instance\n   * @returns {String}\n   */\n  mask(mask?: number): string {\n    if (mask === undefined) {\n      mask = this.subnetMask;\n    }\n\n    return this.getBitsBase2(0, mask);\n  }\n\n  /**\n   * Returns the bits in the given range as a base-2 string\n   * @memberof Address4\n   * @instance\n   * @returns {string}\n   */\n  getBitsBase2(start: number, end: number): string {\n    return this.binaryZeroPad().slice(start, end);\n  }\n\n  /**\n   * Return the reversed ip6.arpa form of the address\n   * @memberof Address4\n   * @param {Object} options\n   * @param {boolean} options.omitSuffix - omit the \"in-addr.arpa\" suffix\n   * @instance\n   * @returns {String}\n   */\n  reverseForm(options?: common.ReverseFormOptions): string {\n    if (!options) {\n      options = {};\n    }\n\n    const reversed = this.correctForm().split('.').reverse().join('.');\n\n    if (options.omitSuffix) {\n      return reversed;\n    }\n\n    return `${reversed}.in-addr.arpa.`;\n  }\n\n  /**\n   * Returns true if the given address is in the subnet of the current address\n   * @memberof Address4\n   * @instance\n   * @returns {boolean}\n   */\n  isInSubnet = common.isInSubnet;\n\n  /**\n   * Returns true if the given address is a multicast address\n   * @memberof Address4\n   * @instance\n   * @returns {boolean}\n   */\n  isMulticast(): boolean {\n    return this.isInSubnet(new Address4('224.0.0.0/4'));\n  }\n\n  /**\n   * Returns a zero-padded base-2 string representation of the address\n   * @memberof Address4\n   * @instance\n   * @returns {string}\n   */\n  binaryZeroPad(): string {\n    return this.bigInt().toString(2).padStart(constants.BITS, '0');\n  }\n\n  /**\n   * Groups an IPv4 address for inclusion at the end of an IPv6 address\n   * @returns {String}\n   */\n  groupForV6(): string {\n    const segments = this.parsedAddress;\n\n    return this.address.replace(\n      constants.RE_ADDRESS,\n      `<span class=\"hover-group group-v4 group-6\">${segments\n        .slice(0, 2)\n        .join('.')}</span>.<span class=\"hover-group group-v4 group-7\">${segments\n        .slice(2, 4)\n        .join('.')}</span>`,\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}