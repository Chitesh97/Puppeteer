{"ast":null,"code":"import { EventEmitter } from '../common/EventEmitter.js';\nimport { debugError } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { DisposableStack } from '../util/disposable.js';\n/**\n * @internal\n */\nexport class PipeTransport {\n  #pipeWrite;\n  #subscriptions = new DisposableStack();\n  #isClosed = false;\n  #pendingMessage = '';\n  onclose;\n  onmessage;\n  constructor(pipeWrite, pipeRead) {\n    this.#pipeWrite = pipeWrite;\n    const pipeReadEmitter = this.#subscriptions.use(\n    // NodeJS event emitters don't support `*` so we need to typecast\n    // As long as we don't use it we should be OK.\n    new EventEmitter(pipeRead));\n    pipeReadEmitter.on('data', buffer => {\n      return this.#dispatch(buffer);\n    });\n    pipeReadEmitter.on('close', () => {\n      if (this.onclose) {\n        this.onclose.call(null);\n      }\n    });\n    pipeReadEmitter.on('error', debugError);\n    const pipeWriteEmitter = this.#subscriptions.use(\n    // NodeJS event emitters don't support `*` so we need to typecast\n    // As long as we don't use it we should be OK.\n    new EventEmitter(pipeWrite));\n    pipeWriteEmitter.on('error', debugError);\n  }\n  send(message) {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n    this.#pipeWrite.write(message);\n    this.#pipeWrite.write('\\0');\n  }\n  #dispatch(buffer) {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this.#pendingMessage += buffer.toString();\n      return;\n    }\n    const message = this.#pendingMessage + buffer.toString(undefined, 0, end);\n    setImmediate(() => {\n      if (this.onmessage) {\n        this.onmessage.call(null, message);\n      }\n    });\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      const message = buffer.toString(undefined, start, end);\n      setImmediate(() => {\n        if (this.onmessage) {\n          this.onmessage.call(null, message);\n        }\n      });\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this.#pendingMessage = buffer.toString(undefined, start);\n  }\n  close() {\n    this.#isClosed = true;\n    this.#subscriptions.dispose();\n  }\n}","map":{"version":3,"names":["EventEmitter","debugError","assert","DisposableStack","PipeTransport","pipeWrite","subscriptions","isClosed","pendingMessage","onclose","onmessage","constructor","pipeRead","pipeReadEmitter","use","on","buffer","dispatch","call","pipeWriteEmitter","send","message","write","#dispatch","end","indexOf","toString","undefined","setImmediate","start","close","dispose"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/node/PipeTransport.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type {ConnectionTransport} from '../common/ConnectionTransport.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {debugError} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {DisposableStack} from '../util/disposable.js';\n\n/**\n * @internal\n */\nexport class PipeTransport implements ConnectionTransport {\n  #pipeWrite: NodeJS.WritableStream;\n  #subscriptions = new DisposableStack();\n\n  #isClosed = false;\n  #pendingMessage = '';\n\n  onclose?: () => void;\n  onmessage?: (value: string) => void;\n\n  constructor(\n    pipeWrite: NodeJS.WritableStream,\n    pipeRead: NodeJS.ReadableStream,\n  ) {\n    this.#pipeWrite = pipeWrite;\n    const pipeReadEmitter = this.#subscriptions.use(\n      // NodeJS event emitters don't support `*` so we need to typecast\n      // As long as we don't use it we should be OK.\n      new EventEmitter(\n        pipeRead as unknown as EventEmitter<Record<string, any>>,\n      ),\n    );\n    pipeReadEmitter.on('data', (buffer: Buffer) => {\n      return this.#dispatch(buffer);\n    });\n    pipeReadEmitter.on('close', () => {\n      if (this.onclose) {\n        this.onclose.call(null);\n      }\n    });\n    pipeReadEmitter.on('error', debugError);\n    const pipeWriteEmitter = this.#subscriptions.use(\n      // NodeJS event emitters don't support `*` so we need to typecast\n      // As long as we don't use it we should be OK.\n      new EventEmitter(\n        pipeWrite as unknown as EventEmitter<Record<string, any>>,\n      ),\n    );\n    pipeWriteEmitter.on('error', debugError);\n  }\n\n  send(message: string): void {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n\n    this.#pipeWrite.write(message);\n    this.#pipeWrite.write('\\0');\n  }\n\n  #dispatch(buffer: Buffer): void {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this.#pendingMessage += buffer.toString();\n      return;\n    }\n    const message = this.#pendingMessage + buffer.toString(undefined, 0, end);\n    setImmediate(() => {\n      if (this.onmessage) {\n        this.onmessage.call(null, message);\n      }\n    });\n\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      const message = buffer.toString(undefined, start, end);\n      setImmediate(() => {\n        if (this.onmessage) {\n          this.onmessage.call(null, message);\n        }\n      });\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this.#pendingMessage = buffer.toString(undefined, start);\n  }\n\n  close(): void {\n    this.#isClosed = true;\n    this.#subscriptions.dispose();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}