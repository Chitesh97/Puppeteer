{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Browser as BrowserBase } from '../api/Browser.js';\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { CdpBrowserContext } from './BrowserContext.js';\nimport { DevToolsTarget, InitializationStatus, OtherTarget, PageTarget, WorkerTarget } from './Target.js';\nimport { TargetManager } from './TargetManager.js';\n/**\n * @internal\n */\nexport class CdpBrowser extends BrowserBase {\n  protocol = 'cdp';\n  static async _create(connection, contextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, networkEnabled = true) {\n    const browser = new CdpBrowser(connection, contextIds, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets, networkEnabled);\n    if (acceptInsecureCerts) {\n      await connection.send('Security.setIgnoreCertificateErrors', {\n        ignore: true\n      });\n    }\n    await browser._attach(downloadBehavior);\n    return browser;\n  }\n  #defaultViewport;\n  #process;\n  #connection;\n  #closeCallback;\n  #targetFilterCallback;\n  #isPageTargetCallback;\n  #defaultContext;\n  #contexts = new Map();\n  #networkEnabled = true;\n  #targetManager;\n  constructor(connection, contextIds, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, networkEnabled = true) {\n    super();\n    this.#networkEnabled = networkEnabled;\n    this.#defaultViewport = defaultViewport;\n    this.#process = process;\n    this.#connection = connection;\n    this.#closeCallback = closeCallback || (() => {});\n    this.#targetFilterCallback = targetFilterCallback || (() => {\n      return true;\n    });\n    this.#setIsPageTargetCallback(isPageTargetCallback);\n    this.#targetManager = new TargetManager(connection, this.#createTarget, this.#targetFilterCallback, waitForInitiallyDiscoveredTargets);\n    this.#defaultContext = new CdpBrowserContext(this.#connection, this);\n    for (const contextId of contextIds) {\n      this.#contexts.set(contextId, new CdpBrowserContext(this.#connection, this, contextId));\n    }\n  }\n  #emitDisconnected = () => {\n    this.emit(\"disconnected\" /* BrowserEvent.Disconnected */, undefined);\n  };\n  async _attach(downloadBehavior) {\n    this.#connection.on(CDPSessionEvent.Disconnected, this.#emitDisconnected);\n    if (downloadBehavior) {\n      await this.#defaultContext.setDownloadBehavior(downloadBehavior);\n    }\n    this.#targetManager.on(\"targetAvailable\" /* TargetManagerEvent.TargetAvailable */, this.#onAttachedToTarget);\n    this.#targetManager.on(\"targetGone\" /* TargetManagerEvent.TargetGone */, this.#onDetachedFromTarget);\n    this.#targetManager.on(\"targetChanged\" /* TargetManagerEvent.TargetChanged */, this.#onTargetChanged);\n    this.#targetManager.on(\"targetDiscovered\" /* TargetManagerEvent.TargetDiscovered */, this.#onTargetDiscovered);\n    await this.#targetManager.initialize();\n  }\n  _detach() {\n    this.#connection.off(CDPSessionEvent.Disconnected, this.#emitDisconnected);\n    this.#targetManager.off(\"targetAvailable\" /* TargetManagerEvent.TargetAvailable */, this.#onAttachedToTarget);\n    this.#targetManager.off(\"targetGone\" /* TargetManagerEvent.TargetGone */, this.#onDetachedFromTarget);\n    this.#targetManager.off(\"targetChanged\" /* TargetManagerEvent.TargetChanged */, this.#onTargetChanged);\n    this.#targetManager.off(\"targetDiscovered\" /* TargetManagerEvent.TargetDiscovered */, this.#onTargetDiscovered);\n  }\n  process() {\n    return this.#process ?? null;\n  }\n  _targetManager() {\n    return this.#targetManager;\n  }\n  #setIsPageTargetCallback(isPageTargetCallback) {\n    this.#isPageTargetCallback = isPageTargetCallback || (target => {\n      return target.type() === 'page' || target.type() === 'background_page' || target.type() === 'webview';\n    });\n  }\n  _getIsPageTargetCallback() {\n    return this.#isPageTargetCallback;\n  }\n  async createBrowserContext(options = {}) {\n    const {\n      proxyServer,\n      proxyBypassList,\n      downloadBehavior\n    } = options;\n    const {\n      browserContextId\n    } = await this.#connection.send('Target.createBrowserContext', {\n      proxyServer,\n      proxyBypassList: proxyBypassList && proxyBypassList.join(',')\n    });\n    const context = new CdpBrowserContext(this.#connection, this, browserContextId);\n    if (downloadBehavior) {\n      await context.setDownloadBehavior(downloadBehavior);\n    }\n    this.#contexts.set(browserContextId, context);\n    return context;\n  }\n  browserContexts() {\n    return [this.#defaultContext, ...Array.from(this.#contexts.values())];\n  }\n  defaultBrowserContext() {\n    return this.#defaultContext;\n  }\n  async _disposeContext(contextId) {\n    if (!contextId) {\n      return;\n    }\n    await this.#connection.send('Target.disposeBrowserContext', {\n      browserContextId: contextId\n    });\n    this.#contexts.delete(contextId);\n  }\n  #createTarget = (targetInfo, session) => {\n    const {\n      browserContextId\n    } = targetInfo;\n    const context = browserContextId && this.#contexts.has(browserContextId) ? this.#contexts.get(browserContextId) : this.#defaultContext;\n    if (!context) {\n      throw new Error('Missing browser context');\n    }\n    const createSession = isAutoAttachEmulated => {\n      return this.#connection._createSession(targetInfo, isAutoAttachEmulated);\n    };\n    const otherTarget = new OtherTarget(targetInfo, session, context, this.#targetManager, createSession);\n    if (targetInfo.url?.startsWith('devtools://')) {\n      return new DevToolsTarget(targetInfo, session, context, this.#targetManager, createSession, this.#defaultViewport ?? null);\n    }\n    if (this.#isPageTargetCallback(otherTarget)) {\n      return new PageTarget(targetInfo, session, context, this.#targetManager, createSession, this.#defaultViewport ?? null);\n    }\n    if (targetInfo.type === 'service_worker' || targetInfo.type === 'shared_worker') {\n      return new WorkerTarget(targetInfo, session, context, this.#targetManager, createSession);\n    }\n    return otherTarget;\n  };\n  #onAttachedToTarget = async target => {\n    if (target._isTargetExposed() && (await target._initializedDeferred.valueOrThrow()) === InitializationStatus.SUCCESS) {\n      this.emit(\"targetcreated\" /* BrowserEvent.TargetCreated */, target);\n      target.browserContext().emit(\"targetcreated\" /* BrowserContextEvent.TargetCreated */, target);\n    }\n  };\n  #onDetachedFromTarget = async target => {\n    target._initializedDeferred.resolve(InitializationStatus.ABORTED);\n    target._isClosedDeferred.resolve();\n    if (target._isTargetExposed() && (await target._initializedDeferred.valueOrThrow()) === InitializationStatus.SUCCESS) {\n      this.emit(\"targetdestroyed\" /* BrowserEvent.TargetDestroyed */, target);\n      target.browserContext().emit(\"targetdestroyed\" /* BrowserContextEvent.TargetDestroyed */, target);\n    }\n  };\n  #onTargetChanged = ({\n    target\n  }) => {\n    this.emit(\"targetchanged\" /* BrowserEvent.TargetChanged */, target);\n    target.browserContext().emit(\"targetchanged\" /* BrowserContextEvent.TargetChanged */, target);\n  };\n  #onTargetDiscovered = targetInfo => {\n    this.emit(\"targetdiscovered\" /* BrowserEvent.TargetDiscovered */, targetInfo);\n  };\n  wsEndpoint() {\n    return this.#connection.url();\n  }\n  async newPage() {\n    return await this.#defaultContext.newPage();\n  }\n  async _createPageInContext(contextId) {\n    const {\n      targetId\n    } = await this.#connection.send('Target.createTarget', {\n      url: 'about:blank',\n      browserContextId: contextId || undefined\n    });\n    const target = await this.waitForTarget(t => {\n      return t._targetId === targetId;\n    });\n    if (!target) {\n      throw new Error(`Missing target for page (id = ${targetId})`);\n    }\n    const initialized = (await target._initializedDeferred.valueOrThrow()) === InitializationStatus.SUCCESS;\n    if (!initialized) {\n      throw new Error(`Failed to create target for page (id = ${targetId})`);\n    }\n    const page = await target.page();\n    if (!page) {\n      throw new Error(`Failed to create a page for context (id = ${contextId})`);\n    }\n    return page;\n  }\n  async installExtension(path) {\n    const {\n      id\n    } = await this.#connection.send('Extensions.loadUnpacked', {\n      path\n    });\n    return id;\n  }\n  uninstallExtension(id) {\n    return this.#connection.send('Extensions.uninstall', {\n      id\n    });\n  }\n  targets() {\n    return Array.from(this.#targetManager.getAvailableTargets().values()).filter(target => {\n      return target._isTargetExposed() && target._initializedDeferred.value() === InitializationStatus.SUCCESS;\n    });\n  }\n  target() {\n    const browserTarget = this.targets().find(target => {\n      return target.type() === 'browser';\n    });\n    if (!browserTarget) {\n      throw new Error('Browser target is not found');\n    }\n    return browserTarget;\n  }\n  async version() {\n    const version = await this.#getVersion();\n    return version.product;\n  }\n  async userAgent() {\n    const version = await this.#getVersion();\n    return version.userAgent;\n  }\n  async close() {\n    await this.#closeCallback.call(null);\n    await this.disconnect();\n  }\n  disconnect() {\n    this.#targetManager.dispose();\n    this.#connection.dispose();\n    this._detach();\n    return Promise.resolve();\n  }\n  get connected() {\n    return !this.#connection._closed;\n  }\n  #getVersion() {\n    return this.#connection.send('Browser.getVersion');\n  }\n  get debugInfo() {\n    return {\n      pendingProtocolErrors: this.#connection.getPendingProtocolErrors()\n    };\n  }\n  isNetworkEnabled() {\n    return this.#networkEnabled;\n  }\n}","map":{"version":3,"names":["Browser","BrowserBase","CDPSessionEvent","CdpBrowserContext","DevToolsTarget","InitializationStatus","OtherTarget","PageTarget","WorkerTarget","TargetManager","CdpBrowser","protocol","_create","connection","contextIds","acceptInsecureCerts","defaultViewport","downloadBehavior","process","closeCallback","targetFilterCallback","isPageTargetCallback","waitForInitiallyDiscoveredTargets","networkEnabled","browser","send","ignore","_attach","defaultContext","contexts","Map","targetManager","constructor","setIsPageTargetCallback","createTarget","contextId","set","emitDisconnected","#emitDisconnected","emit","undefined","on","Disconnected","setDownloadBehavior","onAttachedToTarget","onDetachedFromTarget","onTargetChanged","onTargetDiscovered","initialize","_detach","off","_targetManager","#setIsPageTargetCallback","target","type","_getIsPageTargetCallback","createBrowserContext","options","proxyServer","proxyBypassList","browserContextId","join","context","browserContexts","Array","from","values","defaultBrowserContext","_disposeContext","delete","#createTarget","targetInfo","session","has","get","Error","createSession","isAutoAttachEmulated","_createSession","otherTarget","url","startsWith","_isTargetExposed","_initializedDeferred","valueOrThrow","SUCCESS","browserContext","resolve","ABORTED","_isClosedDeferred","#onTargetChanged","wsEndpoint","newPage","_createPageInContext","targetId","waitForTarget","t","_targetId","initialized","page","installExtension","path","id","uninstallExtension","targets","getAvailableTargets","filter","value","browserTarget","find","version","getVersion","product","userAgent","close","call","disconnect","dispose","Promise","connected","_closed","#getVersion","debugInfo","pendingProtocolErrors","getPendingProtocolErrors","isNetworkEnabled"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/Browser.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {ChildProcess} from 'node:child_process';\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {DebugInfo} from '../api/Browser.js';\nimport {\n  Browser as BrowserBase,\n  BrowserEvent,\n  type BrowserCloseCallback,\n  type BrowserContextOptions,\n  type IsPageTargetCallback,\n  type TargetFilterCallback,\n} from '../api/Browser.js';\nimport {BrowserContextEvent} from '../api/BrowserContext.js';\nimport {CDPSessionEvent} from '../api/CDPSession.js';\nimport type {Page} from '../api/Page.js';\nimport type {Target} from '../api/Target.js';\nimport type {DownloadBehavior} from '../common/DownloadBehavior.js';\nimport type {Viewport} from '../common/Viewport.js';\n\nimport {CdpBrowserContext} from './BrowserContext.js';\nimport type {CdpCDPSession} from './CdpSession.js';\nimport type {Connection} from './Connection.js';\nimport {\n  DevToolsTarget,\n  InitializationStatus,\n  OtherTarget,\n  PageTarget,\n  WorkerTarget,\n  type CdpTarget,\n} from './Target.js';\nimport {TargetManagerEvent} from './TargetManageEvents.js';\nimport {TargetManager} from './TargetManager.js';\n\n/**\n * @internal\n */\nexport class CdpBrowser extends BrowserBase {\n  readonly protocol = 'cdp';\n\n  static async _create(\n    connection: Connection,\n    contextIds: string[],\n    acceptInsecureCerts: boolean,\n    defaultViewport?: Viewport | null,\n    downloadBehavior?: DownloadBehavior,\n    process?: ChildProcess,\n    closeCallback?: BrowserCloseCallback,\n    targetFilterCallback?: TargetFilterCallback,\n    isPageTargetCallback?: IsPageTargetCallback,\n    waitForInitiallyDiscoveredTargets = true,\n    networkEnabled = true,\n  ): Promise<CdpBrowser> {\n    const browser = new CdpBrowser(\n      connection,\n      contextIds,\n      defaultViewport,\n      process,\n      closeCallback,\n      targetFilterCallback,\n      isPageTargetCallback,\n      waitForInitiallyDiscoveredTargets,\n      networkEnabled,\n    );\n    if (acceptInsecureCerts) {\n      await connection.send('Security.setIgnoreCertificateErrors', {\n        ignore: true,\n      });\n    }\n    await browser._attach(downloadBehavior);\n    return browser;\n  }\n  #defaultViewport?: Viewport | null;\n  #process?: ChildProcess;\n  #connection: Connection;\n  #closeCallback: BrowserCloseCallback;\n  #targetFilterCallback: TargetFilterCallback;\n  #isPageTargetCallback!: IsPageTargetCallback;\n  #defaultContext: CdpBrowserContext;\n  #contexts = new Map<string, CdpBrowserContext>();\n  #networkEnabled = true;\n  #targetManager: TargetManager;\n\n  constructor(\n    connection: Connection,\n    contextIds: string[],\n    defaultViewport?: Viewport | null,\n    process?: ChildProcess,\n    closeCallback?: BrowserCloseCallback,\n    targetFilterCallback?: TargetFilterCallback,\n    isPageTargetCallback?: IsPageTargetCallback,\n    waitForInitiallyDiscoveredTargets = true,\n    networkEnabled = true,\n  ) {\n    super();\n    this.#networkEnabled = networkEnabled;\n    this.#defaultViewport = defaultViewport;\n    this.#process = process;\n    this.#connection = connection;\n    this.#closeCallback = closeCallback || (() => {});\n    this.#targetFilterCallback =\n      targetFilterCallback ||\n      (() => {\n        return true;\n      });\n    this.#setIsPageTargetCallback(isPageTargetCallback);\n    this.#targetManager = new TargetManager(\n      connection,\n      this.#createTarget,\n      this.#targetFilterCallback,\n      waitForInitiallyDiscoveredTargets,\n    );\n    this.#defaultContext = new CdpBrowserContext(this.#connection, this);\n    for (const contextId of contextIds) {\n      this.#contexts.set(\n        contextId,\n        new CdpBrowserContext(this.#connection, this, contextId),\n      );\n    }\n  }\n\n  #emitDisconnected = () => {\n    this.emit(BrowserEvent.Disconnected, undefined);\n  };\n\n  async _attach(downloadBehavior: DownloadBehavior | undefined): Promise<void> {\n    this.#connection.on(CDPSessionEvent.Disconnected, this.#emitDisconnected);\n    if (downloadBehavior) {\n      await this.#defaultContext.setDownloadBehavior(downloadBehavior);\n    }\n    this.#targetManager.on(\n      TargetManagerEvent.TargetAvailable,\n      this.#onAttachedToTarget,\n    );\n    this.#targetManager.on(\n      TargetManagerEvent.TargetGone,\n      this.#onDetachedFromTarget,\n    );\n    this.#targetManager.on(\n      TargetManagerEvent.TargetChanged,\n      this.#onTargetChanged,\n    );\n    this.#targetManager.on(\n      TargetManagerEvent.TargetDiscovered,\n      this.#onTargetDiscovered,\n    );\n    await this.#targetManager.initialize();\n  }\n\n  _detach(): void {\n    this.#connection.off(CDPSessionEvent.Disconnected, this.#emitDisconnected);\n    this.#targetManager.off(\n      TargetManagerEvent.TargetAvailable,\n      this.#onAttachedToTarget,\n    );\n    this.#targetManager.off(\n      TargetManagerEvent.TargetGone,\n      this.#onDetachedFromTarget,\n    );\n    this.#targetManager.off(\n      TargetManagerEvent.TargetChanged,\n      this.#onTargetChanged,\n    );\n    this.#targetManager.off(\n      TargetManagerEvent.TargetDiscovered,\n      this.#onTargetDiscovered,\n    );\n  }\n\n  override process(): ChildProcess | null {\n    return this.#process ?? null;\n  }\n\n  _targetManager(): TargetManager {\n    return this.#targetManager;\n  }\n\n  #setIsPageTargetCallback(isPageTargetCallback?: IsPageTargetCallback): void {\n    this.#isPageTargetCallback =\n      isPageTargetCallback ||\n      ((target: Target): boolean => {\n        return (\n          target.type() === 'page' ||\n          target.type() === 'background_page' ||\n          target.type() === 'webview'\n        );\n      });\n  }\n\n  _getIsPageTargetCallback(): IsPageTargetCallback | undefined {\n    return this.#isPageTargetCallback;\n  }\n\n  override async createBrowserContext(\n    options: BrowserContextOptions = {},\n  ): Promise<CdpBrowserContext> {\n    const {proxyServer, proxyBypassList, downloadBehavior} = options;\n\n    const {browserContextId} = await this.#connection.send(\n      'Target.createBrowserContext',\n      {\n        proxyServer,\n        proxyBypassList: proxyBypassList && proxyBypassList.join(','),\n      },\n    );\n    const context = new CdpBrowserContext(\n      this.#connection,\n      this,\n      browserContextId,\n    );\n    if (downloadBehavior) {\n      await context.setDownloadBehavior(downloadBehavior);\n    }\n    this.#contexts.set(browserContextId, context);\n    return context;\n  }\n\n  override browserContexts(): CdpBrowserContext[] {\n    return [this.#defaultContext, ...Array.from(this.#contexts.values())];\n  }\n\n  override defaultBrowserContext(): CdpBrowserContext {\n    return this.#defaultContext;\n  }\n\n  async _disposeContext(contextId?: string): Promise<void> {\n    if (!contextId) {\n      return;\n    }\n    await this.#connection.send('Target.disposeBrowserContext', {\n      browserContextId: contextId,\n    });\n    this.#contexts.delete(contextId);\n  }\n\n  #createTarget = (\n    targetInfo: Protocol.Target.TargetInfo,\n    session?: CdpCDPSession,\n  ) => {\n    const {browserContextId} = targetInfo;\n    const context =\n      browserContextId && this.#contexts.has(browserContextId)\n        ? this.#contexts.get(browserContextId)\n        : this.#defaultContext;\n\n    if (!context) {\n      throw new Error('Missing browser context');\n    }\n\n    const createSession = (isAutoAttachEmulated: boolean) => {\n      return this.#connection._createSession(targetInfo, isAutoAttachEmulated);\n    };\n    const otherTarget = new OtherTarget(\n      targetInfo,\n      session,\n      context,\n      this.#targetManager,\n      createSession,\n    );\n    if (targetInfo.url?.startsWith('devtools://')) {\n      return new DevToolsTarget(\n        targetInfo,\n        session,\n        context,\n        this.#targetManager,\n        createSession,\n        this.#defaultViewport ?? null,\n      );\n    }\n    if (this.#isPageTargetCallback(otherTarget)) {\n      return new PageTarget(\n        targetInfo,\n        session,\n        context,\n        this.#targetManager,\n        createSession,\n        this.#defaultViewport ?? null,\n      );\n    }\n    if (\n      targetInfo.type === 'service_worker' ||\n      targetInfo.type === 'shared_worker'\n    ) {\n      return new WorkerTarget(\n        targetInfo,\n        session,\n        context,\n        this.#targetManager,\n        createSession,\n      );\n    }\n    return otherTarget;\n  };\n\n  #onAttachedToTarget = async (target: CdpTarget) => {\n    if (\n      target._isTargetExposed() &&\n      (await target._initializedDeferred.valueOrThrow()) ===\n        InitializationStatus.SUCCESS\n    ) {\n      this.emit(BrowserEvent.TargetCreated, target);\n      target.browserContext().emit(BrowserContextEvent.TargetCreated, target);\n    }\n  };\n\n  #onDetachedFromTarget = async (target: CdpTarget): Promise<void> => {\n    target._initializedDeferred.resolve(InitializationStatus.ABORTED);\n    target._isClosedDeferred.resolve();\n    if (\n      target._isTargetExposed() &&\n      (await target._initializedDeferred.valueOrThrow()) ===\n        InitializationStatus.SUCCESS\n    ) {\n      this.emit(BrowserEvent.TargetDestroyed, target);\n      target.browserContext().emit(BrowserContextEvent.TargetDestroyed, target);\n    }\n  };\n\n  #onTargetChanged = ({target}: {target: CdpTarget}): void => {\n    this.emit(BrowserEvent.TargetChanged, target);\n    target.browserContext().emit(BrowserContextEvent.TargetChanged, target);\n  };\n\n  #onTargetDiscovered = (targetInfo: Protocol.Target.TargetInfo): void => {\n    this.emit(BrowserEvent.TargetDiscovered, targetInfo);\n  };\n\n  override wsEndpoint(): string {\n    return this.#connection.url();\n  }\n\n  override async newPage(): Promise<Page> {\n    return await this.#defaultContext.newPage();\n  }\n\n  async _createPageInContext(contextId?: string): Promise<Page> {\n    const {targetId} = await this.#connection.send('Target.createTarget', {\n      url: 'about:blank',\n      browserContextId: contextId || undefined,\n    });\n    const target = (await this.waitForTarget(t => {\n      return (t as CdpTarget)._targetId === targetId;\n    })) as CdpTarget;\n    if (!target) {\n      throw new Error(`Missing target for page (id = ${targetId})`);\n    }\n    const initialized =\n      (await target._initializedDeferred.valueOrThrow()) ===\n      InitializationStatus.SUCCESS;\n    if (!initialized) {\n      throw new Error(`Failed to create target for page (id = ${targetId})`);\n    }\n    const page = await target.page();\n    if (!page) {\n      throw new Error(\n        `Failed to create a page for context (id = ${contextId})`,\n      );\n    }\n    return page;\n  }\n\n  override async installExtension(path: string): Promise<string> {\n    const {id} = await this.#connection.send('Extensions.loadUnpacked', {path});\n    return id;\n  }\n\n  override uninstallExtension(id: string): Promise<void> {\n    return this.#connection.send('Extensions.uninstall', {id});\n  }\n\n  override targets(): CdpTarget[] {\n    return Array.from(\n      this.#targetManager.getAvailableTargets().values(),\n    ).filter(target => {\n      return (\n        target._isTargetExposed() &&\n        target._initializedDeferred.value() === InitializationStatus.SUCCESS\n      );\n    });\n  }\n\n  override target(): CdpTarget {\n    const browserTarget = this.targets().find(target => {\n      return target.type() === 'browser';\n    });\n    if (!browserTarget) {\n      throw new Error('Browser target is not found');\n    }\n    return browserTarget;\n  }\n\n  override async version(): Promise<string> {\n    const version = await this.#getVersion();\n    return version.product;\n  }\n\n  override async userAgent(): Promise<string> {\n    const version = await this.#getVersion();\n    return version.userAgent;\n  }\n\n  override async close(): Promise<void> {\n    await this.#closeCallback.call(null);\n    await this.disconnect();\n  }\n\n  override disconnect(): Promise<void> {\n    this.#targetManager.dispose();\n    this.#connection.dispose();\n    this._detach();\n    return Promise.resolve();\n  }\n\n  override get connected(): boolean {\n    return !this.#connection._closed;\n  }\n\n  #getVersion(): Promise<Protocol.Browser.GetVersionResponse> {\n    return this.#connection.send('Browser.getVersion');\n  }\n\n  override get debugInfo(): DebugInfo {\n    return {\n      pendingProtocolErrors: this.#connection.getPendingProtocolErrors(),\n    };\n  }\n\n  override isNetworkEnabled(): boolean {\n    return this.#networkEnabled;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}