{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __setFunctionName = this && this.__setFunctionName || function (f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", {\n    configurable: true,\n    value: prefix ? \"\".concat(prefix, \" \", name) : name\n  });\n};\nimport { spawn, spawnSync } from 'node:child_process';\nimport fs from 'node:fs';\nimport os from 'node:os';\nimport { dirname } from 'node:path';\nimport { PassThrough } from 'node:stream';\nimport debug from 'debug';\nimport { bufferCount, concatMap, filter, from, fromEvent, lastValueFrom, map, takeUntil, tap } from '../../third_party/rxjs/rxjs.js';\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { debugError, fromEmitterEvent } from '../common/util.js';\nimport { guarded } from '../util/decorators.js';\nimport { asyncDisposeSymbol } from '../util/disposable.js';\nconst CRF_VALUE = 30;\nconst DEFAULT_FPS = 30;\nconst debugFfmpeg = debug('puppeteer:ffmpeg');\n/**\n * @public\n */\nlet ScreenRecorder = (() => {\n  let _classSuper = PassThrough;\n  let _instanceExtraInitializers = [];\n  let _private_writeFrame_decorators;\n  let _private_writeFrame_descriptor;\n  let _stop_decorators;\n  return class ScreenRecorder extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, _private_writeFrame_descriptor = {\n        value: __setFunctionName(async function (buffer) {\n          const error = await new Promise(resolve => {\n            this.#process.stdin.write(buffer, resolve);\n          });\n          if (error) {\n            console.log(`ffmpeg failed to write: ${error.message}.`);\n          }\n        }, \"#writeFrame\")\n      }, _private_writeFrame_decorators, {\n        kind: \"method\",\n        name: \"#writeFrame\",\n        static: false,\n        private: true,\n        access: {\n          has: obj => #writeFrame in obj,\n          get: obj => obj.#writeFrame\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _stop_decorators, {\n        kind: \"method\",\n        name: \"stop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"stop\" in obj,\n          get: obj => obj.stop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    #page = __runInitializers(this, _instanceExtraInitializers);\n    #process;\n    #controller = new AbortController();\n    #lastFrame;\n    #fps;\n    /**\n     * @internal\n     */\n    constructor(page, width, height, {\n      ffmpegPath,\n      speed,\n      scale,\n      crop,\n      format,\n      fps,\n      loop,\n      delay,\n      quality,\n      colors,\n      path,\n      overwrite\n    } = {}) {\n      super({\n        allowHalfOpen: false\n      });\n      ffmpegPath ??= 'ffmpeg';\n      format ??= 'webm';\n      fps ??= DEFAULT_FPS;\n      // Maps 0 to -1 as ffmpeg maps 0 to infinity.\n      loop ||= -1;\n      delay ??= -1;\n      quality ??= CRF_VALUE;\n      colors ??= 256;\n      overwrite ??= true;\n      this.#fps = fps;\n      // Tests if `ffmpeg` exists.\n      const {\n        error\n      } = spawnSync(ffmpegPath);\n      if (error) {\n        throw error;\n      }\n      const filters = [`crop='min(${width},iw):min(${height},ih):0:0'`, `pad=${width}:${height}:0:0`];\n      if (speed) {\n        filters.push(`setpts=${1 / speed}*PTS`);\n      }\n      if (crop) {\n        filters.push(`crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}`);\n      }\n      if (scale) {\n        filters.push(`scale=iw*${scale}:-1:flags=lanczos`);\n      }\n      const formatArgs = this.#getFormatArgs(format, fps, loop, delay, quality, colors);\n      const vf = formatArgs.indexOf('-vf');\n      if (vf !== -1) {\n        filters.push(formatArgs.splice(vf, 2).at(-1) ?? '');\n      }\n      // Ensure provided output directory path exists.\n      if (path) {\n        fs.mkdirSync(dirname(path), {\n          recursive: overwrite\n        });\n      }\n      this.#process = spawn(ffmpegPath,\n      // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.\n      [['-loglevel', 'error'],\n      // Reduces general buffering.\n      ['-avioflags', 'direct'],\n      // Reduces initial buffering while analyzing input fps and other stats.\n      ['-fpsprobesize', '0', '-probesize', '32', '-analyzeduration', '0', '-fflags', 'nobuffer'],\n      // Forces input to be read from standard input, and forces png input\n      // image format.\n      ['-f', 'image2pipe', '-vcodec', 'png', '-i', 'pipe:0'],\n      // No audio\n      ['-an'],\n      // This drastically reduces stalling when cpu is overbooked. By default\n      // VP9 tries to use all available threads?\n      ['-threads', '1'],\n      // Specifies the frame rate we are giving ffmpeg.\n      ['-framerate', `${fps}`],\n      // Disable bitrate.\n      ['-b:v', '0'],\n      // Specifies the encoding and format we are using.\n      formatArgs,\n      // Filters to ensure the images are piped correctly,\n      // combined with any format-specific filters.\n      ['-vf', filters.join()],\n      // Overwrite output, or exit immediately if file already exists.\n      [overwrite ? '-y' : '-n'], 'pipe:1'].flat(), {\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n      this.#process.stdout.pipe(this);\n      this.#process.stderr.on('data', data => {\n        debugFfmpeg(data.toString('utf8'));\n      });\n      this.#page = page;\n      const {\n        client\n      } = this.#page.mainFrame();\n      client.once(CDPSessionEvent.Disconnected, () => {\n        void this.stop().catch(debugError);\n      });\n      this.#lastFrame = lastValueFrom(fromEmitterEvent(client, 'Page.screencastFrame').pipe(tap(event => {\n        void client.send('Page.screencastFrameAck', {\n          sessionId: event.sessionId\n        });\n      }), filter(event => {\n        return event.metadata.timestamp !== undefined;\n      }), map(event => {\n        return {\n          buffer: Buffer.from(event.data, 'base64'),\n          timestamp: event.metadata.timestamp\n        };\n      }), bufferCount(2, 1), concatMap(([{\n        timestamp: previousTimestamp,\n        buffer\n      }, {\n        timestamp\n      }]) => {\n        return from(Array(Math.round(fps * Math.max(timestamp - previousTimestamp, 0))).fill(buffer));\n      }), map(buffer => {\n        void this.#writeFrame(buffer);\n        return [buffer, performance.now()];\n      }), takeUntil(fromEvent(this.#controller.signal, 'abort'))), {\n        defaultValue: [Buffer.from([]), performance.now()]\n      });\n    }\n    #getFormatArgs(format, fps, loop, delay, quality, colors) {\n      const libvpx = [['-vcodec', 'vp9'],\n      // Sets the quality. Lower the better.\n      ['-crf', `${quality}`],\n      // Sets the quality and how efficient the compression will be.\n      ['-deadline', 'realtime', '-cpu-used', `${Math.min(os.cpus().length / 2, 8)}`]];\n      switch (format) {\n        case 'webm':\n          return [...libvpx,\n          // Sets the format\n          ['-f', 'webm']].flat();\n        case 'gif':\n          fps = DEFAULT_FPS === fps ? 20 : 'source_fps';\n          if (loop === Infinity) {\n            loop = 0;\n          }\n          if (delay !== -1) {\n            // ms to cs\n            delay /= 10;\n          }\n          return [\n          // Sets the frame rate and uses a custom palette generated from the\n          // input.\n          ['-vf', `fps=${fps},split[s0][s1];[s0]palettegen=stats_mode=diff:max_colors=${colors}[p];[s1][p]paletteuse=dither=bayer`],\n          // Sets the number of times to loop playback.\n          ['-loop', `${loop}`],\n          // Sets the delay between iterations of a loop.\n          ['-final_delay', `${delay}`],\n          // Sets the format\n          ['-f', 'gif']].flat();\n        case 'mp4':\n          return [...libvpx,\n          // Fragment file during stream to avoid errors.\n          ['-movflags', 'hybrid_fragmented'],\n          // Sets the format\n          ['-f', 'mp4']].flat();\n      }\n    }\n    get #writeFrame() {\n      return _private_writeFrame_descriptor.value;\n    }\n    /**\n     * Stops the recorder.\n     *\n     * @public\n     */\n    async stop() {\n      if (this.#controller.signal.aborted) {\n        return;\n      }\n      // Stopping the screencast will flush the frames.\n      await this.#page._stopScreencast().catch(debugError);\n      this.#controller.abort();\n      // Repeat the last frame for the remaining frames.\n      const [buffer, timestamp] = await this.#lastFrame;\n      await Promise.all(Array(Math.max(1, Math.round(this.#fps * (performance.now() - timestamp) / 1000))).fill(buffer).map(this.#writeFrame.bind(this)));\n      // Close stdin to notify FFmpeg we are done.\n      this.#process.stdin.end();\n      await new Promise(resolve => {\n        this.#process.once('close', resolve);\n      });\n    }\n    /**\n     * @internal\n     */\n    async [(_private_writeFrame_decorators = [guarded()], _stop_decorators = [guarded()], asyncDisposeSymbol)]() {\n      await this.stop();\n    }\n  };\n})();\nexport { ScreenRecorder };","map":{"version":3,"names":["spawn","spawnSync","fs","os","dirname","PassThrough","debug","bufferCount","concatMap","filter","from","fromEvent","lastValueFrom","map","takeUntil","tap","CDPSessionEvent","debugError","fromEmitterEvent","guarded","asyncDisposeSymbol","CRF_VALUE","DEFAULT_FPS","debugFfmpeg","ScreenRecorder","_classSuper","__esDecorate","_private_writeFrame_descriptor","value","__setFunctionName","buffer","error","Promise","resolve","process","stdin","write","console","log","message","_private_writeFrame_decorators","kind","name","static","private","access","has","obj","writeFrame","get","metadata","_metadata","_instanceExtraInitializers","_stop_decorators","stop","page","__runInitializers","controller","AbortController","lastFrame","fps","constructor","width","height","ffmpegPath","speed","scale","crop","format","loop","delay","quality","colors","path","overwrite","allowHalfOpen","filters","push","x","y","formatArgs","getFormatArgs","vf","indexOf","splice","at","mkdirSync","recursive","join","flat","stdio","stdout","pipe","stderr","on","data","toString","client","mainFrame","once","Disconnected","catch","event","send","sessionId","timestamp","undefined","Buffer","previousTimestamp","Array","Math","round","max","fill","performance","now","signal","defaultValue","#getFormatArgs","libvpx","min","cpus","length","Infinity","#writeFrame","aborted","_stopScreencast","abort","all","bind","end"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/node/ScreenRecorder.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {ChildProcessWithoutNullStreams} from 'node:child_process';\nimport {spawn, spawnSync} from 'node:child_process';\nimport fs from 'node:fs';\nimport os from 'node:os';\nimport {dirname} from 'node:path';\nimport {PassThrough} from 'node:stream';\n\nimport debug from 'debug';\n\nimport type {OperatorFunction} from '../../third_party/rxjs/rxjs.js';\nimport {\n  bufferCount,\n  concatMap,\n  filter,\n  from,\n  fromEvent,\n  lastValueFrom,\n  map,\n  takeUntil,\n  tap,\n} from '../../third_party/rxjs/rxjs.js';\nimport {CDPSessionEvent} from '../api/CDPSession.js';\nimport type {BoundingBox} from '../api/ElementHandle.js';\nimport type {Page, VideoFormat} from '../api/Page.js';\nimport {debugError, fromEmitterEvent} from '../common/util.js';\nimport {guarded} from '../util/decorators.js';\nimport {asyncDisposeSymbol} from '../util/disposable.js';\n\nconst CRF_VALUE = 30;\nconst DEFAULT_FPS = 30;\n\nconst debugFfmpeg = debug('puppeteer:ffmpeg');\n\n/**\n * @internal\n */\nexport interface ScreenRecorderOptions {\n  ffmpegPath?: string;\n  speed?: number;\n  crop?: BoundingBox;\n  format?: VideoFormat;\n  fps?: number;\n  loop?: number;\n  delay?: number;\n  quality?: number;\n  colors?: number;\n  scale?: number;\n  path?: `${string}.${VideoFormat}`;\n  overwrite?: boolean;\n}\n\n/**\n * @public\n */\nexport class ScreenRecorder extends PassThrough {\n  #page: Page;\n\n  #process: ChildProcessWithoutNullStreams;\n\n  #controller = new AbortController();\n  #lastFrame: Promise<readonly [Buffer, number]>;\n\n  #fps: number;\n\n  /**\n   * @internal\n   */\n  constructor(\n    page: Page,\n    width: number,\n    height: number,\n    {\n      ffmpegPath,\n      speed,\n      scale,\n      crop,\n      format,\n      fps,\n      loop,\n      delay,\n      quality,\n      colors,\n      path,\n      overwrite,\n    }: ScreenRecorderOptions = {},\n  ) {\n    super({allowHalfOpen: false});\n\n    ffmpegPath ??= 'ffmpeg';\n    format ??= 'webm';\n    fps ??= DEFAULT_FPS;\n    // Maps 0 to -1 as ffmpeg maps 0 to infinity.\n    loop ||= -1;\n    delay ??= -1;\n    quality ??= CRF_VALUE;\n    colors ??= 256;\n    overwrite ??= true;\n\n    this.#fps = fps;\n\n    // Tests if `ffmpeg` exists.\n    const {error} = spawnSync(ffmpegPath);\n    if (error) {\n      throw error;\n    }\n\n    const filters = [\n      `crop='min(${width},iw):min(${height},ih):0:0'`,\n      `pad=${width}:${height}:0:0`,\n    ];\n    if (speed) {\n      filters.push(`setpts=${1 / speed}*PTS`);\n    }\n    if (crop) {\n      filters.push(`crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}`);\n    }\n    if (scale) {\n      filters.push(`scale=iw*${scale}:-1:flags=lanczos`);\n    }\n\n    const formatArgs = this.#getFormatArgs(\n      format,\n      fps,\n      loop,\n      delay,\n      quality,\n      colors,\n    );\n    const vf = formatArgs.indexOf('-vf');\n    if (vf !== -1) {\n      filters.push(formatArgs.splice(vf, 2).at(-1) ?? '');\n    }\n\n    // Ensure provided output directory path exists.\n    if (path) {\n      fs.mkdirSync(dirname(path), {recursive: overwrite});\n    }\n\n    this.#process = spawn(\n      ffmpegPath,\n      // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.\n      [\n        ['-loglevel', 'error'],\n        // Reduces general buffering.\n        ['-avioflags', 'direct'],\n        // Reduces initial buffering while analyzing input fps and other stats.\n        [\n          '-fpsprobesize',\n          '0',\n          '-probesize',\n          '32',\n          '-analyzeduration',\n          '0',\n          '-fflags',\n          'nobuffer',\n        ],\n        // Forces input to be read from standard input, and forces png input\n        // image format.\n        ['-f', 'image2pipe', '-vcodec', 'png', '-i', 'pipe:0'],\n        // No audio\n        ['-an'],\n        // This drastically reduces stalling when cpu is overbooked. By default\n        // VP9 tries to use all available threads?\n        ['-threads', '1'],\n        // Specifies the frame rate we are giving ffmpeg.\n        ['-framerate', `${fps}`],\n        // Disable bitrate.\n        ['-b:v', '0'],\n        // Specifies the encoding and format we are using.\n        formatArgs,\n        // Filters to ensure the images are piped correctly,\n        // combined with any format-specific filters.\n        ['-vf', filters.join()],\n        // Overwrite output, or exit immediately if file already exists.\n        [overwrite ? '-y' : '-n'],\n        'pipe:1',\n      ].flat(),\n      {stdio: ['pipe', 'pipe', 'pipe']},\n    );\n    this.#process.stdout.pipe(this);\n    this.#process.stderr.on('data', (data: Buffer) => {\n      debugFfmpeg(data.toString('utf8'));\n    });\n\n    this.#page = page;\n\n    const {client} = this.#page.mainFrame();\n    client.once(CDPSessionEvent.Disconnected, () => {\n      void this.stop().catch(debugError);\n    });\n\n    this.#lastFrame = lastValueFrom(\n      fromEmitterEvent(client, 'Page.screencastFrame').pipe(\n        tap(event => {\n          void client.send('Page.screencastFrameAck', {\n            sessionId: event.sessionId,\n          });\n        }),\n        filter(event => {\n          return event.metadata.timestamp !== undefined;\n        }),\n        map(event => {\n          return {\n            buffer: Buffer.from(event.data, 'base64'),\n            timestamp: event.metadata.timestamp!,\n          };\n        }),\n        bufferCount(2, 1) as OperatorFunction<\n          {buffer: Buffer; timestamp: number},\n          [\n            {buffer: Buffer; timestamp: number},\n            {buffer: Buffer; timestamp: number},\n          ]\n        >,\n        concatMap(([{timestamp: previousTimestamp, buffer}, {timestamp}]) => {\n          return from(\n            Array<Buffer>(\n              Math.round(fps * Math.max(timestamp - previousTimestamp, 0)),\n            ).fill(buffer),\n          );\n        }),\n        map(buffer => {\n          void this.#writeFrame(buffer);\n          return [buffer, performance.now()] as const;\n        }),\n        takeUntil(fromEvent(this.#controller.signal, 'abort')),\n      ),\n      {defaultValue: [Buffer.from([]), performance.now()] as const},\n    );\n  }\n\n  #getFormatArgs(\n    format: VideoFormat,\n    fps: number | 'source_fps',\n    loop: number,\n    delay: number,\n    quality: number,\n    colors: number,\n  ): string[] {\n    const libvpx = [\n      ['-vcodec', 'vp9'],\n      // Sets the quality. Lower the better.\n      ['-crf', `${quality}`],\n      // Sets the quality and how efficient the compression will be.\n      [\n        '-deadline',\n        'realtime',\n        '-cpu-used',\n        `${Math.min(os.cpus().length / 2, 8)}`,\n      ],\n    ];\n    switch (format) {\n      case 'webm':\n        return [\n          ...libvpx,\n          // Sets the format\n          ['-f', 'webm'],\n        ].flat();\n      case 'gif':\n        fps = DEFAULT_FPS === fps ? 20 : 'source_fps';\n        if (loop === Infinity) {\n          loop = 0;\n        }\n        if (delay !== -1) {\n          // ms to cs\n          delay /= 10;\n        }\n        return [\n          // Sets the frame rate and uses a custom palette generated from the\n          // input.\n          [\n            '-vf',\n            `fps=${fps},split[s0][s1];[s0]palettegen=stats_mode=diff:max_colors=${colors}[p];[s1][p]paletteuse=dither=bayer`,\n          ],\n          // Sets the number of times to loop playback.\n          ['-loop', `${loop}`],\n          // Sets the delay between iterations of a loop.\n          ['-final_delay', `${delay}`],\n          // Sets the format\n          ['-f', 'gif'],\n        ].flat();\n      case 'mp4':\n        return [\n          ...libvpx,\n          // Fragment file during stream to avoid errors.\n          ['-movflags', 'hybrid_fragmented'],\n          // Sets the format\n          ['-f', 'mp4'],\n        ].flat();\n    }\n  }\n\n  @guarded()\n  async #writeFrame(buffer: Buffer) {\n    const error = await new Promise<Error | null | undefined>(resolve => {\n      this.#process.stdin.write(buffer, resolve);\n    });\n    if (error) {\n      console.log(`ffmpeg failed to write: ${error.message}.`);\n    }\n  }\n\n  /**\n   * Stops the recorder.\n   *\n   * @public\n   */\n  @guarded()\n  async stop(): Promise<void> {\n    if (this.#controller.signal.aborted) {\n      return;\n    }\n    // Stopping the screencast will flush the frames.\n    await this.#page._stopScreencast().catch(debugError);\n\n    this.#controller.abort();\n\n    // Repeat the last frame for the remaining frames.\n    const [buffer, timestamp] = await this.#lastFrame;\n    await Promise.all(\n      Array<Buffer>(\n        Math.max(\n          1,\n          Math.round((this.#fps * (performance.now() - timestamp)) / 1000),\n        ),\n      )\n        .fill(buffer)\n        .map(this.#writeFrame.bind(this)),\n    );\n\n    // Close stdin to notify FFmpeg we are done.\n    this.#process.stdin.end();\n    await new Promise(resolve => {\n      this.#process.once('close', resolve);\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async [asyncDisposeSymbol](): Promise<void> {\n    await this.stop();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}