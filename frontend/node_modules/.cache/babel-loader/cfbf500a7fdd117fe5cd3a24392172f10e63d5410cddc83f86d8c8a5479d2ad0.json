{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { NetworkManagerEvent } from '../common/NetworkManagerEvents.js';\nimport { debugError, isString } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { DisposableStack } from '../util/disposable.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { isTargetClosedError } from './Connection.js';\nimport { CdpHTTPRequest } from './HTTPRequest.js';\nimport { CdpHTTPResponse } from './HTTPResponse.js';\nimport { NetworkEventManager } from './NetworkEventManager.js';\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter {\n  #frameManager;\n  #networkEventManager = new NetworkEventManager();\n  #extraHTTPHeaders;\n  #credentials = null;\n  #attemptedAuthentications = new Set();\n  #userRequestInterceptionEnabled = false;\n  #protocolRequestInterceptionEnabled = false;\n  #userCacheDisabled;\n  #emulatedNetworkConditions;\n  #userAgent;\n  #userAgentMetadata;\n  #handlers = [['Fetch.requestPaused', this.#onRequestPaused], ['Fetch.authRequired', this.#onAuthRequired], ['Network.requestWillBeSent', this.#onRequestWillBeSent], ['Network.requestServedFromCache', this.#onRequestServedFromCache], ['Network.responseReceived', this.#onResponseReceived], ['Network.loadingFinished', this.#onLoadingFinished], ['Network.loadingFailed', this.#onLoadingFailed], ['Network.responseReceivedExtraInfo', this.#onResponseReceivedExtraInfo], [CDPSessionEvent.Disconnected, this.#removeClient]];\n  #clients = new Map();\n  #networkEnabled = true;\n  constructor(frameManager, networkEnabled) {\n    super();\n    this.#frameManager = frameManager;\n    this.#networkEnabled = networkEnabled ?? true;\n  }\n  #canIgnoreError(error) {\n    return isErrorLike(error) && (isTargetClosedError(error) || error.message.includes('Not supported'));\n  }\n  async addClient(client) {\n    if (!this.#networkEnabled || this.#clients.has(client)) {\n      return;\n    }\n    const subscriptions = new DisposableStack();\n    this.#clients.set(client, subscriptions);\n    const clientEmitter = subscriptions.use(new EventEmitter(client));\n    for (const [event, handler] of this.#handlers) {\n      clientEmitter.on(event, arg => {\n        return handler.bind(this)(client, arg);\n      });\n    }\n    try {\n      await Promise.all([client.send('Network.enable'), this.#applyExtraHTTPHeaders(client), this.#applyNetworkConditions(client), this.#applyProtocolCacheDisabled(client), this.#applyProtocolRequestInterception(client), this.#applyUserAgent(client)]);\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  async #removeClient(client) {\n    this.#clients.get(client)?.dispose();\n    this.#clients.delete(client);\n  }\n  async authenticate(credentials) {\n    this.#credentials = credentials;\n    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;\n    if (enabled === this.#protocolRequestInterceptionEnabled) {\n      return;\n    }\n    this.#protocolRequestInterceptionEnabled = enabled;\n    await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));\n  }\n  async setExtraHTTPHeaders(headers) {\n    const extraHTTPHeaders = {};\n    for (const [key, value] of Object.entries(headers)) {\n      assert(isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n    this.#extraHTTPHeaders = extraHTTPHeaders;\n    await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));\n  }\n  async #applyExtraHTTPHeaders(client) {\n    if (this.#extraHTTPHeaders === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.setExtraHTTPHeaders', {\n        headers: this.#extraHTTPHeaders\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  extraHTTPHeaders() {\n    return Object.assign({}, this.#extraHTTPHeaders);\n  }\n  inFlightRequestsCount() {\n    return this.#networkEventManager.inFlightRequestsCount();\n  }\n  async setOfflineMode(value) {\n    if (!this.#emulatedNetworkConditions) {\n      this.#emulatedNetworkConditions = {\n        offline: false,\n        upload: -1,\n        download: -1,\n        latency: 0\n      };\n    }\n    this.#emulatedNetworkConditions.offline = value;\n    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));\n  }\n  async emulateNetworkConditions(networkConditions) {\n    if (!this.#emulatedNetworkConditions) {\n      this.#emulatedNetworkConditions = {\n        offline: false,\n        upload: -1,\n        download: -1,\n        latency: 0\n      };\n    }\n    this.#emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;\n    this.#emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;\n    this.#emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;\n    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));\n  }\n  async #applyToAllClients(fn) {\n    await Promise.all(Array.from(this.#clients.keys()).map(client => {\n      return fn(client);\n    }));\n  }\n  async #applyNetworkConditions(client) {\n    if (this.#emulatedNetworkConditions === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.emulateNetworkConditions', {\n        offline: this.#emulatedNetworkConditions.offline,\n        latency: this.#emulatedNetworkConditions.latency,\n        uploadThroughput: this.#emulatedNetworkConditions.upload,\n        downloadThroughput: this.#emulatedNetworkConditions.download\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  async setUserAgent(userAgent, userAgentMetadata) {\n    this.#userAgent = userAgent;\n    this.#userAgentMetadata = userAgentMetadata;\n    await this.#applyToAllClients(this.#applyUserAgent.bind(this));\n  }\n  async #applyUserAgent(client) {\n    if (this.#userAgent === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.setUserAgentOverride', {\n        userAgent: this.#userAgent,\n        userAgentMetadata: this.#userAgentMetadata\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  async setCacheEnabled(enabled) {\n    this.#userCacheDisabled = !enabled;\n    await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));\n  }\n  async setRequestInterception(value) {\n    this.#userRequestInterceptionEnabled = value;\n    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;\n    if (enabled === this.#protocolRequestInterceptionEnabled) {\n      return;\n    }\n    this.#protocolRequestInterceptionEnabled = enabled;\n    await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));\n  }\n  async #applyProtocolRequestInterception(client) {\n    if (this.#userCacheDisabled === undefined) {\n      this.#userCacheDisabled = false;\n    }\n    try {\n      if (this.#protocolRequestInterceptionEnabled) {\n        await Promise.all([this.#applyProtocolCacheDisabled(client), client.send('Fetch.enable', {\n          handleAuthRequests: true,\n          patterns: [{\n            urlPattern: '*'\n          }]\n        })]);\n      } else {\n        await Promise.all([this.#applyProtocolCacheDisabled(client), client.send('Fetch.disable')]);\n      }\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  async #applyProtocolCacheDisabled(client) {\n    if (this.#userCacheDisabled === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.setCacheDisabled', {\n        cacheDisabled: this.#userCacheDisabled\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  #onRequestWillBeSent(client, event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this.#userRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const {\n        requestId: networkRequestId\n      } = event;\n      this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);\n      /**\n       * CDP may have sent a Fetch.requestPaused event already. Check for it.\n       */\n      const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);\n      if (requestPausedEvent) {\n        const {\n          requestId: fetchRequestId\n        } = requestPausedEvent;\n        this.#patchRequestEventHeaders(event, requestPausedEvent);\n        this.#onRequest(client, event, fetchRequestId);\n        this.#networkEventManager.forgetRequestPaused(networkRequestId);\n      }\n      return;\n    }\n    this.#onRequest(client, event, undefined);\n  }\n  #onAuthRequired(client, event) {\n    let response = 'Default';\n    if (this.#attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this.#credentials) {\n      response = 'ProvideCredentials';\n      this.#attemptedAuthentications.add(event.requestId);\n    }\n    const {\n      username,\n      password\n    } = this.#credentials || {\n      username: undefined,\n      password: undefined\n    };\n    client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(debugError);\n  }\n  /**\n   * CDP may send a Fetch.requestPaused without or before a\n   * Network.requestWillBeSent\n   *\n   * CDP may send multiple Fetch.requestPaused\n   * for the same Network.requestWillBeSent.\n   */\n  #onRequestPaused(client, event) {\n    if (!this.#userRequestInterceptionEnabled && this.#protocolRequestInterceptionEnabled) {\n      client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(debugError);\n    }\n    const {\n      networkId: networkRequestId,\n      requestId: fetchRequestId\n    } = event;\n    if (!networkRequestId) {\n      this.#onRequestWithoutNetworkInstrumentation(client, event);\n      return;\n    }\n    const requestWillBeSentEvent = (() => {\n      const requestWillBeSentEvent = this.#networkEventManager.getRequestWillBeSent(networkRequestId);\n      // redirect requests have the same `requestId`,\n      if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {\n        this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);\n        return;\n      }\n      return requestWillBeSentEvent;\n    })();\n    if (requestWillBeSentEvent) {\n      this.#patchRequestEventHeaders(requestWillBeSentEvent, event);\n      this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);\n    } else {\n      this.#networkEventManager.storeRequestPaused(networkRequestId, event);\n    }\n  }\n  #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {\n    requestWillBeSentEvent.request.headers = {\n      ...requestWillBeSentEvent.request.headers,\n      // includes extra headers, like: Accept, Origin\n      ...requestPausedEvent.request.headers\n    };\n  }\n  #onRequestWithoutNetworkInstrumentation(client, event) {\n    // If an event has no networkId it should not have any network events. We\n    // still want to dispatch it for the interception by the user.\n    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;\n    const request = new CdpHTTPRequest(client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);\n    this.emit(NetworkManagerEvent.Request, request);\n    void request.finalizeInterceptions();\n  }\n  #onRequest(client, event, fetchRequestId, fromMemoryCache = false) {\n    let redirectChain = [];\n    if (event.redirectResponse) {\n      // We want to emit a response and requestfinished for the\n      // redirectResponse, but we can't do so unless we have a\n      // responseExtraInfo ready to pair it up with. If we don't have any\n      // responseExtraInfos saved in our queue, they we have to wait until\n      // the next one to emit response and requestfinished, *and* we should\n      // also wait to emit this Request too because it should come after the\n      // response/requestfinished.\n      let redirectResponseExtraInfo = null;\n      if (event.redirectHasExtraInfo) {\n        redirectResponseExtraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();\n        if (!redirectResponseExtraInfo) {\n          this.#networkEventManager.queueRedirectInfo(event.requestId, {\n            event,\n            fetchRequestId\n          });\n          return;\n        }\n      }\n      const request = this.#networkEventManager.getRequest(event.requestId);\n      // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n      if (request) {\n        this.#handleRequestRedirect(client, request, event.redirectResponse, redirectResponseExtraInfo);\n        redirectChain = request._redirectChain;\n      }\n    }\n    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;\n    const request = new CdpHTTPRequest(client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);\n    request._fromMemoryCache = fromMemoryCache;\n    this.#networkEventManager.storeRequest(event.requestId, request);\n    this.emit(NetworkManagerEvent.Request, request);\n    void request.finalizeInterceptions();\n  }\n  #onRequestServedFromCache(client, event) {\n    const requestWillBeSentEvent = this.#networkEventManager.getRequestWillBeSent(event.requestId);\n    let request = this.#networkEventManager.getRequest(event.requestId);\n    // Requests served from memory cannot be intercepted.\n    if (request) {\n      request._fromMemoryCache = true;\n    }\n    // If request ended up being served from cache, we need to convert\n    // requestWillBeSentEvent to a HTTP request.\n    if (!request && requestWillBeSentEvent) {\n      this.#onRequest(client, requestWillBeSentEvent, undefined, true);\n      request = this.#networkEventManager.getRequest(event.requestId);\n    }\n    if (!request) {\n      debugError(new Error(`Request ${event.requestId} was served from cache but we could not find the corresponding request object`));\n      return;\n    }\n    this.emit(NetworkManagerEvent.RequestServedFromCache, request);\n  }\n  #handleRequestRedirect(_client, request, responsePayload, extraInfo) {\n    const response = new CdpHTTPResponse(request, responsePayload, extraInfo);\n    request._response = response;\n    request._redirectChain.push(request);\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n    this.#forgetRequest(request, false);\n    this.emit(NetworkManagerEvent.Response, response);\n    this.emit(NetworkManagerEvent.RequestFinished, request);\n  }\n  #emitResponseEvent(_client, responseReceived, extraInfo) {\n    const request = this.#networkEventManager.getRequest(responseReceived.requestId);\n    // FileUpload sends a response without a matching request.\n    if (!request) {\n      return;\n    }\n    const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);\n    if (extraInfos.length) {\n      debugError(new Error('Unexpected extraInfo events for request ' + responseReceived.requestId));\n    }\n    // Chromium sends wrong extraInfo events for responses served from cache.\n    // See https://github.com/puppeteer/puppeteer/issues/9965 and\n    // https://crbug.com/1340398.\n    if (responseReceived.response.fromDiskCache) {\n      extraInfo = null;\n    }\n    const response = new CdpHTTPResponse(request, responseReceived.response, extraInfo);\n    request._response = response;\n    this.emit(NetworkManagerEvent.Response, response);\n  }\n  #onResponseReceived(client, event) {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    let extraInfo = null;\n    if (request && !request._fromMemoryCache && event.hasExtraInfo) {\n      extraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();\n      if (!extraInfo) {\n        // Wait until we get the corresponding ExtraInfo event.\n        this.#networkEventManager.queueEventGroup(event.requestId, {\n          responseReceivedEvent: event\n        });\n        return;\n      }\n    }\n    this.#emitResponseEvent(client, event, extraInfo);\n  }\n  #onResponseReceivedExtraInfo(client, event) {\n    // We may have skipped a redirect response/request pair due to waiting for\n    // this ExtraInfo event. If so, continue that work now that we have the\n    // request.\n    const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);\n    if (redirectInfo) {\n      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n      this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);\n      return;\n    }\n    // We may have skipped response and loading events because we didn't have\n    // this ExtraInfo event yet. If so, emit those events now.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n      this.#networkEventManager.forgetQueuedEventGroup(event.requestId);\n      this.#emitResponseEvent(client, queuedEvents.responseReceivedEvent, event);\n      if (queuedEvents.loadingFinishedEvent) {\n        this.#emitLoadingFinished(client, queuedEvents.loadingFinishedEvent);\n      }\n      if (queuedEvents.loadingFailedEvent) {\n        this.#emitLoadingFailed(client, queuedEvents.loadingFailedEvent);\n      }\n      return;\n    }\n    // Wait until we get another event that can use this ExtraInfo event.\n    this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n  }\n  #forgetRequest(request, events) {\n    const requestId = request.id;\n    const interceptionId = request._interceptionId;\n    this.#networkEventManager.forgetRequest(requestId);\n    if (interceptionId !== undefined) {\n      this.#attemptedAuthentications.delete(interceptionId);\n    }\n    if (events) {\n      this.#networkEventManager.forget(requestId);\n    }\n  }\n  #onLoadingFinished(client, event) {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n      queuedEvents.loadingFinishedEvent = event;\n    } else {\n      this.#emitLoadingFinished(client, event);\n    }\n  }\n  #emitLoadingFinished(client, event) {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n    this.#adoptCdpSessionIfNeeded(client, request);\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    if (request.response()) {\n      request.response()?._resolveBody();\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEvent.RequestFinished, request);\n  }\n  #onLoadingFailed(client, event) {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n      queuedEvents.loadingFailedEvent = event;\n    } else {\n      this.#emitLoadingFailed(client, event);\n    }\n  }\n  #emitLoadingFailed(client, event) {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n    this.#adoptCdpSessionIfNeeded(client, request);\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) {\n      response._resolveBody();\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEvent.RequestFailed, request);\n  }\n  #adoptCdpSessionIfNeeded(client, request) {\n    // Document requests for OOPIFs start in the parent frame but are\n    // adopted by their child frame, meaning their loadingFinished and\n    // loadingFailed events are fired on the child session. In this case\n    // we reassign the request CDPSession to ensure all subsequent\n    // actions use the correct session (e.g. retrieving response body in\n    // HTTPResponse). The same applies to main worker script requests.\n    if (client !== request.client) {\n      request.client = client;\n    }\n  }\n}","map":{"version":3,"names":["CDPSessionEvent","EventEmitter","NetworkManagerEvent","debugError","isString","assert","DisposableStack","isErrorLike","isTargetClosedError","CdpHTTPRequest","CdpHTTPResponse","NetworkEventManager","NetworkManager","frameManager","networkEventManager","extraHTTPHeaders","credentials","attemptedAuthentications","Set","userRequestInterceptionEnabled","protocolRequestInterceptionEnabled","userCacheDisabled","emulatedNetworkConditions","userAgent","userAgentMetadata","handlers","onRequestPaused","onAuthRequired","onRequestWillBeSent","onRequestServedFromCache","onResponseReceived","onLoadingFinished","onLoadingFailed","onResponseReceivedExtraInfo","Disconnected","removeClient","clients","Map","networkEnabled","constructor","canIgnoreError","#canIgnoreError","error","message","includes","addClient","client","has","subscriptions","set","clientEmitter","use","event","handler","on","arg","bind","Promise","all","send","applyExtraHTTPHeaders","applyNetworkConditions","applyProtocolCacheDisabled","applyProtocolRequestInterception","applyUserAgent","#removeClient","get","dispose","delete","authenticate","enabled","applyToAllClients","setExtraHTTPHeaders","headers","key","value","Object","entries","toLowerCase","#applyExtraHTTPHeaders","undefined","assign","inFlightRequestsCount","setOfflineMode","offline","upload","download","latency","emulateNetworkConditions","networkConditions","#applyToAllClients","fn","Array","from","keys","map","#applyNetworkConditions","uploadThroughput","downloadThroughput","setUserAgent","#applyUserAgent","setCacheEnabled","setRequestInterception","#applyProtocolRequestInterception","handleAuthRequests","patterns","urlPattern","#applyProtocolCacheDisabled","cacheDisabled","#onRequestWillBeSent","request","url","startsWith","requestId","networkRequestId","storeRequestWillBeSent","requestPausedEvent","getRequestPaused","fetchRequestId","patchRequestEventHeaders","onRequest","forgetRequestPaused","#onAuthRequired","response","add","username","password","authChallengeResponse","catch","#onRequestPaused","networkId","onRequestWithoutNetworkInstrumentation","requestWillBeSentEvent","getRequestWillBeSent","method","forgetRequestWillBeSent","storeRequestPaused","#patchRequestEventHeaders","#onRequestWithoutNetworkInstrumentation","frame","frameId","emit","Request","finalizeInterceptions","#onRequest","fromMemoryCache","redirectChain","redirectResponse","redirectResponseExtraInfo","redirectHasExtraInfo","responseExtraInfo","shift","queueRedirectInfo","getRequest","handleRequestRedirect","_redirectChain","_fromMemoryCache","storeRequest","#onRequestServedFromCache","Error","RequestServedFromCache","#handleRequestRedirect","_client","responsePayload","extraInfo","_response","push","_resolveBody","forgetRequest","Response","RequestFinished","emitResponseEvent","#emitResponseEvent","responseReceived","extraInfos","length","fromDiskCache","#onResponseReceived","hasExtraInfo","queueEventGroup","responseReceivedEvent","#onResponseReceivedExtraInfo","redirectInfo","takeQueuedRedirectInfo","queuedEvents","getQueuedEventGroup","forgetQueuedEventGroup","loadingFinishedEvent","emitLoadingFinished","loadingFailedEvent","emitLoadingFailed","#forgetRequest","events","id","interceptionId","_interceptionId","forget","#onLoadingFinished","#emitLoadingFinished","adoptCdpSessionIfNeeded","#onLoadingFailed","#emitLoadingFailed","_failureText","errorText","RequestFailed","#adoptCdpSessionIfNeeded"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/NetworkManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {CDPSessionEvent, type CDPSession} from '../api/CDPSession.js';\nimport type {Frame} from '../api/Frame.js';\nimport type {Credentials} from '../api/Page.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {\n  NetworkManagerEvent,\n  type NetworkManagerEvents,\n} from '../common/NetworkManagerEvents.js';\nimport {debugError, isString} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {DisposableStack} from '../util/disposable.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport {isTargetClosedError} from './Connection.js';\nimport {CdpHTTPRequest} from './HTTPRequest.js';\nimport {CdpHTTPResponse} from './HTTPResponse.js';\nimport {\n  NetworkEventManager,\n  type FetchRequestId,\n} from './NetworkEventManager.js';\n\n/**\n * @public\n */\nexport interface NetworkConditions {\n  /**\n   * Download speed (bytes/s)\n   */\n  download: number;\n  /**\n   * Upload speed (bytes/s)\n   */\n  upload: number;\n  /**\n   * Latency (ms)\n   */\n  latency: number;\n}\n\n/**\n * @public\n */\nexport interface InternalNetworkConditions extends NetworkConditions {\n  offline: boolean;\n}\n\n/**\n * @internal\n */\nexport interface FrameProvider {\n  frame(id: string): Frame | null;\n}\n\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter<NetworkManagerEvents> {\n  #frameManager: FrameProvider;\n  #networkEventManager = new NetworkEventManager();\n  #extraHTTPHeaders?: Record<string, string>;\n  #credentials: Credentials | null = null;\n  #attemptedAuthentications = new Set<string>();\n  #userRequestInterceptionEnabled = false;\n  #protocolRequestInterceptionEnabled = false;\n  #userCacheDisabled?: boolean;\n  #emulatedNetworkConditions?: InternalNetworkConditions;\n  #userAgent?: string;\n  #userAgentMetadata?: Protocol.Emulation.UserAgentMetadata;\n\n  readonly #handlers = [\n    ['Fetch.requestPaused', this.#onRequestPaused],\n    ['Fetch.authRequired', this.#onAuthRequired],\n    ['Network.requestWillBeSent', this.#onRequestWillBeSent],\n    ['Network.requestServedFromCache', this.#onRequestServedFromCache],\n    ['Network.responseReceived', this.#onResponseReceived],\n    ['Network.loadingFinished', this.#onLoadingFinished],\n    ['Network.loadingFailed', this.#onLoadingFailed],\n    ['Network.responseReceivedExtraInfo', this.#onResponseReceivedExtraInfo],\n    [CDPSessionEvent.Disconnected, this.#removeClient],\n  ] as const;\n\n  #clients = new Map<CDPSession, DisposableStack>();\n  #networkEnabled = true;\n\n  constructor(frameManager: FrameProvider, networkEnabled?: boolean) {\n    super();\n    this.#frameManager = frameManager;\n    this.#networkEnabled = networkEnabled ?? true;\n  }\n\n  #canIgnoreError(error: unknown) {\n    return (\n      isErrorLike(error) &&\n      (isTargetClosedError(error) || error.message.includes('Not supported'))\n    );\n  }\n\n  async addClient(client: CDPSession): Promise<void> {\n    if (!this.#networkEnabled || this.#clients.has(client)) {\n      return;\n    }\n    const subscriptions = new DisposableStack();\n    this.#clients.set(client, subscriptions);\n    const clientEmitter = subscriptions.use(new EventEmitter(client));\n\n    for (const [event, handler] of this.#handlers) {\n      clientEmitter.on(event, (arg: any) => {\n        return handler.bind(this)(client, arg);\n      });\n    }\n\n    try {\n      await Promise.all([\n        client.send('Network.enable'),\n        this.#applyExtraHTTPHeaders(client),\n        this.#applyNetworkConditions(client),\n        this.#applyProtocolCacheDisabled(client),\n        this.#applyProtocolRequestInterception(client),\n        this.#applyUserAgent(client),\n      ]);\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async #removeClient(client: CDPSession) {\n    this.#clients.get(client)?.dispose();\n    this.#clients.delete(client);\n  }\n\n  async authenticate(credentials: Credentials | null): Promise<void> {\n    this.#credentials = credentials;\n    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;\n    if (enabled === this.#protocolRequestInterceptionEnabled) {\n      return;\n    }\n    this.#protocolRequestInterceptionEnabled = enabled;\n    await this.#applyToAllClients(\n      this.#applyProtocolRequestInterception.bind(this),\n    );\n  }\n\n  async setExtraHTTPHeaders(headers: Record<string, string>): Promise<void> {\n    const extraHTTPHeaders: Record<string, string> = {};\n    for (const [key, value] of Object.entries(headers)) {\n      assert(\n        isString(value),\n        `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`,\n      );\n      extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n    this.#extraHTTPHeaders = extraHTTPHeaders;\n\n    await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));\n  }\n\n  async #applyExtraHTTPHeaders(client: CDPSession) {\n    if (this.#extraHTTPHeaders === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.setExtraHTTPHeaders', {\n        headers: this.#extraHTTPHeaders,\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  extraHTTPHeaders(): Record<string, string> {\n    return Object.assign({}, this.#extraHTTPHeaders);\n  }\n\n  inFlightRequestsCount(): number {\n    return this.#networkEventManager.inFlightRequestsCount();\n  }\n\n  async setOfflineMode(value: boolean): Promise<void> {\n    if (!this.#emulatedNetworkConditions) {\n      this.#emulatedNetworkConditions = {\n        offline: false,\n        upload: -1,\n        download: -1,\n        latency: 0,\n      };\n    }\n    this.#emulatedNetworkConditions.offline = value;\n    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));\n  }\n\n  async emulateNetworkConditions(\n    networkConditions: NetworkConditions | null,\n  ): Promise<void> {\n    if (!this.#emulatedNetworkConditions) {\n      this.#emulatedNetworkConditions = {\n        offline: false,\n        upload: -1,\n        download: -1,\n        latency: 0,\n      };\n    }\n    this.#emulatedNetworkConditions.upload = networkConditions\n      ? networkConditions.upload\n      : -1;\n    this.#emulatedNetworkConditions.download = networkConditions\n      ? networkConditions.download\n      : -1;\n    this.#emulatedNetworkConditions.latency = networkConditions\n      ? networkConditions.latency\n      : 0;\n\n    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));\n  }\n\n  async #applyToAllClients(fn: (client: CDPSession) => Promise<unknown>) {\n    await Promise.all(\n      Array.from(this.#clients.keys()).map(client => {\n        return fn(client);\n      }),\n    );\n  }\n\n  async #applyNetworkConditions(client: CDPSession): Promise<void> {\n    if (this.#emulatedNetworkConditions === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.emulateNetworkConditions', {\n        offline: this.#emulatedNetworkConditions.offline,\n        latency: this.#emulatedNetworkConditions.latency,\n        uploadThroughput: this.#emulatedNetworkConditions.upload,\n        downloadThroughput: this.#emulatedNetworkConditions.download,\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata,\n  ): Promise<void> {\n    this.#userAgent = userAgent;\n    this.#userAgentMetadata = userAgentMetadata;\n    await this.#applyToAllClients(this.#applyUserAgent.bind(this));\n  }\n\n  async #applyUserAgent(client: CDPSession) {\n    if (this.#userAgent === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.setUserAgentOverride', {\n        userAgent: this.#userAgent,\n        userAgentMetadata: this.#userAgentMetadata,\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async setCacheEnabled(enabled: boolean): Promise<void> {\n    this.#userCacheDisabled = !enabled;\n    await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));\n  }\n\n  async setRequestInterception(value: boolean): Promise<void> {\n    this.#userRequestInterceptionEnabled = value;\n    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;\n    if (enabled === this.#protocolRequestInterceptionEnabled) {\n      return;\n    }\n    this.#protocolRequestInterceptionEnabled = enabled;\n    await this.#applyToAllClients(\n      this.#applyProtocolRequestInterception.bind(this),\n    );\n  }\n\n  async #applyProtocolRequestInterception(client: CDPSession): Promise<void> {\n    if (this.#userCacheDisabled === undefined) {\n      this.#userCacheDisabled = false;\n    }\n    try {\n      if (this.#protocolRequestInterceptionEnabled) {\n        await Promise.all([\n          this.#applyProtocolCacheDisabled(client),\n          client.send('Fetch.enable', {\n            handleAuthRequests: true,\n            patterns: [{urlPattern: '*'}],\n          }),\n        ]);\n      } else {\n        await Promise.all([\n          this.#applyProtocolCacheDisabled(client),\n          client.send('Fetch.disable'),\n        ]);\n      }\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  async #applyProtocolCacheDisabled(client: CDPSession): Promise<void> {\n    if (this.#userCacheDisabled === undefined) {\n      return;\n    }\n    try {\n      await client.send('Network.setCacheDisabled', {\n        cacheDisabled: this.#userCacheDisabled,\n      });\n    } catch (error) {\n      if (this.#canIgnoreError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n\n  #onRequestWillBeSent(\n    client: CDPSession,\n    event: Protocol.Network.RequestWillBeSentEvent,\n  ): void {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (\n      this.#userRequestInterceptionEnabled &&\n      !event.request.url.startsWith('data:')\n    ) {\n      const {requestId: networkRequestId} = event;\n\n      this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);\n\n      /**\n       * CDP may have sent a Fetch.requestPaused event already. Check for it.\n       */\n      const requestPausedEvent =\n        this.#networkEventManager.getRequestPaused(networkRequestId);\n      if (requestPausedEvent) {\n        const {requestId: fetchRequestId} = requestPausedEvent;\n        this.#patchRequestEventHeaders(event, requestPausedEvent);\n        this.#onRequest(client, event, fetchRequestId);\n        this.#networkEventManager.forgetRequestPaused(networkRequestId);\n      }\n\n      return;\n    }\n    this.#onRequest(client, event, undefined);\n  }\n\n  #onAuthRequired(\n    client: CDPSession,\n    event: Protocol.Fetch.AuthRequiredEvent,\n  ): void {\n    let response: Protocol.Fetch.AuthChallengeResponse['response'] = 'Default';\n    if (this.#attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this.#credentials) {\n      response = 'ProvideCredentials';\n      this.#attemptedAuthentications.add(event.requestId);\n    }\n    const {username, password} = this.#credentials || {\n      username: undefined,\n      password: undefined,\n    };\n    client\n      .send('Fetch.continueWithAuth', {\n        requestId: event.requestId,\n        authChallengeResponse: {response, username, password},\n      })\n      .catch(debugError);\n  }\n\n  /**\n   * CDP may send a Fetch.requestPaused without or before a\n   * Network.requestWillBeSent\n   *\n   * CDP may send multiple Fetch.requestPaused\n   * for the same Network.requestWillBeSent.\n   */\n  #onRequestPaused(\n    client: CDPSession,\n    event: Protocol.Fetch.RequestPausedEvent,\n  ): void {\n    if (\n      !this.#userRequestInterceptionEnabled &&\n      this.#protocolRequestInterceptionEnabled\n    ) {\n      client\n        .send('Fetch.continueRequest', {\n          requestId: event.requestId,\n        })\n        .catch(debugError);\n    }\n\n    const {networkId: networkRequestId, requestId: fetchRequestId} = event;\n\n    if (!networkRequestId) {\n      this.#onRequestWithoutNetworkInstrumentation(client, event);\n      return;\n    }\n\n    const requestWillBeSentEvent = (() => {\n      const requestWillBeSentEvent =\n        this.#networkEventManager.getRequestWillBeSent(networkRequestId);\n\n      // redirect requests have the same `requestId`,\n      if (\n        requestWillBeSentEvent &&\n        (requestWillBeSentEvent.request.url !== event.request.url ||\n          requestWillBeSentEvent.request.method !== event.request.method)\n      ) {\n        this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);\n        return;\n      }\n      return requestWillBeSentEvent;\n    })();\n\n    if (requestWillBeSentEvent) {\n      this.#patchRequestEventHeaders(requestWillBeSentEvent, event);\n      this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);\n    } else {\n      this.#networkEventManager.storeRequestPaused(networkRequestId, event);\n    }\n  }\n\n  #patchRequestEventHeaders(\n    requestWillBeSentEvent: Protocol.Network.RequestWillBeSentEvent,\n    requestPausedEvent: Protocol.Fetch.RequestPausedEvent,\n  ): void {\n    requestWillBeSentEvent.request.headers = {\n      ...requestWillBeSentEvent.request.headers,\n      // includes extra headers, like: Accept, Origin\n      ...requestPausedEvent.request.headers,\n    };\n  }\n\n  #onRequestWithoutNetworkInstrumentation(\n    client: CDPSession,\n    event: Protocol.Fetch.RequestPausedEvent,\n  ): void {\n    // If an event has no networkId it should not have any network events. We\n    // still want to dispatch it for the interception by the user.\n    const frame = event.frameId\n      ? this.#frameManager.frame(event.frameId)\n      : null;\n\n    const request = new CdpHTTPRequest(\n      client,\n      frame,\n      event.requestId,\n      this.#userRequestInterceptionEnabled,\n      event,\n      [],\n    );\n    this.emit(NetworkManagerEvent.Request, request);\n    void request.finalizeInterceptions();\n  }\n\n  #onRequest(\n    client: CDPSession,\n    event: Protocol.Network.RequestWillBeSentEvent,\n    fetchRequestId?: FetchRequestId,\n    fromMemoryCache = false,\n  ): void {\n    let redirectChain: CdpHTTPRequest[] = [];\n    if (event.redirectResponse) {\n      // We want to emit a response and requestfinished for the\n      // redirectResponse, but we can't do so unless we have a\n      // responseExtraInfo ready to pair it up with. If we don't have any\n      // responseExtraInfos saved in our queue, they we have to wait until\n      // the next one to emit response and requestfinished, *and* we should\n      // also wait to emit this Request too because it should come after the\n      // response/requestfinished.\n      let redirectResponseExtraInfo = null;\n      if (event.redirectHasExtraInfo) {\n        redirectResponseExtraInfo = this.#networkEventManager\n          .responseExtraInfo(event.requestId)\n          .shift();\n        if (!redirectResponseExtraInfo) {\n          this.#networkEventManager.queueRedirectInfo(event.requestId, {\n            event,\n            fetchRequestId,\n          });\n          return;\n        }\n      }\n\n      const request = this.#networkEventManager.getRequest(event.requestId);\n      // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n      if (request) {\n        this.#handleRequestRedirect(\n          client,\n          request,\n          event.redirectResponse,\n          redirectResponseExtraInfo,\n        );\n        redirectChain = request._redirectChain;\n      }\n    }\n    const frame = event.frameId\n      ? this.#frameManager.frame(event.frameId)\n      : null;\n\n    const request = new CdpHTTPRequest(\n      client,\n      frame,\n      fetchRequestId,\n      this.#userRequestInterceptionEnabled,\n      event,\n      redirectChain,\n    );\n    request._fromMemoryCache = fromMemoryCache;\n    this.#networkEventManager.storeRequest(event.requestId, request);\n    this.emit(NetworkManagerEvent.Request, request);\n    void request.finalizeInterceptions();\n  }\n\n  #onRequestServedFromCache(\n    client: CDPSession,\n    event: Protocol.Network.RequestServedFromCacheEvent,\n  ): void {\n    const requestWillBeSentEvent =\n      this.#networkEventManager.getRequestWillBeSent(event.requestId);\n    let request = this.#networkEventManager.getRequest(event.requestId);\n    // Requests served from memory cannot be intercepted.\n    if (request) {\n      request._fromMemoryCache = true;\n    }\n    // If request ended up being served from cache, we need to convert\n    // requestWillBeSentEvent to a HTTP request.\n    if (!request && requestWillBeSentEvent) {\n      this.#onRequest(client, requestWillBeSentEvent, undefined, true);\n      request = this.#networkEventManager.getRequest(event.requestId);\n    }\n    if (!request) {\n      debugError(\n        new Error(\n          `Request ${event.requestId} was served from cache but we could not find the corresponding request object`,\n        ),\n      );\n      return;\n    }\n    this.emit(NetworkManagerEvent.RequestServedFromCache, request);\n  }\n\n  #handleRequestRedirect(\n    _client: CDPSession,\n    request: CdpHTTPRequest,\n    responsePayload: Protocol.Network.Response,\n    extraInfo: Protocol.Network.ResponseReceivedExtraInfoEvent | null,\n  ): void {\n    const response = new CdpHTTPResponse(request, responsePayload, extraInfo);\n    request._response = response;\n    request._redirectChain.push(request);\n    response._resolveBody(\n      new Error('Response body is unavailable for redirect responses'),\n    );\n    this.#forgetRequest(request, false);\n    this.emit(NetworkManagerEvent.Response, response);\n    this.emit(NetworkManagerEvent.RequestFinished, request);\n  }\n\n  #emitResponseEvent(\n    _client: CDPSession,\n    responseReceived: Protocol.Network.ResponseReceivedEvent,\n    extraInfo: Protocol.Network.ResponseReceivedExtraInfoEvent | null,\n  ): void {\n    const request = this.#networkEventManager.getRequest(\n      responseReceived.requestId,\n    );\n    // FileUpload sends a response without a matching request.\n    if (!request) {\n      return;\n    }\n\n    const extraInfos = this.#networkEventManager.responseExtraInfo(\n      responseReceived.requestId,\n    );\n    if (extraInfos.length) {\n      debugError(\n        new Error(\n          'Unexpected extraInfo events for request ' +\n            responseReceived.requestId,\n        ),\n      );\n    }\n\n    // Chromium sends wrong extraInfo events for responses served from cache.\n    // See https://github.com/puppeteer/puppeteer/issues/9965 and\n    // https://crbug.com/1340398.\n    if (responseReceived.response.fromDiskCache) {\n      extraInfo = null;\n    }\n\n    const response = new CdpHTTPResponse(\n      request,\n      responseReceived.response,\n      extraInfo,\n    );\n    request._response = response;\n    this.emit(NetworkManagerEvent.Response, response);\n  }\n\n  #onResponseReceived(\n    client: CDPSession,\n    event: Protocol.Network.ResponseReceivedEvent,\n  ): void {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    let extraInfo = null;\n    if (request && !request._fromMemoryCache && event.hasExtraInfo) {\n      extraInfo = this.#networkEventManager\n        .responseExtraInfo(event.requestId)\n        .shift();\n      if (!extraInfo) {\n        // Wait until we get the corresponding ExtraInfo event.\n        this.#networkEventManager.queueEventGroup(event.requestId, {\n          responseReceivedEvent: event,\n        });\n        return;\n      }\n    }\n    this.#emitResponseEvent(client, event, extraInfo);\n  }\n\n  #onResponseReceivedExtraInfo(\n    client: CDPSession,\n    event: Protocol.Network.ResponseReceivedExtraInfoEvent,\n  ): void {\n    // We may have skipped a redirect response/request pair due to waiting for\n    // this ExtraInfo event. If so, continue that work now that we have the\n    // request.\n    const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(\n      event.requestId,\n    );\n    if (redirectInfo) {\n      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n      this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);\n      return;\n    }\n\n    // We may have skipped response and loading events because we didn't have\n    // this ExtraInfo event yet. If so, emit those events now.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(\n      event.requestId,\n    );\n    if (queuedEvents) {\n      this.#networkEventManager.forgetQueuedEventGroup(event.requestId);\n      this.#emitResponseEvent(\n        client,\n        queuedEvents.responseReceivedEvent,\n        event,\n      );\n      if (queuedEvents.loadingFinishedEvent) {\n        this.#emitLoadingFinished(client, queuedEvents.loadingFinishedEvent);\n      }\n      if (queuedEvents.loadingFailedEvent) {\n        this.#emitLoadingFailed(client, queuedEvents.loadingFailedEvent);\n      }\n      return;\n    }\n\n    // Wait until we get another event that can use this ExtraInfo event.\n    this.#networkEventManager.responseExtraInfo(event.requestId).push(event);\n  }\n\n  #forgetRequest(request: CdpHTTPRequest, events: boolean): void {\n    const requestId = request.id;\n    const interceptionId = request._interceptionId;\n\n    this.#networkEventManager.forgetRequest(requestId);\n    if (interceptionId !== undefined) {\n      this.#attemptedAuthentications.delete(interceptionId);\n    }\n\n    if (events) {\n      this.#networkEventManager.forget(requestId);\n    }\n  }\n\n  #onLoadingFinished(\n    client: CDPSession,\n    event: Protocol.Network.LoadingFinishedEvent,\n  ): void {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(\n      event.requestId,\n    );\n    if (queuedEvents) {\n      queuedEvents.loadingFinishedEvent = event;\n    } else {\n      this.#emitLoadingFinished(client, event);\n    }\n  }\n\n  #emitLoadingFinished(\n    client: CDPSession,\n    event: Protocol.Network.LoadingFinishedEvent,\n  ): void {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n\n    this.#adoptCdpSessionIfNeeded(client, request);\n\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    if (request.response()) {\n      request.response()?._resolveBody();\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEvent.RequestFinished, request);\n  }\n\n  #onLoadingFailed(\n    client: CDPSession,\n    event: Protocol.Network.LoadingFailedEvent,\n  ): void {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(\n      event.requestId,\n    );\n    if (queuedEvents) {\n      queuedEvents.loadingFailedEvent = event;\n    } else {\n      this.#emitLoadingFailed(client, event);\n    }\n  }\n\n  #emitLoadingFailed(\n    client: CDPSession,\n    event: Protocol.Network.LoadingFailedEvent,\n  ): void {\n    const request = this.#networkEventManager.getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n      return;\n    }\n    this.#adoptCdpSessionIfNeeded(client, request);\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) {\n      response._resolveBody();\n    }\n    this.#forgetRequest(request, true);\n    this.emit(NetworkManagerEvent.RequestFailed, request);\n  }\n\n  #adoptCdpSessionIfNeeded(client: CDPSession, request: CdpHTTPRequest): void {\n    // Document requests for OOPIFs start in the parent frame but are\n    // adopted by their child frame, meaning their loadingFinished and\n    // loadingFailed events are fired on the child session. In this case\n    // we reassign the request CDPSession to ensure all subsequent\n    // actions use the correct session (e.g. retrieving response body in\n    // HTTPResponse). The same applies to main worker script requests.\n    if (client !== request.client) {\n      request.client = client;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}