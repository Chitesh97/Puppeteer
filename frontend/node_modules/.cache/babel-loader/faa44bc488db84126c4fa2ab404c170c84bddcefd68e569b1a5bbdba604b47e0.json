{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nimport { bindIsolatedHandle, ElementHandle } from '../api/ElementHandle.js';\nimport { debugError } from '../common/util.js';\nimport { environment } from '../environment.js';\nimport { assert } from '../util/assert.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nimport { throwIfDisposed } from '../util/decorators.js';\nimport { CdpJSHandle } from './JSHandle.js';\nconst NON_ELEMENT_NODE_ROLES = new Set(['StaticText', 'InlineTextBox']);\n/**\n * The CdpElementHandle extends ElementHandle now to keep compatibility\n * with `instanceof` because of that we need to have methods for\n * CdpJSHandle to in this implementation as well.\n *\n * @internal\n */\nlet CdpElementHandle = (() => {\n  let _classSuper = ElementHandle;\n  let _instanceExtraInitializers = [];\n  let _contentFrame_decorators;\n  let _scrollIntoView_decorators;\n  let _uploadFile_decorators;\n  let _autofill_decorators;\n  return class CdpElementHandle extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      _contentFrame_decorators = [throwIfDisposed()];\n      _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _uploadFile_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _autofill_decorators = [throwIfDisposed()];\n      __esDecorate(this, null, _contentFrame_decorators, {\n        kind: \"method\",\n        name: \"contentFrame\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"contentFrame\" in obj,\n          get: obj => obj.contentFrame\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _scrollIntoView_decorators, {\n        kind: \"method\",\n        name: \"scrollIntoView\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"scrollIntoView\" in obj,\n          get: obj => obj.scrollIntoView\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _uploadFile_decorators, {\n        kind: \"method\",\n        name: \"uploadFile\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"uploadFile\" in obj,\n          get: obj => obj.uploadFile\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _autofill_decorators, {\n        kind: \"method\",\n        name: \"autofill\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"autofill\" in obj,\n          get: obj => obj.autofill\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    #backendNodeId = __runInitializers(this, _instanceExtraInitializers);\n    constructor(world, remoteObject) {\n      super(new CdpJSHandle(world, remoteObject));\n    }\n    get realm() {\n      return this.handle.realm;\n    }\n    get client() {\n      return this.handle.client;\n    }\n    remoteObject() {\n      return this.handle.remoteObject();\n    }\n    get #frameManager() {\n      return this.frame._frameManager;\n    }\n    get frame() {\n      return this.realm.environment;\n    }\n    async contentFrame() {\n      const nodeInfo = await this.client.send('DOM.describeNode', {\n        objectId: this.id\n      });\n      if (typeof nodeInfo.node.frameId !== 'string') {\n        return null;\n      }\n      return this.#frameManager.frame(nodeInfo.node.frameId);\n    }\n    async scrollIntoView() {\n      await this.assertConnectedElement();\n      try {\n        await this.client.send('DOM.scrollIntoViewIfNeeded', {\n          objectId: this.id\n        });\n      } catch (error) {\n        debugError(error);\n        // Fallback to Element.scrollIntoView if DOM.scrollIntoViewIfNeeded is not supported\n        await super.scrollIntoView();\n      }\n    }\n    async uploadFile(...files) {\n      const isMultiple = await this.evaluate(element => {\n        return element.multiple;\n      });\n      assert(files.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');\n      // Locate all files and confirm that they exist.\n      const path = environment.value.path;\n      if (path) {\n        files = files.map(filePath => {\n          if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {\n            return filePath;\n          } else {\n            return path.resolve(filePath);\n          }\n        });\n      }\n      /**\n       * The zero-length array is a special case, it seems that\n       * DOM.setFileInputFiles does not actually update the files in that case, so\n       * the solution is to eval the element value to a new FileList directly.\n       */\n      if (files.length === 0) {\n        // XXX: These events should converted to trusted events. Perhaps do this\n        // in `DOM.setFileInputFiles`?\n        await this.evaluate(element => {\n          element.files = new DataTransfer().files;\n          // Dispatch events for this case because it should behave akin to a user action.\n          element.dispatchEvent(new Event('input', {\n            bubbles: true,\n            composed: true\n          }));\n          element.dispatchEvent(new Event('change', {\n            bubbles: true\n          }));\n        });\n        return;\n      }\n      const {\n        node: {\n          backendNodeId\n        }\n      } = await this.client.send('DOM.describeNode', {\n        objectId: this.id\n      });\n      await this.client.send('DOM.setFileInputFiles', {\n        objectId: this.id,\n        files,\n        backendNodeId\n      });\n    }\n    async autofill(data) {\n      const nodeInfo = await this.client.send('DOM.describeNode', {\n        objectId: this.handle.id\n      });\n      const fieldId = nodeInfo.node.backendNodeId;\n      const frameId = this.frame._id;\n      await this.client.send('Autofill.trigger', {\n        fieldId,\n        frameId,\n        card: data.creditCard\n      });\n    }\n    async *queryAXTree(name, role) {\n      const {\n        nodes\n      } = await this.client.send('Accessibility.queryAXTree', {\n        objectId: this.id,\n        accessibleName: name,\n        role\n      });\n      const results = nodes.filter(node => {\n        if (node.ignored) {\n          return false;\n        }\n        if (!node.role) {\n          return false;\n        }\n        if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {\n          return false;\n        }\n        return true;\n      });\n      return yield* AsyncIterableUtil.map(results, node => {\n        return this.realm.adoptBackendNode(node.backendDOMNodeId);\n      });\n    }\n    async backendNodeId() {\n      if (this.#backendNodeId) {\n        return this.#backendNodeId;\n      }\n      const {\n        node\n      } = await this.client.send('DOM.describeNode', {\n        objectId: this.handle.id\n      });\n      this.#backendNodeId = node.backendNodeId;\n      return this.#backendNodeId;\n    }\n  };\n})();\nexport { CdpElementHandle };","map":{"version":3,"names":["bindIsolatedHandle","ElementHandle","debugError","environment","assert","AsyncIterableUtil","throwIfDisposed","CdpJSHandle","NON_ELEMENT_NODE_ROLES","Set","CdpElementHandle","_classSuper","__esDecorate","_contentFrame_decorators","kind","name","static","private","access","has","obj","get","contentFrame","metadata","_metadata","_instanceExtraInitializers","_scrollIntoView_decorators","scrollIntoView","_uploadFile_decorators","uploadFile","_autofill_decorators","autofill","backendNodeId","__runInitializers","constructor","world","remoteObject","realm","handle","client","frameManager","#frameManager","frame","_frameManager","nodeInfo","send","objectId","id","node","frameId","assertConnectedElement","error","files","isMultiple","evaluate","element","multiple","length","path","value","map","filePath","win32","isAbsolute","posix","resolve","DataTransfer","dispatchEvent","Event","bubbles","composed","data","fieldId","_id","card","creditCard","queryAXTree","role","nodes","accessibleName","results","filter","ignored","adoptBackendNode","backendDOMNodeId"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/ElementHandle.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport {\n  bindIsolatedHandle,\n  ElementHandle,\n  type AutofillData,\n} from '../api/ElementHandle.js';\nimport type {AwaitableIterable} from '../common/types.js';\nimport {debugError} from '../common/util.js';\nimport {environment} from '../environment.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {throwIfDisposed} from '../util/decorators.js';\n\nimport type {CdpFrame} from './Frame.js';\nimport type {FrameManager} from './FrameManager.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {CdpJSHandle} from './JSHandle.js';\n\nconst NON_ELEMENT_NODE_ROLES = new Set(['StaticText', 'InlineTextBox']);\n\n/**\n * The CdpElementHandle extends ElementHandle now to keep compatibility\n * with `instanceof` because of that we need to have methods for\n * CdpJSHandle to in this implementation as well.\n *\n * @internal\n */\nexport class CdpElementHandle<\n  ElementType extends Node = Element,\n> extends ElementHandle<ElementType> {\n  declare protected readonly handle: CdpJSHandle<ElementType>;\n  #backendNodeId?: number;\n\n  constructor(\n    world: IsolatedWorld,\n    remoteObject: Protocol.Runtime.RemoteObject,\n  ) {\n    super(new CdpJSHandle(world, remoteObject));\n  }\n\n  override get realm(): IsolatedWorld {\n    return this.handle.realm;\n  }\n\n  get client(): CDPSession {\n    return this.handle.client;\n  }\n\n  override remoteObject(): Protocol.Runtime.RemoteObject {\n    return this.handle.remoteObject();\n  }\n\n  get #frameManager(): FrameManager {\n    return this.frame._frameManager;\n  }\n\n  override get frame(): CdpFrame {\n    return this.realm.environment as CdpFrame;\n  }\n\n  override async contentFrame(\n    this: ElementHandle<HTMLIFrameElement>,\n  ): Promise<CdpFrame>;\n\n  @throwIfDisposed()\n  override async contentFrame(): Promise<CdpFrame | null> {\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: this.id,\n    });\n    if (typeof nodeInfo.node.frameId !== 'string') {\n      return null;\n    }\n    return this.#frameManager.frame(nodeInfo.node.frameId);\n  }\n\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  override async scrollIntoView(\n    this: CdpElementHandle<Element>,\n  ): Promise<void> {\n    await this.assertConnectedElement();\n    try {\n      await this.client.send('DOM.scrollIntoViewIfNeeded', {\n        objectId: this.id,\n      });\n    } catch (error) {\n      debugError(error);\n      // Fallback to Element.scrollIntoView if DOM.scrollIntoViewIfNeeded is not supported\n      await super.scrollIntoView();\n    }\n  }\n\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  override async uploadFile(\n    this: CdpElementHandle<HTMLInputElement>,\n    ...files: string[]\n  ): Promise<void> {\n    const isMultiple = await this.evaluate(element => {\n      return element.multiple;\n    });\n    assert(\n      files.length <= 1 || isMultiple,\n      'Multiple file uploads only work with <input type=file multiple>',\n    );\n\n    // Locate all files and confirm that they exist.\n    const path = environment.value.path;\n    if (path) {\n      files = files.map(filePath => {\n        if (\n          path.win32.isAbsolute(filePath) ||\n          path.posix.isAbsolute(filePath)\n        ) {\n          return filePath;\n        } else {\n          return path.resolve(filePath);\n        }\n      });\n    }\n\n    /**\n     * The zero-length array is a special case, it seems that\n     * DOM.setFileInputFiles does not actually update the files in that case, so\n     * the solution is to eval the element value to a new FileList directly.\n     */\n    if (files.length === 0) {\n      // XXX: These events should converted to trusted events. Perhaps do this\n      // in `DOM.setFileInputFiles`?\n      await this.evaluate(element => {\n        element.files = new DataTransfer().files;\n\n        // Dispatch events for this case because it should behave akin to a user action.\n        element.dispatchEvent(\n          new Event('input', {bubbles: true, composed: true}),\n        );\n        element.dispatchEvent(new Event('change', {bubbles: true}));\n      });\n      return;\n    }\n\n    const {\n      node: {backendNodeId},\n    } = await this.client.send('DOM.describeNode', {\n      objectId: this.id,\n    });\n    await this.client.send('DOM.setFileInputFiles', {\n      objectId: this.id,\n      files,\n      backendNodeId,\n    });\n  }\n\n  @throwIfDisposed()\n  override async autofill(data: AutofillData): Promise<void> {\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: this.handle.id,\n    });\n    const fieldId = nodeInfo.node.backendNodeId;\n    const frameId = this.frame._id;\n    await this.client.send('Autofill.trigger', {\n      fieldId,\n      frameId,\n      card: data.creditCard,\n    });\n  }\n\n  override async *queryAXTree(\n    name?: string | undefined,\n    role?: string | undefined,\n  ): AwaitableIterable<ElementHandle<Node>> {\n    const {nodes} = await this.client.send('Accessibility.queryAXTree', {\n      objectId: this.id,\n      accessibleName: name,\n      role,\n    });\n\n    const results = nodes.filter(node => {\n      if (node.ignored) {\n        return false;\n      }\n      if (!node.role) {\n        return false;\n      }\n      if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {\n        return false;\n      }\n      return true;\n    });\n\n    return yield* AsyncIterableUtil.map(results, node => {\n      return this.realm.adoptBackendNode(node.backendDOMNodeId) as Promise<\n        ElementHandle<Node>\n      >;\n    });\n  }\n\n  override async backendNodeId(): Promise<number> {\n    if (this.#backendNodeId) {\n      return this.#backendNodeId;\n    }\n    const {node} = await this.client.send('DOM.describeNode', {\n      objectId: this.handle.id,\n    });\n    this.#backendNodeId = node.backendNodeId;\n    return this.#backendNodeId;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}