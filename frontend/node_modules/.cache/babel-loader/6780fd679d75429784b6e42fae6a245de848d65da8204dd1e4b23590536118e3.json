{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function () {\n      try {\n        inner.call(this);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    var r,\n      s = 0;\n    function next() {\n      while (r = env.stack.pop()) {\n        try {\n          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n          if (r.dispose) {\n            var result = r.dispose.call(r.value);\n            if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {\n              fail(e);\n              return next();\n            });\n          } else s |= 1;\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nvar __setFunctionName = this && this.__setFunctionName || function (f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", {\n    configurable: true,\n    value: prefix ? \"\".concat(prefix, \" \", name) : name\n  });\n};\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { isString, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nimport { throwIfDisposed } from '../util/decorators.js';\nimport { _isElementHandle } from './ElementHandleSymbol.js';\nimport { JSHandle } from './JSHandle.js';\n/**\n * A given method will have it's `this` replaced with an isolated version of\n * `this` when decorated with this decorator.\n *\n * All changes of isolated `this` are reflected on the actual `this`.\n *\n * @internal\n */\nexport function bindIsolatedHandle(target, _) {\n  return async function (...args) {\n    // If the handle is already isolated, then we don't need to adopt it\n    // again.\n    if (this.realm === this.frame.isolatedRealm()) {\n      return await target.call(this, ...args);\n    }\n    let adoptedThis;\n    if (this['isolatedHandle']) {\n      adoptedThis = this['isolatedHandle'];\n    } else {\n      this['isolatedHandle'] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);\n    }\n    const result = await target.call(adoptedThis, ...args);\n    // If the function returns `adoptedThis`, then we return `this`.\n    if (result === adoptedThis) {\n      return this;\n    }\n    // If the function returns a handle, transfer it into the current realm.\n    if (result instanceof JSHandle) {\n      return await this.realm.transferHandle(result);\n    }\n    // If the function returns an array of handlers, transfer them into the\n    // current realm.\n    if (Array.isArray(result)) {\n      await Promise.all(result.map(async (item, index, result) => {\n        if (item instanceof JSHandle) {\n          result[index] = await this.realm.transferHandle(item);\n        }\n      }));\n    }\n    if (result instanceof Map) {\n      await Promise.all([...result.entries()].map(async ([key, value]) => {\n        if (value instanceof JSHandle) {\n          result.set(key, await this.realm.transferHandle(value));\n        }\n      }));\n    }\n    return result;\n  };\n}\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nlet ElementHandle = (() => {\n  let _classSuper = JSHandle;\n  let _instanceExtraInitializers = [];\n  let _getProperty_decorators;\n  let _getProperties_decorators;\n  let _jsonValue_decorators;\n  let _$_decorators;\n  let _$$_decorators;\n  let _private_$$_decorators;\n  let _private_$$_descriptor;\n  let _waitForSelector_decorators;\n  let _isVisible_decorators;\n  let _isHidden_decorators;\n  let _toElement_decorators;\n  let _clickablePoint_decorators;\n  let _hover_decorators;\n  let _click_decorators;\n  let _drag_decorators;\n  let _dragEnter_decorators;\n  let _dragOver_decorators;\n  let _drop_decorators;\n  let _dragAndDrop_decorators;\n  let _select_decorators;\n  let _tap_decorators;\n  let _touchStart_decorators;\n  let _touchMove_decorators;\n  let _touchEnd_decorators;\n  let _focus_decorators;\n  let _type_decorators;\n  let _press_decorators;\n  let _boundingBox_decorators;\n  let _boxModel_decorators;\n  let _screenshot_decorators;\n  let _isIntersectingViewport_decorators;\n  let _scrollIntoView_decorators;\n  return class ElementHandle extends _classSuper {\n    static {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      _getProperty_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _getProperties_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _jsonValue_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _$_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _$$_decorators = [throwIfDisposed()];\n      _private_$$_decorators = [bindIsolatedHandle];\n      _waitForSelector_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _isVisible_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _isHidden_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _toElement_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _clickablePoint_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _hover_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _click_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _drag_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _dragEnter_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _dragOver_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _drop_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _dragAndDrop_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _select_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _tap_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _touchStart_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _touchMove_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _touchEnd_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _focus_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _type_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _press_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _boundingBox_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _boxModel_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _screenshot_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _isIntersectingViewport_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];\n      __esDecorate(this, null, _getProperty_decorators, {\n        kind: \"method\",\n        name: \"getProperty\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperty\" in obj,\n          get: obj => obj.getProperty\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _getProperties_decorators, {\n        kind: \"method\",\n        name: \"getProperties\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperties\" in obj,\n          get: obj => obj.getProperties\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _jsonValue_decorators, {\n        kind: \"method\",\n        name: \"jsonValue\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"jsonValue\" in obj,\n          get: obj => obj.jsonValue\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$_decorators, {\n        kind: \"method\",\n        name: \"$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$\" in obj,\n          get: obj => obj.$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$_decorators, {\n        kind: \"method\",\n        name: \"$$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$\" in obj,\n          get: obj => obj.$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, _private_$$_descriptor = {\n        value: __setFunctionName(async function (selector) {\n          return await this.#$$impl(selector);\n        }, \"#$$\")\n      }, _private_$$_decorators, {\n        kind: \"method\",\n        name: \"#$$\",\n        static: false,\n        private: true,\n        access: {\n          has: obj => #$$ in obj,\n          get: obj => obj.#$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForSelector_decorators, {\n        kind: \"method\",\n        name: \"waitForSelector\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForSelector\" in obj,\n          get: obj => obj.waitForSelector\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isVisible_decorators, {\n        kind: \"method\",\n        name: \"isVisible\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isVisible\" in obj,\n          get: obj => obj.isVisible\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isHidden_decorators, {\n        kind: \"method\",\n        name: \"isHidden\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isHidden\" in obj,\n          get: obj => obj.isHidden\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _toElement_decorators, {\n        kind: \"method\",\n        name: \"toElement\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"toElement\" in obj,\n          get: obj => obj.toElement\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _clickablePoint_decorators, {\n        kind: \"method\",\n        name: \"clickablePoint\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"clickablePoint\" in obj,\n          get: obj => obj.clickablePoint\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _hover_decorators, {\n        kind: \"method\",\n        name: \"hover\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"hover\" in obj,\n          get: obj => obj.hover\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _click_decorators, {\n        kind: \"method\",\n        name: \"click\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"click\" in obj,\n          get: obj => obj.click\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drag_decorators, {\n        kind: \"method\",\n        name: \"drag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drag\" in obj,\n          get: obj => obj.drag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragEnter_decorators, {\n        kind: \"method\",\n        name: \"dragEnter\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragEnter\" in obj,\n          get: obj => obj.dragEnter\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragOver_decorators, {\n        kind: \"method\",\n        name: \"dragOver\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragOver\" in obj,\n          get: obj => obj.dragOver\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drop_decorators, {\n        kind: \"method\",\n        name: \"drop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drop\" in obj,\n          get: obj => obj.drop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragAndDrop_decorators, {\n        kind: \"method\",\n        name: \"dragAndDrop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragAndDrop\" in obj,\n          get: obj => obj.dragAndDrop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _select_decorators, {\n        kind: \"method\",\n        name: \"select\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"select\" in obj,\n          get: obj => obj.select\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _tap_decorators, {\n        kind: \"method\",\n        name: \"tap\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"tap\" in obj,\n          get: obj => obj.tap\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchStart_decorators, {\n        kind: \"method\",\n        name: \"touchStart\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchStart\" in obj,\n          get: obj => obj.touchStart\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchMove_decorators, {\n        kind: \"method\",\n        name: \"touchMove\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchMove\" in obj,\n          get: obj => obj.touchMove\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchEnd_decorators, {\n        kind: \"method\",\n        name: \"touchEnd\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchEnd\" in obj,\n          get: obj => obj.touchEnd\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _focus_decorators, {\n        kind: \"method\",\n        name: \"focus\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"focus\" in obj,\n          get: obj => obj.focus\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _type_decorators, {\n        kind: \"method\",\n        name: \"type\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"type\" in obj,\n          get: obj => obj.type\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _press_decorators, {\n        kind: \"method\",\n        name: \"press\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"press\" in obj,\n          get: obj => obj.press\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boundingBox_decorators, {\n        kind: \"method\",\n        name: \"boundingBox\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boundingBox\" in obj,\n          get: obj => obj.boundingBox\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boxModel_decorators, {\n        kind: \"method\",\n        name: \"boxModel\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boxModel\" in obj,\n          get: obj => obj.boxModel\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isIntersectingViewport_decorators, {\n        kind: \"method\",\n        name: \"isIntersectingViewport\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isIntersectingViewport\" in obj,\n          get: obj => obj.isIntersectingViewport\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _scrollIntoView_decorators, {\n        kind: \"method\",\n        name: \"scrollIntoView\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"scrollIntoView\" in obj,\n          get: obj => obj.scrollIntoView\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    }\n    /**\n     * @internal\n     * Cached isolatedHandle to prevent\n     * trying to adopt it multiple times\n     */\n    isolatedHandle = __runInitializers(this, _instanceExtraInitializers);\n    /**\n     * @internal\n     */\n    handle;\n    /**\n     * @internal\n     */\n    constructor(handle) {\n      super();\n      this.handle = handle;\n      this[_isElementHandle] = true;\n    }\n    /**\n     * @internal\n     */\n    get id() {\n      return this.handle.id;\n    }\n    /**\n     * @internal\n     */\n    get disposed() {\n      return this.handle.disposed;\n    }\n    /**\n     * @internal\n     */\n    async getProperty(propertyName) {\n      return await this.handle.getProperty(propertyName);\n    }\n    /**\n     * @internal\n     */\n    async getProperties() {\n      return await this.handle.getProperties();\n    }\n    /**\n     * @internal\n     */\n    async evaluate(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      return await this.handle.evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async evaluateHandle(pageFunction, ...args) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      return await this.handle.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async jsonValue() {\n      return await this.handle.jsonValue();\n    }\n    /**\n     * @internal\n     */\n    toString() {\n      return this.handle.toString();\n    }\n    /**\n     * @internal\n     */\n    remoteObject() {\n      return this.handle.remoteObject();\n    }\n    /**\n     * @internal\n     */\n    async dispose() {\n      await Promise.all([this.handle.dispose(), this.isolatedHandle?.dispose()]);\n    }\n    /**\n     * @internal\n     */\n    asElement() {\n      return this;\n    }\n    /**\n     * Queries the current element for an element matching the given selector.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows querying by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @returns A {@link ElementHandle | element handle} to the first element\n     * matching the given selector. Otherwise, `null`.\n     */\n    async $(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.queryOne(this, updatedSelector);\n    }\n    /**\n     * Queries the current element for all elements matching the given selector.\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows querying by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @returns An array of {@link ElementHandle | element handles} that point to\n     * elements matching the given selector.\n     */\n    async $$(selector, options) {\n      if (options?.isolate === false) {\n        return await this.#$$impl(selector);\n      }\n      return await this.#$$(selector);\n    }\n    /**\n     * Isolates {@link ElementHandle.$$} if needed.\n     *\n     * @internal\n     */\n    get #$$() {\n      return _private_$$_descriptor.value;\n    }\n    /**\n     * Implementation for {@link ElementHandle.$$}.\n     *\n     * @internal\n     */\n    async #$$impl(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));\n    }\n    /**\n     * Runs the given function on the first element matching the given selector in\n     * the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```ts\n     * const tweetHandle = await page.$('.tweet');\n     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n     *   '100',\n     * );\n     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n     *   '10',\n     * );\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows querying by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - The function to be evaluated in this element's page's\n     * context. The first element matching the selector will be passed in as the\n     * first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $eval(selector, pageFunction, ...args) {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n        const elementHandle = __addDisposableResource(env_1, await this.$(selector), false);\n        if (!elementHandle) {\n          throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n        }\n        return await elementHandle.evaluate(pageFunction, ...args);\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    /**\n     * Runs the given function on an array of elements matching the given selector\n     * in the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     * HTML:\n     *\n     * ```html\n     * <div class=\"feed\">\n     *   <div class=\"tweet\">Hello!</div>\n     *   <div class=\"tweet\">Hi!</div>\n     * </div>\n     * ```\n     *\n     * JavaScript:\n     *\n     * ```ts\n     * const feedHandle = await page.$('.feed');\n     * expect(\n     *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)),\n     * ).toEqual(['Hello!', 'Hi!']);\n     * ```\n     *\n     * @param selector -\n     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n     * to query the page for.\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n     * can be passed as-is and a\n     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n     * allows querying by\n     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n     * and\n     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n     * Alternatively, you can specify the selector type using a\n     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n     * @param pageFunction - The function to be evaluated in the element's page's\n     * context. An array of elements matching the given selector will be passed to\n     * the function as its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n        const results = await this.$$(selector);\n        const elements = __addDisposableResource(env_2, await this.evaluateHandle((_, ...elements) => {\n          return elements;\n        }, ...results), false);\n        const [result] = await Promise.all([elements.evaluate(pageFunction, ...args), ...results.map(results => {\n          return results.dispose();\n        })]);\n        return result;\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        __disposeResources(env_2);\n      }\n    }\n    /**\n     * Wait for an element matching the given selector to appear in the current\n     * element.\n     *\n     * Unlike {@link Frame.waitForSelector}, this method does not work across\n     * navigations or if the element is detached from DOM.\n     *\n     * @example\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .mainFrame()\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - The selector to query and wait for.\n     * @param options - Options for customizing waiting behavior.\n     * @returns An element matching the given selector.\n     * @throws Throws if an element matching the given selector doesn't appear.\n     */\n    async waitForSelector(selector, options = {}) {\n      const {\n        updatedSelector,\n        QueryHandler,\n        polling\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.waitFor(this, updatedSelector, {\n        polling,\n        ...options\n      });\n    }\n    async #checkVisibility(visibility) {\n      return await this.evaluate(async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      }, LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }), visibility);\n    }\n    /**\n     * An element is considered to be visible if all of the following is\n     * true:\n     *\n     * - the element has\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n     *\n     * - the element has a non-empty\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n     *\n     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n     *   is not `hidden` or `collapse`.\n     */\n    async isVisible() {\n      return await this.#checkVisibility(true);\n    }\n    /**\n     * An element is considered to be hidden if at least one of the following is true:\n     *\n     * - the element has no\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n     *\n     * - the element has an empty\n     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n     *\n     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n     *   is `hidden` or `collapse`.\n     */\n    async isHidden() {\n      return await this.#checkVisibility(false);\n    }\n    /**\n     * Converts the current handle to the given element type.\n     *\n     * @example\n     *\n     * ```ts\n     * const element: ElementHandle<Element> = await page.$(\n     *   '.class-name-of-anchor',\n     * );\n     * // DO NOT DISPOSE `element`, this will be always be the same handle.\n     * const anchor: ElementHandle<HTMLAnchorElement> =\n     *   await element.toElement('a');\n     * ```\n     *\n     * @param tagName - The tag name of the desired element type.\n     * @throws An error if the handle does not match. **The handle will not be\n     * automatically disposed.**\n     */\n    async toElement(tagName) {\n      const isMatchingTagName = await this.evaluate((node, tagName) => {\n        return node.nodeName === tagName.toUpperCase();\n      }, tagName);\n      if (!isMatchingTagName) {\n        throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n      }\n      return this;\n    }\n    /**\n     * Returns the middle point within an element unless a specific offset is provided.\n     */\n    async clickablePoint(offset) {\n      const box = await this.#clickableBox();\n      if (!box) {\n        throw new Error('Node is either not clickable or not an Element');\n      }\n      if (offset !== undefined) {\n        return {\n          x: box.x + offset.x,\n          y: box.y + offset.y\n        };\n      }\n      return {\n        x: box.x + box.width / 2,\n        y: box.y + box.height / 2\n      };\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page.mouse} to hover over the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async hover() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().mouse.move(x, y);\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page.mouse} to click in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async click(options = {}) {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint(options.offset);\n      try {\n        await this.frame.page().mouse.click(x, y, options);\n      } finally {\n        if (options.debugHighlight) {\n          await this.frame.page().evaluate((x, y) => {\n            const highlight = document.createElement('div');\n            highlight.innerHTML = `<style>\n        @scope {\n          :scope {\n              position: fixed;\n              left: ${x}px;\n              top: ${y}px;\n              width: 10px;\n              height: 10px;\n              border-radius: 50%;\n              animation: colorChange 10s 1 normal;\n              animation-fill-mode: forwards;\n          }\n\n          @keyframes colorChange {\n              from {\n                  background-color: red;\n              }\n              to {\n                  background-color: #FADADD00;\n              }\n          }\n        }\n      </style>`;\n            highlight.addEventListener('animationend', () => {\n              highlight.remove();\n            }, {\n              once: true\n            });\n            document.body.append(highlight);\n          }, x, y);\n        }\n      }\n    }\n    /**\n     * Drags an element over the given element or point.\n     *\n     * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n     * returned.\n     */\n    async drag(target) {\n      await this.scrollIntoViewIfNeeded();\n      const page = this.frame.page();\n      if (page.isDragInterceptionEnabled()) {\n        const source = await this.clickablePoint();\n        if (target instanceof ElementHandle) {\n          target = await target.clickablePoint();\n        }\n        return await page.mouse.drag(source, target);\n      }\n      try {\n        if (!page._isDragging) {\n          page._isDragging = true;\n          await this.hover();\n          await page.mouse.down();\n        }\n        if (target instanceof ElementHandle) {\n          await target.hover();\n        } else {\n          await page.mouse.move(target.x, target.y);\n        }\n      } catch (error) {\n        page._isDragging = false;\n        throw error;\n      }\n    }\n    /**\n     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n     */\n    async dragEnter(data = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragEnter(target, data);\n    }\n    /**\n     * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n     */\n    async dragOver(data = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragOver(target, data);\n    }\n    /**\n     * @internal\n     */\n    async drop(dataOrElement = {\n      items: [],\n      dragOperationsMask: 1\n    }) {\n      const page = this.frame.page();\n      if ('items' in dataOrElement) {\n        await this.scrollIntoViewIfNeeded();\n        const destination = await this.clickablePoint();\n        await page.mouse.drop(destination, dataOrElement);\n      } else {\n        // Note if the rest errors, we still want dragging off because the errors\n        // is most likely something implying the mouse is no longer dragging.\n        await dataOrElement.drag(this);\n        page._isDragging = false;\n        await page.mouse.up();\n      }\n    }\n    /**\n     * @deprecated Use `ElementHandle.drop` instead.\n     */\n    async dragAndDrop(target, options) {\n      const page = this.frame.page();\n      assert(page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');\n      await this.scrollIntoViewIfNeeded();\n      const startPoint = await this.clickablePoint();\n      const targetPoint = await target.clickablePoint();\n      await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * handle.select('blue'); // single selection\n     * handle.select('red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     */\n    async select(...values) {\n      for (const value of values) {\n        assert(isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + typeof value + '\"');\n      }\n      return await this.evaluate((element, vals) => {\n        const values = new Set(vals);\n        if (!(element instanceof HTMLSelectElement)) {\n          throw new Error('Element is not a <select> element.');\n        }\n        const selectedValues = new Set();\n        if (!element.multiple) {\n          for (const option of element.options) {\n            option.selected = false;\n          }\n          for (const option of element.options) {\n            if (values.has(option.value)) {\n              option.selected = true;\n              selectedValues.add(option.value);\n              break;\n            }\n          }\n        } else {\n          for (const option of element.options) {\n            option.selected = values.has(option.value);\n            if (option.selected) {\n              selectedValues.add(option.value);\n            }\n          }\n        }\n        element.dispatchEvent(new Event('input', {\n          bubbles: true\n        }));\n        element.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n        return [...selectedValues.values()];\n      }, values);\n    }\n    /**\n     * This method scrolls element into view if needed, and then uses\n     * {@link Touchscreen.tap} to tap in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async tap() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.tap(x, y);\n    }\n    /**\n     * This method scrolls the element into view if needed, and then\n     * starts a touch in the center of the element.\n     * @returns A {@link TouchHandle} representing the touch that was started\n     */\n    async touchStart() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      return await this.frame.page().touchscreen.touchStart(x, y);\n    }\n    /**\n     * This method scrolls the element into view if needed, and then\n     * moves the touch to the center of the element.\n     * @param touch - An optional {@link TouchHandle}. If provided, this touch\n     * will be moved. If not provided, the first active touch will be moved.\n     */\n    async touchMove(touch) {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      if (touch) {\n        return await touch.move(x, y);\n      }\n      await this.frame.page().touchscreen.touchMove(x, y);\n    }\n    async touchEnd() {\n      await this.scrollIntoViewIfNeeded();\n      await this.frame.page().touchscreen.touchEnd();\n    }\n    /**\n     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n     */\n    async focus() {\n      await this.evaluate(element => {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('Cannot focus non-HTMLElement');\n        }\n        return element.focus();\n      });\n    }\n    /**\n     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n     * `keyup` event for each character in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`,\n     * use {@link ElementHandle.press}.\n     *\n     * @example\n     *\n     * ```ts\n     * await elementHandle.type('Hello'); // Types instantly\n     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @example\n     * An example of typing into a text field and then submitting the form:\n     *\n     * ```ts\n     * const elementHandle = await page.$('input');\n     * await elementHandle.type('some text');\n     * await elementHandle.press('Enter');\n     * ```\n     *\n     * @param options - Delay in milliseconds. Defaults to 0.\n     */\n    async type(text, options) {\n      await this.focus();\n      await this.frame.page().keyboard.type(text, options);\n    }\n    /**\n     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n     *\n     * @remarks\n     * If `key` is a single character and no modifier keys besides `Shift`\n     * are being held down, a `keypress`/`input` event will also be generated.\n     * The `text` option can be specified to force an input event to be generated.\n     *\n     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n     * will type the text in upper case.\n     *\n     * @param key - Name of key to press, such as `ArrowLeft`.\n     * See {@link KeyInput} for a list of all key names.\n     */\n    async press(key, options) {\n      await this.focus();\n      await this.frame.page().keyboard.press(key, options);\n    }\n    async #clickableBox() {\n      const boxes = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        return [...element.getClientRects()].map(rect => {\n          return {\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n          };\n        });\n      });\n      if (!boxes?.length) {\n        return null;\n      }\n      await this.#intersectBoundingBoxesWithFrame(boxes);\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_3 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_3, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          for (const box of boxes) {\n            box.x += parentBox.left;\n            box.y += parentBox.top;\n          }\n          await handle.#intersectBoundingBoxesWithFrame(boxes);\n          frame = parentFrame;\n        } catch (e_3) {\n          env_3.error = e_3;\n          env_3.hasError = true;\n        } finally {\n          __disposeResources(env_3);\n        }\n      }\n      const box = boxes.find(box => {\n        return box.width >= 1 && box.height >= 1;\n      });\n      if (!box) {\n        return null;\n      }\n      return {\n        x: box.x,\n        y: box.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    async #intersectBoundingBoxesWithFrame(boxes) {\n      const {\n        documentWidth,\n        documentHeight\n      } = await this.frame.isolatedRealm().evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight\n        };\n      });\n      for (const box of boxes) {\n        intersectBoundingBox(box, documentWidth, documentHeight);\n      }\n    }\n    /**\n     * This method returns the bounding box of the element (relative to the main frame),\n     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n     * (example: `display: none`).\n     */\n    async boundingBox() {\n      const box = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        return {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      });\n      if (!box) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    /**\n     * This method returns boxes of the element,\n     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n     * (example: `display: none`).\n     *\n     * @remarks\n     *\n     * Boxes are represented as an array of points;\n     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n     */\n    async boxModel() {\n      const model = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        const offsets = {\n          padding: {\n            left: parseInt(style.paddingLeft, 10),\n            top: parseInt(style.paddingTop, 10),\n            right: parseInt(style.paddingRight, 10),\n            bottom: parseInt(style.paddingBottom, 10)\n          },\n          margin: {\n            left: -parseInt(style.marginLeft, 10),\n            top: -parseInt(style.marginTop, 10),\n            right: -parseInt(style.marginRight, 10),\n            bottom: -parseInt(style.marginBottom, 10)\n          },\n          border: {\n            left: parseInt(style.borderLeft, 10),\n            top: parseInt(style.borderTop, 10),\n            right: parseInt(style.borderRight, 10),\n            bottom: parseInt(style.borderBottom, 10)\n          }\n        };\n        const border = [{\n          x: rect.left,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top + rect.height\n        }, {\n          x: rect.left,\n          y: rect.top + rect.height\n        }];\n        const padding = transformQuadWithOffsets(border, offsets.border);\n        const content = transformQuadWithOffsets(padding, offsets.padding);\n        const margin = transformQuadWithOffsets(border, offsets.margin);\n        return {\n          content,\n          padding,\n          border,\n          margin,\n          width: rect.width,\n          height: rect.height\n        };\n        function transformQuadWithOffsets(quad, offsets) {\n          return [{\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top\n          }, {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top\n          }, {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom\n          }, {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom\n          }];\n        }\n      });\n      if (!model) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      for (const attribute of ['content', 'padding', 'border', 'margin']) {\n        for (const point of model[attribute]) {\n          point.x += offset.x;\n          point.y += offset.y;\n        }\n      }\n      return model;\n    }\n    async #getTopLeftCornerOfFrame() {\n      const point = {\n        x: 0,\n        y: 0\n      };\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_4 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_4, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          point.x += parentBox.left;\n          point.y += parentBox.top;\n          frame = parentFrame;\n        } catch (e_4) {\n          env_4.error = e_4;\n          env_4.hasError = true;\n        } finally {\n          __disposeResources(env_4);\n        }\n      }\n      return point;\n    }\n    async screenshot(options = {}) {\n      const {\n        scrollIntoView = true,\n        clip\n      } = options;\n      const page = this.frame.page();\n      // Only scroll the element into view if the user wants it.\n      if (scrollIntoView) {\n        await this.scrollIntoViewIfNeeded();\n      }\n      const elementClip = await this.#nonEmptyVisibleBoundingBox();\n      const [pageLeft, pageTop] = await this.evaluate(() => {\n        if (!window.visualViewport) {\n          throw new Error('window.visualViewport is not supported.');\n        }\n        return [window.visualViewport.pageLeft, window.visualViewport.pageTop];\n      });\n      elementClip.x += pageLeft;\n      elementClip.y += pageTop;\n      if (clip) {\n        elementClip.x += clip.x;\n        elementClip.y += clip.y;\n        elementClip.height = clip.height;\n        elementClip.width = clip.width;\n      }\n      return await page.screenshot({\n        ...options,\n        clip: elementClip\n      });\n    }\n    async #nonEmptyVisibleBoundingBox() {\n      const box = await this.boundingBox();\n      assert(box, 'Node is either not visible or not an HTMLElement');\n      assert(box.width !== 0, 'Node has 0 width.');\n      assert(box.height !== 0, 'Node has 0 height.');\n      return box;\n    }\n    /**\n     * @internal\n     */\n    async assertConnectedElement() {\n      const error = await this.evaluate(async element => {\n        if (!element.isConnected) {\n          return 'Node is detached from document';\n        }\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n          return 'Node is not of type HTMLElement';\n        }\n        return;\n      });\n      if (error) {\n        throw new Error(error);\n      }\n    }\n    /**\n     * @internal\n     */\n    async scrollIntoViewIfNeeded() {\n      if (await this.isIntersectingViewport({\n        threshold: 1\n      })) {\n        return;\n      }\n      await this.scrollIntoView();\n    }\n    /**\n     * Resolves to true if the element is visible in the current viewport. If an\n     * element is an SVG, we check if the svg owner element is in the viewport\n     * instead. See https://crbug.com/963246.\n     *\n     * @param options - Threshold for the intersection between 0 (no intersection) and 1\n     * (full intersection). Defaults to 1.\n     */\n    async isIntersectingViewport(options = {}) {\n      const env_5 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        await this.assertConnectedElement();\n        // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n        const handle = await this.#asSVGElementHandle();\n        const target = __addDisposableResource(env_5, handle && (await handle.#getOwnerSVGElement()), false);\n        return await (target ?? this).evaluate(async (element, threshold) => {\n          const visibleRatio = await new Promise(resolve => {\n            const observer = new IntersectionObserver(entries => {\n              resolve(entries[0].intersectionRatio);\n              observer.disconnect();\n            });\n            observer.observe(element);\n          });\n          return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n        }, options.threshold ?? 0);\n      } catch (e_5) {\n        env_5.error = e_5;\n        env_5.hasError = true;\n      } finally {\n        __disposeResources(env_5);\n      }\n    }\n    /**\n     * Scrolls the element into view using either the automation protocol client\n     * or by calling element.scrollIntoView.\n     */\n    async scrollIntoView() {\n      await this.assertConnectedElement();\n      await this.evaluate(async element => {\n        element.scrollIntoView({\n          block: 'center',\n          inline: 'center',\n          behavior: 'instant'\n        });\n      });\n    }\n    /**\n     * Returns true if an element is an SVGElement (included svg, path, rect\n     * etc.).\n     */\n    async #asSVGElementHandle() {\n      if (await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })) {\n        return this;\n      } else {\n        return null;\n      }\n    }\n    async #getOwnerSVGElement() {\n      // SVGSVGElement.ownerSVGElement === null.\n      return await this.evaluateHandle(element => {\n        if (element instanceof SVGSVGElement) {\n          return element;\n        }\n        return element.ownerSVGElement;\n      });\n    }\n  };\n})();\nexport { ElementHandle };\nfunction intersectBoundingBox(box, width, height) {\n  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);\n  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);\n  box.x = Math.max(box.x, 0);\n  box.y = Math.max(box.y, 0);\n}","map":{"version":3,"names":["getQueryHandlerAndSelector","LazyArg","isString","withSourcePuppeteerURLIfNone","assert","AsyncIterableUtil","throwIfDisposed","_isElementHandle","JSHandle","bindIsolatedHandle","target","_","args","realm","frame","isolatedRealm","call","adoptedThis","adoptHandle","result","transferHandle","Array","isArray","Promise","all","map","item","index","Map","entries","key","value","set","ElementHandle","_classSuper","__esDecorate","_getProperty_decorators","kind","name","static","private","access","has","obj","get","getProperty","metadata","_metadata","_instanceExtraInitializers","_getProperties_decorators","getProperties","_jsonValue_decorators","jsonValue","_$_decorators","$","_$$_decorators","$$","_private_$$_descriptor","__setFunctionName","selector","$$impl","_private_$$_decorators","_waitForSelector_decorators","waitForSelector","_isVisible_decorators","isVisible","_isHidden_decorators","isHidden","_toElement_decorators","toElement","_clickablePoint_decorators","clickablePoint","_hover_decorators","hover","_click_decorators","click","_drag_decorators","drag","_dragEnter_decorators","dragEnter","_dragOver_decorators","dragOver","_drop_decorators","drop","_dragAndDrop_decorators","dragAndDrop","_select_decorators","select","_tap_decorators","tap","_touchStart_decorators","touchStart","_touchMove_decorators","touchMove","_touchEnd_decorators","touchEnd","_focus_decorators","focus","_type_decorators","type","_press_decorators","press","_boundingBox_decorators","boundingBox","_boxModel_decorators","boxModel","_screenshot_decorators","screenshot","_isIntersectingViewport_decorators","isIntersectingViewport","_scrollIntoView_decorators","scrollIntoView","isolatedHandle","__runInitializers","handle","constructor","id","disposed","propertyName","evaluate","pageFunction","evaluateHandle","toString","remoteObject","dispose","asElement","updatedSelector","QueryHandler","queryOne","options","isolate","#$$","#$$impl","collect","queryAll","$eval","elementHandle","__addDisposableResource","env_1","Error","$$eval","results","elements","env_2","polling","waitFor","checkVisibility","#checkVisibility","visibility","element","PuppeteerUtil","Boolean","create","context","puppeteerUtil","tagName","isMatchingTagName","node","nodeName","toUpperCase","offset","box","clickableBox","undefined","x","y","width","height","scrollIntoViewIfNeeded","page","mouse","move","debugHighlight","highlight","document","createElement","innerHTML","addEventListener","remove","once","body","append","isDragInterceptionEnabled","source","_isDragging","down","error","data","items","dragOperationsMask","dataOrElement","destination","up","startPoint","targetPoint","values","vals","Set","HTMLSelectElement","selectedValues","multiple","option","selected","add","dispatchEvent","Event","bubbles","touchscreen","touch","HTMLElement","text","keyboard","#clickableBox","boxes","Element","getClientRects","rect","length","intersectBoundingBoxesWithFrame","parentFrame","env_3","frameElement","parentBox","getBoundingClientRect","style","window","getComputedStyle","left","parseInt","paddingLeft","borderLeftWidth","top","paddingTop","borderTopWidth","find","#intersectBoundingBoxesWithFrame","documentWidth","documentHeight","documentElement","clientWidth","clientHeight","intersectBoundingBox","getTopLeftCornerOfFrame","model","offsets","padding","right","paddingRight","bottom","paddingBottom","margin","marginLeft","marginTop","marginRight","marginBottom","border","borderLeft","borderTop","borderRight","borderBottom","transformQuadWithOffsets","content","quad","attribute","point","#getTopLeftCornerOfFrame","env_4","clip","elementClip","nonEmptyVisibleBoundingBox","pageLeft","pageTop","visualViewport","#nonEmptyVisibleBoundingBox","assertConnectedElement","isConnected","nodeType","Node","ELEMENT_NODE","threshold","asSVGElementHandle","env_5","getOwnerSVGElement","visibleRatio","resolve","observer","IntersectionObserver","intersectionRatio","disconnect","observe","block","inline","behavior","#asSVGElementHandle","SVGElement","#getOwnerSVGElement","SVGSVGElement","ownerSVGElement","Math","max","min"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/api/ElementHandle.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {Frame} from '../api/Frame.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport type {\n  AwaitableIterable,\n  ElementFor,\n  EvaluateFuncWith,\n  HandleFor,\n  HandleOr,\n  NodeFor,\n} from '../common/types.js';\nimport type {KeyInput} from '../common/USKeyboardLayout.js';\nimport {isString, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {throwIfDisposed} from '../util/decorators.js';\n\nimport {_isElementHandle} from './ElementHandleSymbol.js';\nimport type {\n  KeyboardTypeOptions,\n  KeyPressOptions,\n  MouseClickOptions,\n  TouchHandle,\n} from './Input.js';\nimport {JSHandle} from './JSHandle.js';\nimport type {\n  QueryOptions,\n  ScreenshotOptions,\n  WaitForSelectorOptions,\n} from './Page.js';\n\n/**\n * @public\n */\nexport type Quad = [Point, Point, Point, Point];\n\n/**\n * @public\n */\nexport interface BoxModel {\n  content: Quad;\n  padding: Quad;\n  border: Quad;\n  margin: Quad;\n  width: number;\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface BoundingBox extends Point {\n  /**\n   * the width of the element in pixels.\n   */\n  width: number;\n  /**\n   * the height of the element in pixels.\n   */\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface Offset {\n  /**\n   * x-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  x: number;\n  /**\n   * y-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ClickOptions extends MouseClickOptions {\n  /**\n   * Offset for the clickable point relative to the top-left corner of the border box.\n   */\n  offset?: Offset;\n  /**\n   * An experimental debugging feature. If true, inserts an element into the\n   * page to highlight the click location for 10 seconds. Might not work on all\n   * pages and does not persist across navigations.\n   *\n   * @experimental\n   */\n  debugHighlight?: boolean;\n}\n\n/**\n * @public\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ElementScreenshotOptions extends ScreenshotOptions {\n  /**\n   * @defaultValue `true`\n   */\n  scrollIntoView?: boolean;\n}\n\n/**\n * A given method will have it's `this` replaced with an isolated version of\n * `this` when decorated with this decorator.\n *\n * All changes of isolated `this` are reflected on the actual `this`.\n *\n * @internal\n */\nexport function bindIsolatedHandle<This extends ElementHandle<Node>>(\n  target: (this: This, ...args: any[]) => Promise<any>,\n  _: unknown,\n): typeof target {\n  return async function (...args) {\n    // If the handle is already isolated, then we don't need to adopt it\n    // again.\n    if (this.realm === this.frame.isolatedRealm()) {\n      return await target.call(this, ...args);\n    }\n    let adoptedThis: This;\n    if (this['isolatedHandle']) {\n      adoptedThis = this['isolatedHandle'];\n    } else {\n      this['isolatedHandle'] = adoptedThis = await this.frame\n        .isolatedRealm()\n        .adoptHandle(this);\n    }\n    const result = await target.call(adoptedThis, ...args);\n    // If the function returns `adoptedThis`, then we return `this`.\n    if (result === adoptedThis) {\n      return this;\n    }\n    // If the function returns a handle, transfer it into the current realm.\n    if (result instanceof JSHandle) {\n      return await this.realm.transferHandle(result);\n    }\n    // If the function returns an array of handlers, transfer them into the\n    // current realm.\n    if (Array.isArray(result)) {\n      await Promise.all(\n        result.map(async (item, index, result) => {\n          if (item instanceof JSHandle) {\n            result[index] = await this.realm.transferHandle(item);\n          }\n        }),\n      );\n    }\n    if (result instanceof Map) {\n      await Promise.all(\n        [...result.entries()].map(async ([key, value]) => {\n          if (value instanceof JSHandle) {\n            result.set(key, await this.realm.transferHandle(value));\n          }\n        }),\n      );\n    }\n    return result;\n  };\n}\n\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nexport abstract class ElementHandle<\n  ElementType extends Node = Element,\n> extends JSHandle<ElementType> {\n  /**\n   * @internal\n   */\n  declare [_isElementHandle]: boolean;\n\n  /**\n   * @internal\n   * Cached isolatedHandle to prevent\n   * trying to adopt it multiple times\n   */\n  isolatedHandle?: typeof this;\n\n  /**\n   * @internal\n   */\n  protected readonly handle;\n\n  /**\n   * @internal\n   */\n  constructor(handle: JSHandle<ElementType>) {\n    super();\n    this.handle = handle;\n    this[_isElementHandle] = true;\n  }\n\n  /**\n   * @internal\n   */\n  override get id(): string | undefined {\n    return this.handle.id;\n  }\n\n  /**\n   * @internal\n   */\n  override get disposed(): boolean {\n    return this.handle.disposed;\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  override async getProperty<K extends keyof ElementType>(\n    propertyName: HandleOr<K>,\n  ): Promise<HandleFor<ElementType[K]>> {\n    return await this.handle.getProperty(propertyName);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  override async getProperties(): Promise<Map<string, JSHandle>> {\n    return await this.handle.getProperties();\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction,\n    );\n    return await this.handle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction,\n    );\n    return await this.handle.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  override async jsonValue(): Promise<ElementType> {\n    return await this.handle.jsonValue();\n  }\n\n  /**\n   * @internal\n   */\n  override toString(): string {\n    return this.handle.toString();\n  }\n\n  /**\n   * @internal\n   */\n  override remoteObject(): Protocol.Runtime.RemoteObject {\n    return this.handle.remoteObject();\n  }\n\n  /**\n   * @internal\n   */\n  override async dispose(): Promise<void> {\n    await Promise.all([this.handle.dispose(), this.isolatedHandle?.dispose()]);\n  }\n\n  /**\n   * @internal\n   */\n  override asElement(): ElementHandle<ElementType> {\n    return this;\n  }\n\n  /**\n   * Frame corresponding to the current handle.\n   */\n  abstract get frame(): Frame;\n\n  /**\n   * Queries the current element for an element matching the given selector.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows querying by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async $<Selector extends string>(\n    selector: Selector,\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.queryOne(\n      this,\n      updatedSelector,\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * Queries the current element for all elements matching the given selector.\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows querying by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  @throwIfDisposed()\n  async $$<Selector extends string>(\n    selector: Selector,\n    options?: QueryOptions,\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    if (options?.isolate === false) {\n      return await this.#$$impl(selector);\n    }\n    return await this.#$$(selector);\n  }\n\n  /**\n   * Isolates {@link ElementHandle.$$} if needed.\n   *\n   * @internal\n   */\n  @bindIsolatedHandle\n  async #$$<Selector extends string>(\n    selector: Selector,\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    return await this.#$$impl(selector);\n  }\n\n  /**\n   * Implementation for {@link ElementHandle.$$}.\n   *\n   * @internal\n   */\n  async #$$impl<Selector extends string>(\n    selector: Selector,\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return await (AsyncIterableUtil.collect(\n      QueryHandler.queryAll(this, updatedSelector),\n    ) as Promise<Array<ElementHandle<NodeFor<Selector>>>>);\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const tweetHandle = await page.$('.tweet');\n   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n   *   '100',\n   * );\n   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n   *   '10',\n   * );\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows querying by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - The function to be evaluated in this element's page's\n   * context. The first element matching the selector will be passed in as the\n   * first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    using elementHandle = await this.$(selector);\n    if (!elementHandle) {\n      throw new Error(\n        `Error: failed to find element matching selector \"${selector}\"`,\n      );\n    }\n    return await elementHandle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   * HTML:\n   *\n   * ```html\n   * <div class=\"feed\">\n   *   <div class=\"tweet\">Hello!</div>\n   *   <div class=\"tweet\">Hi!</div>\n   * </div>\n   * ```\n   *\n   * JavaScript:\n   *\n   * ```ts\n   * const feedHandle = await page.$('.feed');\n   * expect(\n   *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)),\n   * ).toEqual(['Hello!', 'Hi!']);\n   * ```\n   *\n   * @param selector -\n   * {@link https://pptr.dev/guides/page-interactions#selectors | selector}\n   * to query the page for.\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}\n   * can be passed as-is and a\n   * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}\n   * allows querying by\n   * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},\n   * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}\n   * and\n   * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.\n   * Alternatively, you can specify the selector type using a\n   * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.\n   * @param pageFunction - The function to be evaluated in the element's page's\n   * context. An array of elements matching the given selector will be passed to\n   * the function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const results = await this.$$(selector);\n    using elements = await this.evaluateHandle(\n      (_, ...elements) => {\n        return elements;\n      },\n      ...results,\n    );\n    const [result] = await Promise.all([\n      elements.evaluate(pageFunction, ...args),\n      ...results.map(results => {\n        return results.dispose();\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * Wait for an element matching the given selector to appear in the current\n   * element.\n   *\n   * Unlike {@link Frame.waitForSelector}, this method does not work across\n   * navigations or if the element is detached from DOM.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {},\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler, polling} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(this, updatedSelector, {\n      polling,\n      ...options,\n    })) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  async #checkVisibility(visibility: boolean): Promise<boolean> {\n    return await this.evaluate(\n      async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      },\n      LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }),\n      visibility,\n    );\n  }\n\n  /**\n   * An element is considered to be visible if all of the following is\n   * true:\n   *\n   * - the element has\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n   *\n   * - the element has a non-empty\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n   *\n   * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n   *   is not `hidden` or `collapse`.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async isVisible(): Promise<boolean> {\n    return await this.#checkVisibility(true);\n  }\n\n  /**\n   * An element is considered to be hidden if at least one of the following is true:\n   *\n   * - the element has no\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.\n   *\n   * - the element has an empty\n   *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.\n   *\n   * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}\n   *   is `hidden` or `collapse`.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async isHidden(): Promise<boolean> {\n    return await this.#checkVisibility(false);\n  }\n\n  /**\n   * Converts the current handle to the given element type.\n   *\n   * @example\n   *\n   * ```ts\n   * const element: ElementHandle<Element> = await page.$(\n   *   '.class-name-of-anchor',\n   * );\n   * // DO NOT DISPOSE `element`, this will be always be the same handle.\n   * const anchor: ElementHandle<HTMLAnchorElement> =\n   *   await element.toElement('a');\n   * ```\n   *\n   * @param tagName - The tag name of the desired element type.\n   * @throws An error if the handle does not match. **The handle will not be\n   * automatically disposed.**\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async toElement<\n    K extends keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap,\n  >(tagName: K): Promise<HandleFor<ElementFor<K>>> {\n    const isMatchingTagName = await this.evaluate((node, tagName) => {\n      return node.nodeName === tagName.toUpperCase();\n    }, tagName);\n    if (!isMatchingTagName) {\n      throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n    }\n    return this as unknown as HandleFor<ElementFor<K>>;\n  }\n\n  /**\n   * Resolves the frame associated with the element, if any. Always exists for\n   * HTMLIFrameElements.\n   */\n  abstract contentFrame(this: ElementHandle<HTMLIFrameElement>): Promise<Frame>;\n  abstract contentFrame(): Promise<Frame | null>;\n\n  /**\n   * Returns the middle point within an element unless a specific offset is provided.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async clickablePoint(offset?: Offset): Promise<Point> {\n    const box = await this.#clickableBox();\n    if (!box) {\n      throw new Error('Node is either not clickable or not an Element');\n    }\n    if (offset !== undefined) {\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n      };\n    }\n    return {\n      x: box.x + box.width / 2,\n      y: box.y + box.height / 2,\n    };\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async hover(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().mouse.move(x, y);\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async click(\n    this: ElementHandle<Element>,\n    options: Readonly<ClickOptions> = {},\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint(options.offset);\n    try {\n      await this.frame.page().mouse.click(x, y, options);\n    } finally {\n      if (options.debugHighlight) {\n        await this.frame.page().evaluate(\n          (x, y) => {\n            const highlight = document.createElement('div');\n            highlight.innerHTML = `<style>\n        @scope {\n          :scope {\n              position: fixed;\n              left: ${x}px;\n              top: ${y}px;\n              width: 10px;\n              height: 10px;\n              border-radius: 50%;\n              animation: colorChange 10s 1 normal;\n              animation-fill-mode: forwards;\n          }\n\n          @keyframes colorChange {\n              from {\n                  background-color: red;\n              }\n              to {\n                  background-color: #FADADD00;\n              }\n          }\n        }\n      </style>`;\n            highlight.addEventListener(\n              'animationend',\n              () => {\n                highlight.remove();\n              },\n              {once: true},\n            );\n            document.body.append(highlight);\n          },\n          x,\n          y,\n        );\n      }\n    }\n  }\n\n  /**\n   * Drags an element over the given element or point.\n   *\n   * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n   * returned.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async drag(\n    this: ElementHandle<Element>,\n    target: Point | ElementHandle<Element>,\n  ): Promise<Protocol.Input.DragData | void> {\n    await this.scrollIntoViewIfNeeded();\n    const page = this.frame.page();\n    if (page.isDragInterceptionEnabled()) {\n      const source = await this.clickablePoint();\n      if (target instanceof ElementHandle) {\n        target = await target.clickablePoint();\n      }\n      return await page.mouse.drag(source, target);\n    }\n    try {\n      if (!page._isDragging) {\n        page._isDragging = true;\n        await this.hover();\n        await page.mouse.down();\n      }\n      if (target instanceof ElementHandle) {\n        await target.hover();\n      } else {\n        await page.mouse.move(target.x, target.y);\n      }\n    } catch (error) {\n      page._isDragging = false;\n      throw error;\n    }\n  }\n\n  /**\n   * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async dragEnter(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1},\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragEnter(target, data);\n  }\n\n  /**\n   * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async dragOver(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1},\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragOver(target, data);\n  }\n\n  /**\n   * Drops the given element onto the current one.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    element: ElementHandle<Element>,\n  ): Promise<void>;\n\n  /**\n   * @deprecated No longer supported.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    data?: Protocol.Input.DragData,\n  ): Promise<void>;\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async drop(\n    this: ElementHandle<Element>,\n    dataOrElement: ElementHandle<Element> | Protocol.Input.DragData = {\n      items: [],\n      dragOperationsMask: 1,\n    },\n  ): Promise<void> {\n    const page = this.frame.page();\n    if ('items' in dataOrElement) {\n      await this.scrollIntoViewIfNeeded();\n      const destination = await this.clickablePoint();\n      await page.mouse.drop(destination, dataOrElement);\n    } else {\n      // Note if the rest errors, we still want dragging off because the errors\n      // is most likely something implying the mouse is no longer dragging.\n      await dataOrElement.drag(this);\n      page._isDragging = false;\n      await page.mouse.up();\n    }\n  }\n\n  /**\n   * @deprecated Use `ElementHandle.drop` instead.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async dragAndDrop(\n    this: ElementHandle<Element>,\n    target: ElementHandle<Node>,\n    options?: {delay: number},\n  ): Promise<void> {\n    const page = this.frame.page();\n    assert(\n      page.isDragInterceptionEnabled(),\n      'Drag Interception is not enabled!',\n    );\n    await this.scrollIntoViewIfNeeded();\n    const startPoint = await this.clickablePoint();\n    const targetPoint = await target.clickablePoint();\n    await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * handle.select('blue'); // single selection\n   * handle.select('red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async select(...values: string[]): Promise<string[]> {\n    for (const value of values) {\n      assert(\n        isString(value),\n        'Values must be strings. Found value \"' +\n          value +\n          '\" of type \"' +\n          typeof value +\n          '\"',\n      );\n    }\n\n    return await this.evaluate((element, vals): string[] => {\n      const values = new Set(vals);\n      if (!(element instanceof HTMLSelectElement)) {\n        throw new Error('Element is not a <select> element.');\n      }\n\n      const selectedValues = new Set<string>();\n      if (!element.multiple) {\n        for (const option of element.options) {\n          option.selected = false;\n        }\n        for (const option of element.options) {\n          if (values.has(option.value)) {\n            option.selected = true;\n            selectedValues.add(option.value);\n            break;\n          }\n        }\n      } else {\n        for (const option of element.options) {\n          option.selected = values.has(option.value);\n          if (option.selected) {\n            selectedValues.add(option.value);\n          }\n        }\n      }\n      element.dispatchEvent(new Event('input', {bubbles: true}));\n      element.dispatchEvent(new Event('change', {bubbles: true}));\n      return [...selectedValues.values()];\n    }, values);\n  }\n\n  /**\n   * Sets the value of an\n   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}\n   * to the given file paths.\n   *\n   * @remarks This will not validate whether the file paths exists. Also, if a\n   * path is relative, then it is resolved against the\n   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.\n   * For locals script connecting to remote chrome environments, paths must be\n   * absolute.\n   */\n  abstract uploadFile(\n    this: ElementHandle<HTMLInputElement>,\n    ...paths: string[]\n  ): Promise<void>;\n\n  /**\n   * @internal\n   */\n  abstract queryAXTree(\n    name?: string,\n    role?: string,\n  ): AwaitableIterable<ElementHandle<Node>>;\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Touchscreen.tap} to tap in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async tap(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.tap(x, y);\n  }\n\n  /**\n   * This method scrolls the element into view if needed, and then\n   * starts a touch in the center of the element.\n   * @returns A {@link TouchHandle} representing the touch that was started\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async touchStart(this: ElementHandle<Element>): Promise<TouchHandle> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    return await this.frame.page().touchscreen.touchStart(x, y);\n  }\n\n  /**\n   * This method scrolls the element into view if needed, and then\n   * moves the touch to the center of the element.\n   * @param touch - An optional {@link TouchHandle}. If provided, this touch\n   * will be moved. If not provided, the first active touch will be moved.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async touchMove(\n    this: ElementHandle<Element>,\n    touch?: TouchHandle,\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    if (touch) {\n      return await touch.move(x, y);\n    }\n    await this.frame.page().touchscreen.touchMove(x, y);\n  }\n\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async touchEnd(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    await this.frame.page().touchscreen.touchEnd();\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async focus(): Promise<void> {\n    await this.evaluate(element => {\n      if (!(element instanceof HTMLElement)) {\n        throw new Error('Cannot focus non-HTMLElement');\n      }\n      return element.focus();\n    });\n  }\n\n  /**\n   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n   * `keyup` event for each character in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`,\n   * use {@link ElementHandle.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await elementHandle.type('Hello'); // Types instantly\n   * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @example\n   * An example of typing into a text field and then submitting the form:\n   *\n   * ```ts\n   * const elementHandle = await page.$('input');\n   * await elementHandle.type('some text');\n   * await elementHandle.press('Enter');\n   * ```\n   *\n   * @param options - Delay in milliseconds. Defaults to 0.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async type(\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>,\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.type(text, options);\n  }\n\n  /**\n   * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n   *\n   * @remarks\n   * If `key` is a single character and no modifier keys besides `Shift`\n   * are being held down, a `keypress`/`input` event will also be generated.\n   * The `text` option can be specified to force an input event to be generated.\n   *\n   * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n   * will type the text in upper case.\n   *\n   * @param key - Name of key to press, such as `ArrowLeft`.\n   * See {@link KeyInput} for a list of all key names.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async press(\n    key: KeyInput,\n    options?: Readonly<KeyPressOptions>,\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.press(key, options);\n  }\n\n  async #clickableBox(): Promise<BoundingBox | null> {\n    const boxes = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      return [...element.getClientRects()].map(rect => {\n        return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n      });\n    });\n    if (!boxes?.length) {\n      return null;\n    }\n    await this.#intersectBoundingBoxesWithFrame(boxes);\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      for (const box of boxes) {\n        box.x += parentBox.left;\n        box.y += parentBox.top;\n      }\n      await handle.#intersectBoundingBoxesWithFrame(boxes);\n      frame = parentFrame;\n    }\n    const box = boxes.find(box => {\n      return box.width >= 1 && box.height >= 1;\n    });\n    if (!box) {\n      return null;\n    }\n    return {\n      x: box.x,\n      y: box.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  async #intersectBoundingBoxesWithFrame(boxes: BoundingBox[]) {\n    const {documentWidth, documentHeight} = await this.frame\n      .isolatedRealm()\n      .evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight,\n        };\n      });\n    for (const box of boxes) {\n      intersectBoundingBox(box, documentWidth, documentHeight);\n    }\n  }\n\n  /**\n   * This method returns the bounding box of the element (relative to the main frame),\n   * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n   * (example: `display: none`).\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async boundingBox(): Promise<BoundingBox | null> {\n    const box = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n    });\n    if (!box) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    return {\n      x: box.x + offset.x,\n      y: box.y + offset.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  /**\n   * This method returns boxes of the element,\n   * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}\n   * (example: `display: none`).\n   *\n   * @remarks\n   *\n   * Boxes are represented as an array of points;\n   * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async boxModel(): Promise<BoxModel | null> {\n    const model = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      const style = window.getComputedStyle(element);\n      const offsets = {\n        padding: {\n          left: parseInt(style.paddingLeft, 10),\n          top: parseInt(style.paddingTop, 10),\n          right: parseInt(style.paddingRight, 10),\n          bottom: parseInt(style.paddingBottom, 10),\n        },\n        margin: {\n          left: -parseInt(style.marginLeft, 10),\n          top: -parseInt(style.marginTop, 10),\n          right: -parseInt(style.marginRight, 10),\n          bottom: -parseInt(style.marginBottom, 10),\n        },\n        border: {\n          left: parseInt(style.borderLeft, 10),\n          top: parseInt(style.borderTop, 10),\n          right: parseInt(style.borderRight, 10),\n          bottom: parseInt(style.borderBottom, 10),\n        },\n      };\n      const border: Quad = [\n        {x: rect.left, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top + rect.height},\n        {x: rect.left, y: rect.top + rect.height},\n      ];\n      const padding = transformQuadWithOffsets(border, offsets.border);\n      const content = transformQuadWithOffsets(padding, offsets.padding);\n      const margin = transformQuadWithOffsets(border, offsets.margin);\n      return {\n        content,\n        padding,\n        border,\n        margin,\n        width: rect.width,\n        height: rect.height,\n      };\n\n      function transformQuadWithOffsets(\n        quad: Quad,\n        offsets: {top: number; left: number; right: number; bottom: number},\n      ): Quad {\n        return [\n          {\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top,\n          },\n          {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top,\n          },\n          {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom,\n          },\n          {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom,\n          },\n        ];\n      }\n    });\n    if (!model) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    for (const attribute of [\n      'content',\n      'padding',\n      'border',\n      'margin',\n    ] as const) {\n      for (const point of model[attribute]) {\n        point.x += offset.x;\n        point.y += offset.y;\n      }\n    }\n    return model;\n  }\n\n  async #getTopLeftCornerOfFrame() {\n    const point = {x: 0, y: 0};\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      point.x += parentBox.left;\n      point.y += parentBox.top;\n      frame = parentFrame;\n    }\n    return point;\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Page.(screenshot:2) } to take a screenshot of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'},\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Uint8Array>;\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async screenshot(\n    this: ElementHandle<Element>,\n    options: Readonly<ElementScreenshotOptions> = {},\n  ): Promise<string | Uint8Array> {\n    const {scrollIntoView = true, clip} = options;\n\n    const page = this.frame.page();\n\n    // Only scroll the element into view if the user wants it.\n    if (scrollIntoView) {\n      await this.scrollIntoViewIfNeeded();\n    }\n    const elementClip = await this.#nonEmptyVisibleBoundingBox();\n\n    const [pageLeft, pageTop] = await this.evaluate(() => {\n      if (!window.visualViewport) {\n        throw new Error('window.visualViewport is not supported.');\n      }\n      return [\n        window.visualViewport.pageLeft,\n        window.visualViewport.pageTop,\n      ] as const;\n    });\n    elementClip.x += pageLeft;\n    elementClip.y += pageTop;\n    if (clip) {\n      elementClip.x += clip.x;\n      elementClip.y += clip.y;\n      elementClip.height = clip.height;\n      elementClip.width = clip.width;\n    }\n\n    return await page.screenshot({...options, clip: elementClip});\n  }\n\n  async #nonEmptyVisibleBoundingBox() {\n    const box = await this.boundingBox();\n    assert(box, 'Node is either not visible or not an HTMLElement');\n    assert(box.width !== 0, 'Node has 0 width.');\n    assert(box.height !== 0, 'Node has 0 height.');\n    return box;\n  }\n\n  /**\n   * @internal\n   */\n  protected async assertConnectedElement(): Promise<void> {\n    const error = await this.evaluate(async element => {\n      if (!element.isConnected) {\n        return 'Node is detached from document';\n      }\n      if (element.nodeType !== Node.ELEMENT_NODE) {\n        return 'Node is not of type HTMLElement';\n      }\n      return;\n    });\n\n    if (error) {\n      throw new Error(error);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected async scrollIntoViewIfNeeded(\n    this: ElementHandle<Element>,\n  ): Promise<void> {\n    if (\n      await this.isIntersectingViewport({\n        threshold: 1,\n      })\n    ) {\n      return;\n    }\n    await this.scrollIntoView();\n  }\n\n  /**\n   * Resolves to true if the element is visible in the current viewport. If an\n   * element is an SVG, we check if the svg owner element is in the viewport\n   * instead. See https://crbug.com/963246.\n   *\n   * @param options - Threshold for the intersection between 0 (no intersection) and 1\n   * (full intersection). Defaults to 1.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async isIntersectingViewport(\n    this: ElementHandle<Element>,\n    options: {\n      threshold?: number;\n    } = {},\n  ): Promise<boolean> {\n    await this.assertConnectedElement();\n    // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n    const handle = await this.#asSVGElementHandle();\n    using target = handle && (await handle.#getOwnerSVGElement());\n    return await ((target ?? this) as ElementHandle<Element>).evaluate(\n      async (element, threshold) => {\n        const visibleRatio = await new Promise<number>(resolve => {\n          const observer = new IntersectionObserver(entries => {\n            resolve(entries[0]!.intersectionRatio);\n            observer.disconnect();\n          });\n          observer.observe(element);\n        });\n        return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n      },\n      options.threshold ?? 0,\n    );\n  }\n\n  /**\n   * Scrolls the element into view using either the automation protocol client\n   * or by calling element.scrollIntoView.\n   */\n  @throwIfDisposed()\n  @bindIsolatedHandle\n  async scrollIntoView(this: ElementHandle<Element>): Promise<void> {\n    await this.assertConnectedElement();\n    await this.evaluate(async (element): Promise<void> => {\n      element.scrollIntoView({\n        block: 'center',\n        inline: 'center',\n        behavior: 'instant',\n      });\n    });\n  }\n\n  /**\n   * Returns true if an element is an SVGElement (included svg, path, rect\n   * etc.).\n   */\n  async #asSVGElementHandle(\n    this: ElementHandle<Element>,\n  ): Promise<ElementHandle<SVGElement> | null> {\n    if (\n      await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })\n    ) {\n      return this as ElementHandle<SVGElement>;\n    } else {\n      return null;\n    }\n  }\n\n  async #getOwnerSVGElement(\n    this: ElementHandle<SVGElement>,\n  ): Promise<ElementHandle<SVGSVGElement>> {\n    // SVGSVGElement.ownerSVGElement === null.\n    return await this.evaluateHandle(element => {\n      if (element instanceof SVGSVGElement) {\n        return element;\n      }\n      return element.ownerSVGElement!;\n    });\n  }\n\n  /**\n   * If the element is a form input, you can use {@link ElementHandle.autofill}\n   * to test if the form is compatible with the browser's autofill\n   * implementation. Throws an error if the form cannot be autofilled.\n   *\n   * @remarks\n   *\n   * Currently, Puppeteer supports auto-filling credit card information only and\n   * in Chrome in the new headless and headful modes only.\n   *\n   * ```ts\n   * // Select an input on the credit card form.\n   * const name = await page.waitForSelector('form #name');\n   * // Trigger autofill with the desired data.\n   * await name.autofill({\n   *   creditCard: {\n   *     number: '4444444444444444',\n   *     name: 'John Smith',\n   *     expiryMonth: '01',\n   *     expiryYear: '2030',\n   *     cvc: '123',\n   *   },\n   * });\n   * ```\n   */\n  abstract autofill(data: AutofillData): Promise<void>;\n\n  /**\n   * When connected using Chrome DevTools Protocol, it returns a\n   * DOM.BackendNodeId for the element.\n   */\n  abstract backendNodeId(): Promise<number>;\n}\n\n/**\n * @public\n */\nexport interface AutofillData {\n  /**\n   * See {@link https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#type-CreditCard | Autofill.CreditCard}.\n   */\n  creditCard: {\n    number: string;\n    name: string;\n    expiryMonth: string;\n    expiryYear: string;\n    cvc: string;\n  };\n}\n\nfunction intersectBoundingBox(\n  box: BoundingBox,\n  width: number,\n  height: number,\n): void {\n  box.width = Math.max(\n    box.x >= 0\n      ? Math.min(width - box.x, box.width)\n      : Math.min(width, box.width + box.x),\n    0,\n  );\n  box.height = Math.max(\n    box.y >= 0\n      ? Math.min(height - box.y, box.height)\n      : Math.min(height, box.height + box.y),\n    0,\n  );\n  box.x = Math.max(box.x, 0);\n  box.y = Math.max(box.y, 0);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}