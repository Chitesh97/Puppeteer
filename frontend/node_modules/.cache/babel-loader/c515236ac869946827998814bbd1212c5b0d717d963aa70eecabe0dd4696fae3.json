{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function () {\n      try {\n        inner.call(this);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    var r,\n      s = 0;\n    function next() {\n      while (r = env.stack.pop()) {\n        try {\n          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n          if (r.dispose) {\n            var result = r.dispose.call(r.value);\n            if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {\n              fail(e);\n              return next();\n            });\n          } else s |= 1;\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\n/**\n * The Accessibility class provides methods for inspecting the browser's\n * accessibility tree. The accessibility tree is used by assistive technology\n * such as {@link https://en.wikipedia.org/wiki/Screen_reader | screen readers} or\n * {@link https://en.wikipedia.org/wiki/Switch_access | switches}.\n *\n * @remarks\n *\n * Accessibility is a very platform-specific thing. On different platforms,\n * there are different screen readers that might have wildly different output.\n *\n * Blink - Chrome's rendering engine - has a concept of \"accessibility tree\",\n * which is then translated into different platform-specific APIs. Accessibility\n * namespace gives users access to the Blink Accessibility Tree.\n *\n * Most of the accessibility tree gets filtered out when converting from Blink\n * AX Tree to Platform-specific AX-Tree or by assistive technologies themselves.\n * By default, Puppeteer tries to approximate this filtering, exposing only\n * the \"interesting\" nodes of the tree.\n *\n * @public\n */\nexport class Accessibility {\n  #realm;\n  #frameId;\n  /**\n   * @internal\n   */\n  constructor(realm, frameId = '') {\n    this.#realm = realm;\n    this.#frameId = frameId;\n  }\n  /**\n   * Captures the current state of the accessibility tree.\n   * The returned object represents the root accessible node of the page.\n   *\n   * @remarks\n   *\n   * **NOTE** The Chrome accessibility tree contains nodes that go unused on\n   * most platforms and by most screen readers. Puppeteer will discard them as\n   * well for an easier to process tree, unless `interestingOnly` is set to\n   * `false`.\n   *\n   * @example\n   * An example of dumping the entire accessibility tree:\n   *\n   * ```ts\n   * const snapshot = await page.accessibility.snapshot();\n   * console.log(snapshot);\n   * ```\n   *\n   * @example\n   * An example of logging the focused node's name:\n   *\n   * ```ts\n   * const snapshot = await page.accessibility.snapshot();\n   * const node = findFocusedNode(snapshot);\n   * console.log(node && node.name);\n   *\n   * function findFocusedNode(node) {\n   *   if (node.focused) return node;\n   *   for (const child of node.children || []) {\n   *     const foundNode = findFocusedNode(child);\n   *     return foundNode;\n   *   }\n   *   return null;\n   * }\n   * ```\n   *\n   * @returns An AXNode object representing the snapshot.\n   */\n  async snapshot(options = {}) {\n    const {\n      interestingOnly = true,\n      root = null,\n      includeIframes = false\n    } = options;\n    const {\n      nodes\n    } = await this.#realm.environment.client.send('Accessibility.getFullAXTree', {\n      frameId: this.#frameId\n    });\n    let backendNodeId;\n    if (root) {\n      const {\n        node\n      } = await this.#realm.environment.client.send('DOM.describeNode', {\n        objectId: root.id\n      });\n      backendNodeId = node.backendNodeId;\n    }\n    const defaultRoot = AXNode.createTree(this.#realm, nodes);\n    const populateIframes = async root => {\n      if (root.payload.role?.value === 'Iframe') {\n        const env_1 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          if (!root.payload.backendDOMNodeId) {\n            return;\n          }\n          const handle = __addDisposableResource(env_1, await this.#realm.adoptBackendNode(root.payload.backendDOMNodeId), false);\n          if (!handle || !('contentFrame' in handle)) {\n            return;\n          }\n          const frame = await handle.contentFrame();\n          if (!frame) {\n            return;\n          }\n          const iframeSnapshot = await frame.accessibility.snapshot(options);\n          root.iframeSnapshot = iframeSnapshot ?? undefined;\n        } catch (e_1) {\n          env_1.error = e_1;\n          env_1.hasError = true;\n        } finally {\n          __disposeResources(env_1);\n        }\n      }\n      for (const child of root.children) {\n        await populateIframes(child);\n      }\n    };\n    let needle = defaultRoot;\n    if (!defaultRoot) {\n      return null;\n    }\n    if (includeIframes) {\n      await populateIframes(defaultRoot);\n    }\n    if (backendNodeId) {\n      needle = defaultRoot.find(node => {\n        return node.payload.backendDOMNodeId === backendNodeId;\n      });\n    }\n    if (!needle) {\n      return null;\n    }\n    if (!interestingOnly) {\n      return this.serializeTree(needle)[0] ?? null;\n    }\n    const interestingNodes = new Set();\n    this.collectInterestingNodes(interestingNodes, defaultRoot, false);\n    if (!interestingNodes.has(needle)) {\n      return null;\n    }\n    return this.serializeTree(needle, interestingNodes)[0] ?? null;\n  }\n  serializeTree(node, interestingNodes) {\n    const children = [];\n    for (const child of node.children) {\n      children.push(...this.serializeTree(child, interestingNodes));\n    }\n    if (interestingNodes && !interestingNodes.has(node)) {\n      return children;\n    }\n    const serializedNode = node.serialize();\n    if (children.length) {\n      serializedNode.children = children;\n    }\n    if (node.iframeSnapshot) {\n      if (!serializedNode.children) {\n        serializedNode.children = [];\n      }\n      serializedNode.children.push(node.iframeSnapshot);\n    }\n    return [serializedNode];\n  }\n  collectInterestingNodes(collection, node, insideControl) {\n    if (node.isInteresting(insideControl) || node.iframeSnapshot) {\n      collection.add(node);\n    }\n    if (node.isLeafNode()) {\n      return;\n    }\n    insideControl = insideControl || node.isControl();\n    for (const child of node.children) {\n      this.collectInterestingNodes(collection, child, insideControl);\n    }\n  }\n}\nclass AXNode {\n  payload;\n  children = [];\n  iframeSnapshot;\n  #richlyEditable = false;\n  #editable = false;\n  #focusable = false;\n  #hidden = false;\n  #name;\n  #role;\n  #ignored;\n  #cachedHasFocusableChild;\n  #realm;\n  constructor(realm, payload) {\n    this.payload = payload;\n    this.#name = this.payload.name ? this.payload.name.value : '';\n    this.#role = this.payload.role ? this.payload.role.value : 'Unknown';\n    this.#ignored = this.payload.ignored;\n    this.#realm = realm;\n    for (const property of this.payload.properties || []) {\n      if (property.name === 'editable') {\n        this.#richlyEditable = property.value.value === 'richtext';\n        this.#editable = true;\n      }\n      if (property.name === 'focusable') {\n        this.#focusable = property.value.value;\n      }\n      if (property.name === 'hidden') {\n        this.#hidden = property.value.value;\n      }\n    }\n  }\n  #isPlainTextField() {\n    if (this.#richlyEditable) {\n      return false;\n    }\n    if (this.#editable) {\n      return true;\n    }\n    return this.#role === 'textbox' || this.#role === 'searchbox';\n  }\n  #isTextOnlyObject() {\n    const role = this.#role;\n    return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox' || role === 'StaticText';\n  }\n  #hasFocusableChild() {\n    if (this.#cachedHasFocusableChild === undefined) {\n      this.#cachedHasFocusableChild = false;\n      for (const child of this.children) {\n        if (child.#focusable || child.#hasFocusableChild()) {\n          this.#cachedHasFocusableChild = true;\n          break;\n        }\n      }\n    }\n    return this.#cachedHasFocusableChild;\n  }\n  find(predicate) {\n    if (predicate(this)) {\n      return this;\n    }\n    for (const child of this.children) {\n      const result = child.find(predicate);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n  isLeafNode() {\n    if (!this.children.length) {\n      return true;\n    }\n    // These types of objects may have children that we use as internal\n    // implementation details, but we want to expose them as leaves to platform\n    // accessibility APIs because screen readers might be confused if they find\n    // any children.\n    if (this.#isPlainTextField() || this.#isTextOnlyObject()) {\n      return true;\n    }\n    // Roles whose children are only presentational according to the ARIA and\n    // HTML5 Specs should be hidden from screen readers.\n    // (Note that whilst ARIA buttons can have only presentational children, HTML5\n    // buttons are allowed to have content.)\n    switch (this.#role) {\n      case 'doc-cover':\n      case 'graphics-symbol':\n      case 'img':\n      case 'image':\n      case 'Meter':\n      case 'scrollbar':\n      case 'slider':\n      case 'separator':\n      case 'progressbar':\n        return true;\n      default:\n        break;\n    }\n    // Here and below: Android heuristics\n    if (this.#hasFocusableChild()) {\n      return false;\n    }\n    if (this.#focusable && this.#name) {\n      return true;\n    }\n    if (this.#role === 'heading' && this.#name) {\n      return true;\n    }\n    return false;\n  }\n  isControl() {\n    switch (this.#role) {\n      case 'button':\n      case 'checkbox':\n      case 'ColorWell':\n      case 'combobox':\n      case 'DisclosureTriangle':\n      case 'listbox':\n      case 'menu':\n      case 'menubar':\n      case 'menuitem':\n      case 'menuitemcheckbox':\n      case 'menuitemradio':\n      case 'radio':\n      case 'scrollbar':\n      case 'searchbox':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'tab':\n      case 'textbox':\n      case 'tree':\n      case 'treeitem':\n        return true;\n      default:\n        return false;\n    }\n  }\n  isInteresting(insideControl) {\n    const role = this.#role;\n    if (role === 'Ignored' || this.#hidden || this.#ignored) {\n      return false;\n    }\n    if (this.#focusable || this.#richlyEditable) {\n      return true;\n    }\n    // If it's not focusable but has a control role, then it's interesting.\n    if (this.isControl()) {\n      return true;\n    }\n    // A non focusable child of a control is not interesting\n    if (insideControl) {\n      return false;\n    }\n    return this.isLeafNode() && !!this.#name;\n  }\n  serialize() {\n    const properties = new Map();\n    for (const property of this.payload.properties || []) {\n      properties.set(property.name.toLowerCase(), property.value.value);\n    }\n    if (this.payload.name) {\n      properties.set('name', this.payload.name.value);\n    }\n    if (this.payload.value) {\n      properties.set('value', this.payload.value.value);\n    }\n    if (this.payload.description) {\n      properties.set('description', this.payload.description.value);\n    }\n    const node = {\n      role: this.#role,\n      elementHandle: async () => {\n        if (!this.payload.backendDOMNodeId) {\n          return null;\n        }\n        return await this.#realm.adoptBackendNode(this.payload.backendDOMNodeId);\n      }\n    };\n    const userStringProperties = ['name', 'value', 'description', 'keyshortcuts', 'roledescription', 'valuetext'];\n    const getUserStringPropertyValue = key => {\n      return properties.get(key);\n    };\n    for (const userStringProperty of userStringProperties) {\n      if (!properties.has(userStringProperty)) {\n        continue;\n      }\n      node[userStringProperty] = getUserStringPropertyValue(userStringProperty);\n    }\n    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];\n    const getBooleanPropertyValue = key => {\n      return properties.get(key);\n    };\n    for (const booleanProperty of booleanProperties) {\n      // RootWebArea's treat focus differently than other nodes. They report whether\n      // their frame  has focus, not whether focus is specifically on the root\n      // node.\n      if (booleanProperty === 'focused' && this.#role === 'RootWebArea') {\n        continue;\n      }\n      const value = getBooleanPropertyValue(booleanProperty);\n      if (!value) {\n        continue;\n      }\n      node[booleanProperty] = getBooleanPropertyValue(booleanProperty);\n    }\n    const tristateProperties = ['checked', 'pressed'];\n    for (const tristateProperty of tristateProperties) {\n      if (!properties.has(tristateProperty)) {\n        continue;\n      }\n      const value = properties.get(tristateProperty);\n      node[tristateProperty] = value === 'mixed' ? 'mixed' : value === 'true' ? true : false;\n    }\n    const numericalProperties = ['level', 'valuemax', 'valuemin'];\n    const getNumericalPropertyValue = key => {\n      return properties.get(key);\n    };\n    for (const numericalProperty of numericalProperties) {\n      if (!properties.has(numericalProperty)) {\n        continue;\n      }\n      node[numericalProperty] = getNumericalPropertyValue(numericalProperty);\n    }\n    const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];\n    const getTokenPropertyValue = key => {\n      return properties.get(key);\n    };\n    for (const tokenProperty of tokenProperties) {\n      const value = getTokenPropertyValue(tokenProperty);\n      if (!value || value === 'false') {\n        continue;\n      }\n      node[tokenProperty] = getTokenPropertyValue(tokenProperty);\n    }\n    return node;\n  }\n  static createTree(realm, payloads) {\n    const nodeById = new Map();\n    for (const payload of payloads) {\n      nodeById.set(payload.nodeId, new AXNode(realm, payload));\n    }\n    for (const node of nodeById.values()) {\n      for (const childId of node.payload.childIds || []) {\n        const child = nodeById.get(childId);\n        if (child) {\n          node.children.push(child);\n        }\n      }\n    }\n    return nodeById.values().next().value ?? null;\n  }\n}","map":{"version":3,"names":["Accessibility","realm","frameId","constructor","snapshot","options","interestingOnly","root","includeIframes","nodes","environment","client","send","backendNodeId","node","objectId","id","defaultRoot","AXNode","createTree","populateIframes","payload","role","value","backendDOMNodeId","handle","__addDisposableResource","env_1","adoptBackendNode","frame","contentFrame","iframeSnapshot","accessibility","undefined","child","children","needle","find","serializeTree","interestingNodes","Set","collectInterestingNodes","has","push","serializedNode","serialize","length","collection","insideControl","isInteresting","add","isLeafNode","isControl","richlyEditable","editable","focusable","hidden","name","ignored","cachedHasFocusableChild","property","properties","isPlainTextField","#isPlainTextField","isTextOnlyObject","#isTextOnlyObject","hasFocusableChild","#hasFocusableChild","predicate","result","Map","set","toLowerCase","description","elementHandle","userStringProperties","getUserStringPropertyValue","key","get","userStringProperty","booleanProperties","getBooleanPropertyValue","booleanProperty","tristateProperties","tristateProperty","numericalProperties","getNumericalPropertyValue","numericalProperty","tokenProperties","getTokenPropertyValue","tokenProperty","payloads","nodeById","nodeId","values","childId","childIds","next"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/Accessibility.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {Realm} from '../api/Realm.js';\n\n/**\n * Represents a Node and the properties of it that are relevant to Accessibility.\n * @public\n */\nexport interface SerializedAXNode {\n  /**\n   * The {@link https://www.w3.org/TR/wai-aria/#usage_intro | role} of the node.\n   */\n  role: string;\n  /**\n   * A human readable name for the node.\n   */\n  name?: string;\n  /**\n   * The current value of the node.\n   */\n  value?: string | number;\n  /**\n   * An additional human readable description of the node.\n   */\n  description?: string;\n  /**\n   * Any keyboard shortcuts associated with this node.\n   */\n  keyshortcuts?: string;\n  /**\n   * A human readable alternative to the role.\n   */\n  roledescription?: string;\n  /**\n   * A description of the current value.\n   */\n  valuetext?: string;\n  disabled?: boolean;\n  expanded?: boolean;\n  focused?: boolean;\n  modal?: boolean;\n  multiline?: boolean;\n  /**\n   * Whether more than one child can be selected.\n   */\n  multiselectable?: boolean;\n  readonly?: boolean;\n  required?: boolean;\n  selected?: boolean;\n  /**\n   * Whether the checkbox is checked, or in a\n   * {@link https://www.w3.org/TR/wai-aria-practices/examples/checkbox/checkbox-2/checkbox-2.html | mixed state}.\n   */\n  checked?: boolean | 'mixed';\n  /**\n   * Whether the node is checked or in a mixed state.\n   */\n  pressed?: boolean | 'mixed';\n  /**\n   * The level of a heading.\n   */\n  level?: number;\n  valuemin?: number;\n  valuemax?: number;\n  autocomplete?: string;\n  haspopup?: string;\n  /**\n   * Whether and in what way this node's value is invalid.\n   */\n  invalid?: string;\n  orientation?: string;\n  /**\n   * Children of this node, if there are any.\n   */\n  children?: SerializedAXNode[];\n\n  /**\n   * Get an ElementHandle for this AXNode if available.\n   *\n   * If the underlying DOM element has been disposed, the method might return an\n   * error.\n   */\n  elementHandle(): Promise<ElementHandle | null>;\n}\n\n/**\n * @public\n */\nexport interface SnapshotOptions {\n  /**\n   * Prune uninteresting nodes from the tree.\n   * @defaultValue `true`\n   */\n  interestingOnly?: boolean;\n  /**\n   * If true, gets accessibility trees for each of the iframes in the frame\n   * subtree.\n   *\n   * @defaultValue `false`\n   */\n  includeIframes?: boolean;\n  /**\n   * Root node to get the accessibility tree for\n   * @defaultValue The root node of the entire page.\n   */\n  root?: ElementHandle<Node>;\n}\n\n/**\n * The Accessibility class provides methods for inspecting the browser's\n * accessibility tree. The accessibility tree is used by assistive technology\n * such as {@link https://en.wikipedia.org/wiki/Screen_reader | screen readers} or\n * {@link https://en.wikipedia.org/wiki/Switch_access | switches}.\n *\n * @remarks\n *\n * Accessibility is a very platform-specific thing. On different platforms,\n * there are different screen readers that might have wildly different output.\n *\n * Blink - Chrome's rendering engine - has a concept of \"accessibility tree\",\n * which is then translated into different platform-specific APIs. Accessibility\n * namespace gives users access to the Blink Accessibility Tree.\n *\n * Most of the accessibility tree gets filtered out when converting from Blink\n * AX Tree to Platform-specific AX-Tree or by assistive technologies themselves.\n * By default, Puppeteer tries to approximate this filtering, exposing only\n * the \"interesting\" nodes of the tree.\n *\n * @public\n */\nexport class Accessibility {\n  #realm: Realm;\n  #frameId: string;\n\n  /**\n   * @internal\n   */\n  constructor(realm: Realm, frameId = '') {\n    this.#realm = realm;\n    this.#frameId = frameId;\n  }\n\n  /**\n   * Captures the current state of the accessibility tree.\n   * The returned object represents the root accessible node of the page.\n   *\n   * @remarks\n   *\n   * **NOTE** The Chrome accessibility tree contains nodes that go unused on\n   * most platforms and by most screen readers. Puppeteer will discard them as\n   * well for an easier to process tree, unless `interestingOnly` is set to\n   * `false`.\n   *\n   * @example\n   * An example of dumping the entire accessibility tree:\n   *\n   * ```ts\n   * const snapshot = await page.accessibility.snapshot();\n   * console.log(snapshot);\n   * ```\n   *\n   * @example\n   * An example of logging the focused node's name:\n   *\n   * ```ts\n   * const snapshot = await page.accessibility.snapshot();\n   * const node = findFocusedNode(snapshot);\n   * console.log(node && node.name);\n   *\n   * function findFocusedNode(node) {\n   *   if (node.focused) return node;\n   *   for (const child of node.children || []) {\n   *     const foundNode = findFocusedNode(child);\n   *     return foundNode;\n   *   }\n   *   return null;\n   * }\n   * ```\n   *\n   * @returns An AXNode object representing the snapshot.\n   */\n  public async snapshot(\n    options: SnapshotOptions = {},\n  ): Promise<SerializedAXNode | null> {\n    const {\n      interestingOnly = true,\n      root = null,\n      includeIframes = false,\n    } = options;\n    const {nodes} = await this.#realm.environment.client.send(\n      'Accessibility.getFullAXTree',\n      {\n        frameId: this.#frameId,\n      },\n    );\n    let backendNodeId: number | undefined;\n    if (root) {\n      const {node} = await this.#realm.environment.client.send(\n        'DOM.describeNode',\n        {\n          objectId: root.id,\n        },\n      );\n      backendNodeId = node.backendNodeId;\n    }\n    const defaultRoot = AXNode.createTree(this.#realm, nodes);\n    const populateIframes = async (root: AXNode): Promise<void> => {\n      if (root.payload.role?.value === 'Iframe') {\n        if (!root.payload.backendDOMNodeId) {\n          return;\n        }\n        using handle = (await this.#realm.adoptBackendNode(\n          root.payload.backendDOMNodeId,\n        )) as ElementHandle<Element>;\n        if (!handle || !('contentFrame' in handle)) {\n          return;\n        }\n        const frame = await handle.contentFrame();\n        if (!frame) {\n          return;\n        }\n        const iframeSnapshot = await frame.accessibility.snapshot(options);\n        root.iframeSnapshot = iframeSnapshot ?? undefined;\n      }\n      for (const child of root.children) {\n        await populateIframes(child);\n      }\n    };\n\n    let needle: AXNode | null = defaultRoot;\n    if (!defaultRoot) {\n      return null;\n    }\n\n    if (includeIframes) {\n      await populateIframes(defaultRoot);\n    }\n\n    if (backendNodeId) {\n      needle = defaultRoot.find(node => {\n        return node.payload.backendDOMNodeId === backendNodeId;\n      });\n    }\n\n    if (!needle) {\n      return null;\n    }\n\n    if (!interestingOnly) {\n      return this.serializeTree(needle)[0] ?? null;\n    }\n\n    const interestingNodes = new Set<AXNode>();\n    this.collectInterestingNodes(interestingNodes, defaultRoot, false);\n    if (!interestingNodes.has(needle)) {\n      return null;\n    }\n    return this.serializeTree(needle, interestingNodes)[0] ?? null;\n  }\n\n  private serializeTree(\n    node: AXNode,\n    interestingNodes?: Set<AXNode>,\n  ): SerializedAXNode[] {\n    const children: SerializedAXNode[] = [];\n    for (const child of node.children) {\n      children.push(...this.serializeTree(child, interestingNodes));\n    }\n\n    if (interestingNodes && !interestingNodes.has(node)) {\n      return children;\n    }\n\n    const serializedNode = node.serialize();\n    if (children.length) {\n      serializedNode.children = children;\n    }\n    if (node.iframeSnapshot) {\n      if (!serializedNode.children) {\n        serializedNode.children = [];\n      }\n      serializedNode.children.push(node.iframeSnapshot);\n    }\n    return [serializedNode];\n  }\n\n  private collectInterestingNodes(\n    collection: Set<AXNode>,\n    node: AXNode,\n    insideControl: boolean,\n  ): void {\n    if (node.isInteresting(insideControl) || node.iframeSnapshot) {\n      collection.add(node);\n    }\n    if (node.isLeafNode()) {\n      return;\n    }\n    insideControl = insideControl || node.isControl();\n    for (const child of node.children) {\n      this.collectInterestingNodes(collection, child, insideControl);\n    }\n  }\n}\n\nclass AXNode {\n  public payload: Protocol.Accessibility.AXNode;\n  public children: AXNode[] = [];\n  public iframeSnapshot?: SerializedAXNode;\n\n  #richlyEditable = false;\n  #editable = false;\n  #focusable = false;\n  #hidden = false;\n  #name: string;\n  #role: string;\n  #ignored: boolean;\n  #cachedHasFocusableChild?: boolean;\n  #realm: Realm;\n\n  constructor(realm: Realm, payload: Protocol.Accessibility.AXNode) {\n    this.payload = payload;\n    this.#name = this.payload.name ? this.payload.name.value : '';\n    this.#role = this.payload.role ? this.payload.role.value : 'Unknown';\n    this.#ignored = this.payload.ignored;\n    this.#realm = realm;\n    for (const property of this.payload.properties || []) {\n      if (property.name === 'editable') {\n        this.#richlyEditable = property.value.value === 'richtext';\n        this.#editable = true;\n      }\n      if (property.name === 'focusable') {\n        this.#focusable = property.value.value;\n      }\n      if (property.name === 'hidden') {\n        this.#hidden = property.value.value;\n      }\n    }\n  }\n\n  #isPlainTextField(): boolean {\n    if (this.#richlyEditable) {\n      return false;\n    }\n    if (this.#editable) {\n      return true;\n    }\n    return this.#role === 'textbox' || this.#role === 'searchbox';\n  }\n\n  #isTextOnlyObject(): boolean {\n    const role = this.#role;\n    return (\n      role === 'LineBreak' ||\n      role === 'text' ||\n      role === 'InlineTextBox' ||\n      role === 'StaticText'\n    );\n  }\n\n  #hasFocusableChild(): boolean {\n    if (this.#cachedHasFocusableChild === undefined) {\n      this.#cachedHasFocusableChild = false;\n      for (const child of this.children) {\n        if (child.#focusable || child.#hasFocusableChild()) {\n          this.#cachedHasFocusableChild = true;\n          break;\n        }\n      }\n    }\n    return this.#cachedHasFocusableChild;\n  }\n\n  public find(predicate: (x: AXNode) => boolean): AXNode | null {\n    if (predicate(this)) {\n      return this;\n    }\n    for (const child of this.children) {\n      const result = child.find(predicate);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n\n  public isLeafNode(): boolean {\n    if (!this.children.length) {\n      return true;\n    }\n\n    // These types of objects may have children that we use as internal\n    // implementation details, but we want to expose them as leaves to platform\n    // accessibility APIs because screen readers might be confused if they find\n    // any children.\n    if (this.#isPlainTextField() || this.#isTextOnlyObject()) {\n      return true;\n    }\n\n    // Roles whose children are only presentational according to the ARIA and\n    // HTML5 Specs should be hidden from screen readers.\n    // (Note that whilst ARIA buttons can have only presentational children, HTML5\n    // buttons are allowed to have content.)\n    switch (this.#role) {\n      case 'doc-cover':\n      case 'graphics-symbol':\n      case 'img':\n      case 'image':\n      case 'Meter':\n      case 'scrollbar':\n      case 'slider':\n      case 'separator':\n      case 'progressbar':\n        return true;\n      default:\n        break;\n    }\n\n    // Here and below: Android heuristics\n    if (this.#hasFocusableChild()) {\n      return false;\n    }\n    if (this.#focusable && this.#name) {\n      return true;\n    }\n    if (this.#role === 'heading' && this.#name) {\n      return true;\n    }\n    return false;\n  }\n\n  public isControl(): boolean {\n    switch (this.#role) {\n      case 'button':\n      case 'checkbox':\n      case 'ColorWell':\n      case 'combobox':\n      case 'DisclosureTriangle':\n      case 'listbox':\n      case 'menu':\n      case 'menubar':\n      case 'menuitem':\n      case 'menuitemcheckbox':\n      case 'menuitemradio':\n      case 'radio':\n      case 'scrollbar':\n      case 'searchbox':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'tab':\n      case 'textbox':\n      case 'tree':\n      case 'treeitem':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  public isInteresting(insideControl: boolean): boolean {\n    const role = this.#role;\n    if (role === 'Ignored' || this.#hidden || this.#ignored) {\n      return false;\n    }\n\n    if (this.#focusable || this.#richlyEditable) {\n      return true;\n    }\n\n    // If it's not focusable but has a control role, then it's interesting.\n    if (this.isControl()) {\n      return true;\n    }\n\n    // A non focusable child of a control is not interesting\n    if (insideControl) {\n      return false;\n    }\n\n    return this.isLeafNode() && !!this.#name;\n  }\n\n  public serialize(): SerializedAXNode {\n    const properties = new Map<string, number | string | boolean>();\n    for (const property of this.payload.properties || []) {\n      properties.set(property.name.toLowerCase(), property.value.value);\n    }\n    if (this.payload.name) {\n      properties.set('name', this.payload.name.value);\n    }\n    if (this.payload.value) {\n      properties.set('value', this.payload.value.value);\n    }\n    if (this.payload.description) {\n      properties.set('description', this.payload.description.value);\n    }\n\n    const node: SerializedAXNode = {\n      role: this.#role,\n      elementHandle: async (): Promise<ElementHandle | null> => {\n        if (!this.payload.backendDOMNodeId) {\n          return null;\n        }\n        return (await this.#realm.adoptBackendNode(\n          this.payload.backendDOMNodeId,\n        )) as ElementHandle<Element>;\n      },\n    };\n\n    type UserStringProperty =\n      | 'name'\n      | 'value'\n      | 'description'\n      | 'keyshortcuts'\n      | 'roledescription'\n      | 'valuetext';\n\n    const userStringProperties: UserStringProperty[] = [\n      'name',\n      'value',\n      'description',\n      'keyshortcuts',\n      'roledescription',\n      'valuetext',\n    ];\n    const getUserStringPropertyValue = (key: UserStringProperty): string => {\n      return properties.get(key) as string;\n    };\n\n    for (const userStringProperty of userStringProperties) {\n      if (!properties.has(userStringProperty)) {\n        continue;\n      }\n\n      node[userStringProperty] = getUserStringPropertyValue(userStringProperty);\n    }\n\n    type BooleanProperty =\n      | 'disabled'\n      | 'expanded'\n      | 'focused'\n      | 'modal'\n      | 'multiline'\n      | 'multiselectable'\n      | 'readonly'\n      | 'required'\n      | 'selected';\n    const booleanProperties: BooleanProperty[] = [\n      'disabled',\n      'expanded',\n      'focused',\n      'modal',\n      'multiline',\n      'multiselectable',\n      'readonly',\n      'required',\n      'selected',\n    ];\n    const getBooleanPropertyValue = (key: BooleanProperty): boolean => {\n      return properties.get(key) as boolean;\n    };\n\n    for (const booleanProperty of booleanProperties) {\n      // RootWebArea's treat focus differently than other nodes. They report whether\n      // their frame  has focus, not whether focus is specifically on the root\n      // node.\n      if (booleanProperty === 'focused' && this.#role === 'RootWebArea') {\n        continue;\n      }\n      const value = getBooleanPropertyValue(booleanProperty);\n      if (!value) {\n        continue;\n      }\n      node[booleanProperty] = getBooleanPropertyValue(booleanProperty);\n    }\n\n    type TristateProperty = 'checked' | 'pressed';\n    const tristateProperties: TristateProperty[] = ['checked', 'pressed'];\n    for (const tristateProperty of tristateProperties) {\n      if (!properties.has(tristateProperty)) {\n        continue;\n      }\n      const value = properties.get(tristateProperty);\n      node[tristateProperty] =\n        value === 'mixed' ? 'mixed' : value === 'true' ? true : false;\n    }\n\n    type NumbericalProperty = 'level' | 'valuemax' | 'valuemin';\n    const numericalProperties: NumbericalProperty[] = [\n      'level',\n      'valuemax',\n      'valuemin',\n    ];\n    const getNumericalPropertyValue = (key: NumbericalProperty): number => {\n      return properties.get(key) as number;\n    };\n    for (const numericalProperty of numericalProperties) {\n      if (!properties.has(numericalProperty)) {\n        continue;\n      }\n      node[numericalProperty] = getNumericalPropertyValue(numericalProperty);\n    }\n\n    type TokenProperty =\n      | 'autocomplete'\n      | 'haspopup'\n      | 'invalid'\n      | 'orientation';\n    const tokenProperties: TokenProperty[] = [\n      'autocomplete',\n      'haspopup',\n      'invalid',\n      'orientation',\n    ];\n    const getTokenPropertyValue = (key: TokenProperty): string => {\n      return properties.get(key) as string;\n    };\n    for (const tokenProperty of tokenProperties) {\n      const value = getTokenPropertyValue(tokenProperty);\n      if (!value || value === 'false') {\n        continue;\n      }\n      node[tokenProperty] = getTokenPropertyValue(tokenProperty);\n    }\n    return node;\n  }\n\n  public static createTree(\n    realm: Realm,\n    payloads: Protocol.Accessibility.AXNode[],\n  ): AXNode | null {\n    const nodeById = new Map<string, AXNode>();\n    for (const payload of payloads) {\n      nodeById.set(payload.nodeId, new AXNode(realm, payload));\n    }\n    for (const node of nodeById.values()) {\n      for (const childId of node.payload.childIds || []) {\n        const child = nodeById.get(childId);\n        if (child) {\n          node.children.push(child);\n        }\n      }\n    }\n    return nodeById.values().next().value ?? null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}