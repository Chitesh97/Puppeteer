{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { FrameEvent } from '../api/Frame.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { debugError, PuppeteerURL, UTILITY_WORLD_NAME } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { disposeSymbol } from '../util/disposable.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { CdpPreloadScript } from './CdpPreloadScript.js';\nimport { isTargetClosedError } from './Connection.js';\nimport { DeviceRequestPromptManager } from './DeviceRequestPrompt.js';\nimport { ExecutionContext } from './ExecutionContext.js';\nimport { CdpFrame } from './Frame.js';\nimport { FrameManagerEvent } from './FrameManagerEvents.js';\nimport { FrameTree } from './FrameTree.js';\nimport { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';\nimport { NetworkManager } from './NetworkManager.js';\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter {\n  #page;\n  #networkManager;\n  #timeoutSettings;\n  #isolatedWorlds = new Set();\n  #client;\n  #scriptsToEvaluateOnNewDocument = new Map();\n  #bindings = new Set();\n  _frameTree = new FrameTree();\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set();\n  #deviceRequestPromptManagerMap = new WeakMap();\n  #frameTreeHandled;\n  get timeoutSettings() {\n    return this.#timeoutSettings;\n  }\n  get networkManager() {\n    return this.#networkManager;\n  }\n  get client() {\n    return this.#client;\n  }\n  constructor(client, page, timeoutSettings) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(this, page.browser().isNetworkEnabled());\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n  }\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n    if (!this.#page.browser().connected) {\n      // If the browser is not connected we know\n      // that activation will not happen\n      this.#removeFramesRecursively(mainFrame);\n      return;\n    }\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred.create({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped'\n    });\n    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client) {\n    this.#client = client;\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client.target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client.target()._targetId);\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n    await this.initialize(client, frame);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n  async registerSpeculativeSession(client) {\n    await this.#networkManager.addClient(client);\n  }\n  setupEventListeners(session) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on('Page.frameDetached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameDetached(event.frameId, event.reason);\n    });\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n  async initialize(client, frame) {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchronously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([this.#networkManager.addClient(client), client.send('Page.enable'), client.send('Page.getFrameTree').then(({\n        frameTree\n      }) => {\n        this.#handleFrameTree(client, frameTree);\n        this.#frameTreeHandled?.resolve();\n      }), client.send('Page.setLifecycleEventsEnabled', {\n        enabled: true\n      }), client.send('Runtime.enable').then(() => {\n        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n      }), ...(frame ? Array.from(this.#scriptsToEvaluateOnNewDocument.values()) : []).map(script => {\n        return frame?.addPreloadScript(script);\n      }), ...(frame ? Array.from(this.#bindings.values()) : []).map(binding => {\n        return frame?.addExposedFunctionBinding(binding);\n      })]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  page() {\n    return this.#page;\n  }\n  mainFrame() {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n  frames() {\n    return Array.from(this._frameTree.frames());\n  }\n  frame(frameId) {\n    return this._frameTree.getById(frameId) || null;\n  }\n  async addExposedFunctionBinding(binding) {\n    this.#bindings.add(binding);\n    await Promise.all(this.frames().map(async frame => {\n      return await frame.addExposedFunctionBinding(binding);\n    }));\n  }\n  async removeExposedFunctionBinding(binding) {\n    this.#bindings.delete(binding);\n    await Promise.all(this.frames().map(async frame => {\n      return await frame.removeExposedFunctionBinding(binding);\n    }));\n  }\n  async evaluateOnNewDocument(source) {\n    const {\n      identifier\n    } = await this.mainFrame()._client().send('Page.addScriptToEvaluateOnNewDocument', {\n      source\n    });\n    const preloadScript = new CdpPreloadScript(this.mainFrame(), identifier, source);\n    this.#scriptsToEvaluateOnNewDocument.set(identifier, preloadScript);\n    await Promise.all(this.frames().map(async frame => {\n      return await frame.addPreloadScript(preloadScript);\n    }));\n    return {\n      identifier\n    };\n  }\n  async removeScriptToEvaluateOnNewDocument(identifier) {\n    const preloadScript = this.#scriptsToEvaluateOnNewDocument.get(identifier);\n    if (!preloadScript) {\n      throw new Error(`Script to evaluate on new document with id ${identifier} not found`);\n    }\n    this.#scriptsToEvaluateOnNewDocument.delete(identifier);\n    await Promise.all(this.frames().map(frame => {\n      const identifier = preloadScript.getIdForFrame(frame);\n      if (!identifier) {\n        return;\n      }\n      return frame._client().send('Page.removeScriptToEvaluateOnNewDocument', {\n        identifier\n      }).catch(debugError);\n    }));\n  }\n  onAttachedToTarget(target) {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session());\n    }\n    this.setupEventListeners(target._session());\n    void this.initialize(target._session(), frame);\n  }\n  _deviceRequestPromptManager(client) {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n  #onLifecycleEvent(event) {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n  #onFrameStartedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n  #onFrameStoppedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n  #handleFrameTree(session, frameTree) {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n    if (!frameTree.childFrames) {\n      return;\n    }\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n  #onFrameAttached(session, frameId, parentFrameId) {\n    let frame = this.frame(frameId);\n    if (frame) {\n      const parentFrame = this.frame(parentFrameId);\n      if (session && parentFrame && frame.client !== parentFrame?.client) {\n        // If an OOP iframes becomes a normal iframe\n        // again it is first attached to the parent frame before the\n        // target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n    frame = new CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvent.FrameAttached, frame);\n  }\n  async #onFrameNavigated(framePayload, navigationType) {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n    let frame = this._frameTree.getById(frameId);\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, navigationType);\n  }\n  async #createIsolatedWorld(session, name) {\n    const key = `${session.id()}:${name}`;\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name\n    });\n    await Promise.all(this.frames().filter(frame => {\n      return frame.client === session;\n    }).map(frame => {\n      // Frames might be removed before we send this, so we don't want to\n      // throw an error.\n      return session.send('Page.createIsolatedWorld', {\n        frameId: frame._id,\n        worldName: name,\n        grantUniveralAccess: true\n      }).catch(debugError);\n    }));\n    this.#isolatedWorlds.add(key);\n  }\n  #onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, 'Navigation');\n  }\n  #onFrameDetached(frameId, reason) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n  #onExecutionContextCreated(contextPayload, session) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (contextPayload.name === UTILITY_WORLD_NAME) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext(frame?.client || this.#client, contextPayload, world);\n    world.setContext(context);\n  }\n  #removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvent.FrameDetached, frame);\n    frame.emit(FrameEvent.FrameDetached, frame);\n  }\n}","map":{"version":3,"names":["CDPSessionEvent","FrameEvent","EventEmitter","debugError","PuppeteerURL","UTILITY_WORLD_NAME","assert","Deferred","disposeSymbol","isErrorLike","CdpPreloadScript","isTargetClosedError","DeviceRequestPromptManager","ExecutionContext","CdpFrame","FrameManagerEvent","FrameTree","MAIN_WORLD","PUPPETEER_WORLD","NetworkManager","TIME_FOR_WAITING_FOR_SWAP","FrameManager","page","networkManager","timeoutSettings","isolatedWorlds","Set","client","scriptsToEvaluateOnNewDocument","Map","bindings","_frameTree","frameNavigatedReceived","deviceRequestPromptManagerMap","WeakMap","frameTreeHandled","constructor","browser","isNetworkEnabled","setupEventListeners","once","Disconnected","onClientDisconnect","catch","#onClientDisconnect","mainFrame","getMainFrame","connected","removeFramesRecursively","child","childFrames","swapped","create","timeout","message","FrameSwappedByActivation","resolve","valueOrThrow","swapFrameTree","frame","add","target","_targetId","removeFrame","updateId","addFrame","updateClient","initialize","addClient","emit","undefined","registerSpeculativeSession","session","on","event","onFrameAttached","frameId","parentFrameId","id","onFrameNavigated","type","onFrameNavigatedWithinDocument","url","onFrameDetached","reason","onFrameStartedLoading","onFrameStoppedLoading","onExecutionContextCreated","context","onLifecycleEvent","Promise","all","send","then","frameTree","handleFrameTree","enabled","createIsolatedWorld","Array","from","values","map","script","addPreloadScript","binding","addExposedFunctionBinding","error","frames","getById","removeExposedFunctionBinding","delete","evaluateOnNewDocument","source","identifier","_client","preloadScript","set","removeScriptToEvaluateOnNewDocument","get","Error","getIdForFrame","onAttachedToTarget","_getTargetInfo","targetId","_session","_deviceRequestPromptManager","manager","#onLifecycleEvent","_onLifecycleEvent","loaderId","name","LifecycleEvent","#onFrameStartedLoading","_onLoadingStarted","#onFrameStoppedLoading","_onLoadingStopped","#handleFrameTree","parentId","has","#onFrameAttached","parentFrame","FrameAttached","#onFrameNavigated","framePayload","navigationType","isMainFrame","_id","waitForFrame","_navigated","FrameNavigated","#createIsolatedWorld","key","INTERNAL_URL","worldName","filter","grantUniveralAccess","#onFrameNavigatedWithinDocument","_navigatedWithinDocument","FrameNavigatedWithinDocument","#onFrameDetached","FrameSwapped","#onExecutionContextCreated","contextPayload","auxData","world","worlds","setContext","#removeFramesRecursively","FrameDetached"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/FrameManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {type CDPSession, CDPSessionEvent} from '../api/CDPSession.js';\nimport {FrameEvent} from '../api/Frame.js';\nimport type {NewDocumentScriptEvaluation} from '../api/Page.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport {debugError, PuppeteerURL, UTILITY_WORLD_NAME} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {disposeSymbol} from '../util/disposable.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport type {Binding} from './Binding.js';\nimport {CdpPreloadScript} from './CdpPreloadScript.js';\nimport type {CdpCDPSession} from './CdpSession.js';\nimport {isTargetClosedError} from './Connection.js';\nimport {DeviceRequestPromptManager} from './DeviceRequestPrompt.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {CdpFrame} from './Frame.js';\nimport type {FrameManagerEvents} from './FrameManagerEvents.js';\nimport {FrameManagerEvent} from './FrameManagerEvents.js';\nimport {FrameTree} from './FrameTree.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {NetworkManager} from './NetworkManager.js';\nimport type {CdpPage} from './Page.js';\nimport type {CdpTarget} from './Target.js';\n\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter<FrameManagerEvents> {\n  #page: CdpPage;\n  #networkManager: NetworkManager;\n  #timeoutSettings: TimeoutSettings;\n  #isolatedWorlds = new Set<string>();\n  #client: CdpCDPSession;\n  #scriptsToEvaluateOnNewDocument = new Map<string, CdpPreloadScript>();\n  #bindings = new Set<Binding>();\n\n  _frameTree = new FrameTree<CdpFrame>();\n\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set<string>();\n\n  #deviceRequestPromptManagerMap = new WeakMap<\n    CDPSession,\n    DeviceRequestPromptManager\n  >();\n\n  #frameTreeHandled?: Deferred<void>;\n\n  get timeoutSettings(): TimeoutSettings {\n    return this.#timeoutSettings;\n  }\n\n  get networkManager(): NetworkManager {\n    return this.#networkManager;\n  }\n\n  get client(): CdpCDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CdpCDPSession,\n    page: CdpPage,\n    timeoutSettings: TimeoutSettings,\n  ) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(\n      this,\n      page.browser().isNetworkEnabled(),\n    );\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n  }\n\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n\n    if (!this.#page.browser().connected) {\n      // If the browser is not connected we know\n      // that activation will not happen\n      this.#removeFramesRecursively(mainFrame);\n      return;\n    }\n\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred.create<void>({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped',\n    });\n    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client: CdpCDPSession): Promise<void> {\n    this.#client = client;\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client.target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client.target()._targetId);\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n    await this.initialize(client, frame);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n\n  async registerSpeculativeSession(client: CdpCDPSession): Promise<void> {\n    await this.#networkManager.addClient(client);\n  }\n\n  private setupEventListeners(session: CDPSession) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on(\n      'Page.frameDetached',\n      async (event: Protocol.Page.FrameDetachedEvent) => {\n        await this.#frameTreeHandled?.valueOrThrow();\n        this.#onFrameDetached(\n          event.frameId,\n          event.reason as Protocol.Page.FrameDetachedEventReason,\n        );\n      },\n    );\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n\n  async initialize(client: CDPSession, frame?: CdpFrame | null): Promise<void> {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchronously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([\n        this.#networkManager.addClient(client),\n        client.send('Page.enable'),\n        client.send('Page.getFrameTree').then(({frameTree}) => {\n          this.#handleFrameTree(client, frameTree);\n          this.#frameTreeHandled?.resolve();\n        }),\n        client.send('Page.setLifecycleEventsEnabled', {enabled: true}),\n        client.send('Runtime.enable').then(() => {\n          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n        }),\n        ...(frame\n          ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())\n          : []\n        ).map(script => {\n          return frame?.addPreloadScript(script);\n        }),\n        ...(frame ? Array.from(this.#bindings.values()) : []).map(binding => {\n          return frame?.addExposedFunctionBinding(binding);\n        }),\n      ]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  page(): CdpPage {\n    return this.#page;\n  }\n\n  mainFrame(): CdpFrame {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n\n  frames(): CdpFrame[] {\n    return Array.from(this._frameTree.frames());\n  }\n\n  frame(frameId: string): CdpFrame | null {\n    return this._frameTree.getById(frameId) || null;\n  }\n\n  async addExposedFunctionBinding(binding: Binding): Promise<void> {\n    this.#bindings.add(binding);\n    await Promise.all(\n      this.frames().map(async frame => {\n        return await frame.addExposedFunctionBinding(binding);\n      }),\n    );\n  }\n\n  async removeExposedFunctionBinding(binding: Binding): Promise<void> {\n    this.#bindings.delete(binding);\n    await Promise.all(\n      this.frames().map(async frame => {\n        return await frame.removeExposedFunctionBinding(binding);\n      }),\n    );\n  }\n\n  async evaluateOnNewDocument(\n    source: string,\n  ): Promise<NewDocumentScriptEvaluation> {\n    const {identifier} = await this.mainFrame()\n      ._client()\n      .send('Page.addScriptToEvaluateOnNewDocument', {\n        source,\n      });\n\n    const preloadScript = new CdpPreloadScript(\n      this.mainFrame(),\n      identifier,\n      source,\n    );\n\n    this.#scriptsToEvaluateOnNewDocument.set(identifier, preloadScript);\n\n    await Promise.all(\n      this.frames().map(async frame => {\n        return await frame.addPreloadScript(preloadScript);\n      }),\n    );\n\n    return {identifier};\n  }\n\n  async removeScriptToEvaluateOnNewDocument(identifier: string): Promise<void> {\n    const preloadScript = this.#scriptsToEvaluateOnNewDocument.get(identifier);\n    if (!preloadScript) {\n      throw new Error(\n        `Script to evaluate on new document with id ${identifier} not found`,\n      );\n    }\n\n    this.#scriptsToEvaluateOnNewDocument.delete(identifier);\n\n    await Promise.all(\n      this.frames().map(frame => {\n        const identifier = preloadScript.getIdForFrame(frame);\n        if (!identifier) {\n          return;\n        }\n        return frame\n          ._client()\n          .send('Page.removeScriptToEvaluateOnNewDocument', {\n            identifier,\n          })\n          .catch(debugError);\n      }),\n    );\n  }\n\n  onAttachedToTarget(target: CdpTarget): void {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session()!);\n    }\n    this.setupEventListeners(target._session()!);\n    void this.initialize(target._session()!, frame);\n  }\n\n  _deviceRequestPromptManager(client: CDPSession): DeviceRequestPromptManager {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n\n  #onLifecycleEvent(event: Protocol.Page.LifecycleEventEvent): void {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #onFrameStartedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n\n  #onFrameStoppedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #handleFrameTree(\n    session: CDPSession,\n    frameTree: Protocol.Page.FrameTree,\n  ): void {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(\n        session,\n        frameTree.frame.id,\n        frameTree.frame.parentId,\n      );\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n\n    if (!frameTree.childFrames) {\n      return;\n    }\n\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n\n  #onFrameAttached(\n    session: CDPSession,\n    frameId: string,\n    parentFrameId: string,\n  ): void {\n    let frame = this.frame(frameId);\n    if (frame) {\n      const parentFrame = this.frame(parentFrameId);\n      if (session && parentFrame && frame.client !== parentFrame?.client) {\n        // If an OOP iframes becomes a normal iframe\n        // again it is first attached to the parent frame before the\n        // target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n\n    frame = new CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvent.FrameAttached, frame);\n  }\n\n  async #onFrameNavigated(\n    framePayload: Protocol.Page.Frame,\n    navigationType: Protocol.Page.NavigationType,\n  ): Promise<void> {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n\n    let frame = this._frameTree.getById(frameId);\n\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, navigationType);\n  }\n\n  async #createIsolatedWorld(session: CDPSession, name: string): Promise<void> {\n    const key = `${session.id()}:${name}`;\n\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name,\n    });\n\n    await Promise.all(\n      this.frames()\n        .filter(frame => {\n          return frame.client === session;\n        })\n        .map(frame => {\n          // Frames might be removed before we send this, so we don't want to\n          // throw an error.\n          return session\n            .send('Page.createIsolatedWorld', {\n              frameId: frame._id,\n              worldName: name,\n              grantUniveralAccess: true,\n            })\n            .catch(debugError);\n        }),\n    );\n\n    this.#isolatedWorlds.add(key);\n  }\n\n  #onFrameNavigatedWithinDocument(frameId: string, url: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, 'Navigation');\n  }\n\n  #onFrameDetached(\n    frameId: string,\n    reason: Protocol.Page.FrameDetachedEventReason,\n  ): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n\n  #onExecutionContextCreated(\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    session: CDPSession,\n  ): void {\n    const auxData = contextPayload.auxData as {frameId?: string} | undefined;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world: IsolatedWorld | undefined;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (contextPayload.name === UTILITY_WORLD_NAME) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext(\n      frame?.client || this.#client,\n      contextPayload,\n      world,\n    );\n    world.setContext(context);\n  }\n\n  #removeFramesRecursively(frame: CdpFrame): void {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvent.FrameDetached, frame);\n    frame.emit(FrameEvent.FrameDetached, frame);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}