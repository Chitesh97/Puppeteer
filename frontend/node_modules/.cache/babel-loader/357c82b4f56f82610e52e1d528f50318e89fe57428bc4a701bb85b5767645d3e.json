{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { CallbackRegistry } from '../common/CallbackRegistry.js';\nimport { debug } from '../common/Debug.js';\nimport { TargetCloseError } from '../common/Errors.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { createProtocolErrorMessage } from '../util/ErrorLike.js';\nimport { CdpCDPSession } from './CdpSession.js';\nconst debugProtocolSend = debug('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = debug('puppeteer:protocol:RECV ◀');\n/**\n * @public\n */\nexport class Connection extends EventEmitter {\n  #url;\n  #transport;\n  #delay;\n  #timeout;\n  #sessions = new Map();\n  #closed = false;\n  #manuallyAttached = new Set();\n  #callbacks;\n  #rawErrors = false;\n  constructor(url, transport, delay = 0, timeout, rawErrors = false) {\n    super();\n    this.#rawErrors = rawErrors;\n    this.#callbacks = new CallbackRegistry();\n    this.#url = url;\n    this.#delay = delay;\n    this.#timeout = timeout ?? 180_000;\n    this.#transport = transport;\n    this.#transport.onmessage = this.onMessage.bind(this);\n    this.#transport.onclose = this.#onClose.bind(this);\n  }\n  static fromSession(session) {\n    return session.connection();\n  }\n  /**\n   * @internal\n   */\n  get delay() {\n    return this.#delay;\n  }\n  get timeout() {\n    return this.#timeout;\n  }\n  /**\n   * @internal\n   */\n  get _closed() {\n    return this.#closed;\n  }\n  /**\n   * @internal\n   */\n  get _sessions() {\n    return this.#sessions;\n  }\n  /**\n   * @internal\n   */\n  _session(sessionId) {\n    return this.#sessions.get(sessionId) || null;\n  }\n  /**\n   * @param sessionId - The session id\n   * @returns The current CDP session if it exists\n   */\n  session(sessionId) {\n    return this._session(sessionId);\n  }\n  url() {\n    return this.#url;\n  }\n  send(method, params, options) {\n    // There is only ever 1 param arg passed, but the Protocol defines it as an\n    // array of 0 or 1 items See this comment:\n    // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n    // which explains why the protocol defines the params this way for better\n    // type-inference.\n    // So now we check if there are any params or not and deal with them accordingly.\n    return this._rawSend(this.#callbacks, method, params, undefined, options);\n  }\n  /**\n   * @internal\n   */\n  _rawSend(callbacks, method, params, sessionId, options) {\n    if (this.#closed) {\n      return Promise.reject(new Error('Protocol error: Connection closed.'));\n    }\n    return callbacks.create(method, options?.timeout ?? this.#timeout, id => {\n      const stringifiedMessage = JSON.stringify({\n        method,\n        params,\n        id,\n        sessionId\n      });\n      debugProtocolSend(stringifiedMessage);\n      this.#transport.send(stringifiedMessage);\n    });\n  }\n  /**\n   * @internal\n   */\n  async closeBrowser() {\n    await this.send('Browser.close');\n  }\n  /**\n   * @internal\n   */\n  async onMessage(message) {\n    if (this.#delay) {\n      await new Promise(r => {\n        return setTimeout(r, this.#delay);\n      });\n    }\n    debugProtocolReceive(message);\n    const object = JSON.parse(message);\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId, this.#rawErrors);\n      this.#sessions.set(sessionId, session);\n      this.emit(CDPSessionEvent.SessionAttached, session);\n      const parentSession = this.#sessions.get(object.sessionId);\n      if (parentSession) {\n        parentSession.emit(CDPSessionEvent.SessionAttached, session);\n      }\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = this.#sessions.get(object.params.sessionId);\n      if (session) {\n        session.onClosed();\n        this.#sessions.delete(object.params.sessionId);\n        this.emit(CDPSessionEvent.SessionDetached, session);\n        const parentSession = this.#sessions.get(object.sessionId);\n        if (parentSession) {\n          parentSession.emit(CDPSessionEvent.SessionDetached, session);\n        }\n      }\n    }\n    if (object.sessionId) {\n      const session = this.#sessions.get(object.sessionId);\n      if (session) {\n        session.onMessage(object);\n      }\n    } else if (object.id) {\n      if (object.error) {\n        if (this.#rawErrors) {\n          this.#callbacks.rejectRaw(object.id, object.error);\n        } else {\n          this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);\n        }\n      } else {\n        this.#callbacks.resolve(object.id, object.result);\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n  #onClose() {\n    if (this.#closed) {\n      return;\n    }\n    this.#closed = true;\n    this.#transport.onmessage = undefined;\n    this.#transport.onclose = undefined;\n    this.#callbacks.clear();\n    for (const session of this.#sessions.values()) {\n      session.onClosed();\n    }\n    this.#sessions.clear();\n    this.emit(CDPSessionEvent.Disconnected, undefined);\n  }\n  dispose() {\n    this.#onClose();\n    this.#transport.close();\n  }\n  /**\n   * @internal\n   */\n  isAutoAttached(targetId) {\n    return !this.#manuallyAttached.has(targetId);\n  }\n  /**\n   * @internal\n   */\n  async _createSession(targetInfo, isAutoAttachEmulated = true) {\n    if (!isAutoAttachEmulated) {\n      this.#manuallyAttached.add(targetInfo.targetId);\n    }\n    const {\n      sessionId\n    } = await this.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true\n    });\n    this.#manuallyAttached.delete(targetInfo.targetId);\n    const session = this.#sessions.get(sessionId);\n    if (!session) {\n      throw new Error('CDPSession creation failed.');\n    }\n    return session;\n  }\n  /**\n   * @param targetInfo - The target info\n   * @returns The CDP session that is created\n   */\n  async createSession(targetInfo) {\n    return await this._createSession(targetInfo, false);\n  }\n  /**\n   * @internal\n   */\n  getPendingProtocolErrors() {\n    const result = [];\n    result.push(...this.#callbacks.getPendingProtocolErrors());\n    for (const session of this.#sessions.values()) {\n      result.push(...session.getPendingProtocolErrors());\n    }\n    return result;\n  }\n}\n/**\n * @internal\n */\nexport function isTargetClosedError(error) {\n  return error instanceof TargetCloseError;\n}","map":{"version":3,"names":["CDPSessionEvent","CallbackRegistry","debug","TargetCloseError","EventEmitter","createProtocolErrorMessage","CdpCDPSession","debugProtocolSend","debugProtocolReceive","Connection","url","transport","delay","timeout","sessions","Map","closed","manuallyAttached","Set","callbacks","rawErrors","constructor","onmessage","onMessage","bind","onclose","onClose","fromSession","session","connection","_closed","_sessions","_session","sessionId","get","send","method","params","options","_rawSend","undefined","Promise","reject","Error","create","id","stringifiedMessage","JSON","stringify","closeBrowser","message","r","setTimeout","object","parse","targetInfo","type","set","emit","SessionAttached","parentSession","onClosed","delete","SessionDetached","error","rejectRaw","resolve","result","#onClose","clear","values","Disconnected","dispose","close","isAutoAttached","targetId","has","_createSession","isAutoAttachEmulated","add","flatten","createSession","getPendingProtocolErrors","push","isTargetClosedError"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/Connection.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {Protocol} from 'devtools-protocol';\nimport type {ProtocolMapping} from 'devtools-protocol/types/protocol-mapping.js';\n\nimport type {CommandOptions} from '../api/CDPSession.js';\nimport {\n  CDPSessionEvent,\n  type CDPSession,\n  type CDPSessionEvents,\n} from '../api/CDPSession.js';\nimport {CallbackRegistry} from '../common/CallbackRegistry.js';\nimport type {ConnectionTransport} from '../common/ConnectionTransport.js';\nimport {debug} from '../common/Debug.js';\nimport {TargetCloseError} from '../common/Errors.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport {createProtocolErrorMessage} from '../util/ErrorLike.js';\n\nimport {CdpCDPSession} from './CdpSession.js';\n\nconst debugProtocolSend = debug('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = debug('puppeteer:protocol:RECV ◀');\n\n/**\n * @public\n */\nexport class Connection extends EventEmitter<CDPSessionEvents> {\n  #url: string;\n  #transport: ConnectionTransport;\n  #delay: number;\n  #timeout: number;\n  #sessions = new Map<string, CdpCDPSession>();\n  #closed = false;\n  #manuallyAttached = new Set<string>();\n  #callbacks: CallbackRegistry;\n  #rawErrors = false;\n\n  constructor(\n    url: string,\n    transport: ConnectionTransport,\n    delay = 0,\n    timeout?: number,\n    rawErrors = false,\n  ) {\n    super();\n    this.#rawErrors = rawErrors;\n    this.#callbacks = new CallbackRegistry();\n    this.#url = url;\n    this.#delay = delay;\n    this.#timeout = timeout ?? 180_000;\n\n    this.#transport = transport;\n    this.#transport.onmessage = this.onMessage.bind(this);\n    this.#transport.onclose = this.#onClose.bind(this);\n  }\n\n  static fromSession(session: CDPSession): Connection | undefined {\n    return session.connection();\n  }\n\n  /**\n   * @internal\n   */\n  get delay(): number {\n    return this.#delay;\n  }\n\n  get timeout(): number {\n    return this.#timeout;\n  }\n\n  /**\n   * @internal\n   */\n  get _closed(): boolean {\n    return this.#closed;\n  }\n\n  /**\n   * @internal\n   */\n  get _sessions(): Map<string, CdpCDPSession> {\n    return this.#sessions;\n  }\n\n  /**\n   * @internal\n   */\n  _session(sessionId: string): CdpCDPSession | null {\n    return this.#sessions.get(sessionId) || null;\n  }\n\n  /**\n   * @param sessionId - The session id\n   * @returns The current CDP session if it exists\n   */\n  session(sessionId: string): CDPSession | null {\n    return this._session(sessionId);\n  }\n\n  url(): string {\n    return this.#url;\n  }\n\n  send<T extends keyof ProtocolMapping.Commands>(\n    method: T,\n    params?: ProtocolMapping.Commands[T]['paramsType'][0],\n    options?: CommandOptions,\n  ): Promise<ProtocolMapping.Commands[T]['returnType']> {\n    // There is only ever 1 param arg passed, but the Protocol defines it as an\n    // array of 0 or 1 items See this comment:\n    // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n    // which explains why the protocol defines the params this way for better\n    // type-inference.\n    // So now we check if there are any params or not and deal with them accordingly.\n    return this._rawSend(this.#callbacks, method, params, undefined, options);\n  }\n\n  /**\n   * @internal\n   */\n  _rawSend<T extends keyof ProtocolMapping.Commands>(\n    callbacks: CallbackRegistry,\n    method: T,\n    params: ProtocolMapping.Commands[T]['paramsType'][0],\n    sessionId?: string,\n    options?: CommandOptions,\n  ): Promise<ProtocolMapping.Commands[T]['returnType']> {\n    if (this.#closed) {\n      return Promise.reject(new Error('Protocol error: Connection closed.'));\n    }\n    return callbacks.create(method, options?.timeout ?? this.#timeout, id => {\n      const stringifiedMessage = JSON.stringify({\n        method,\n        params,\n        id,\n        sessionId,\n      });\n      debugProtocolSend(stringifiedMessage);\n      this.#transport.send(stringifiedMessage);\n    }) as Promise<ProtocolMapping.Commands[T]['returnType']>;\n  }\n\n  /**\n   * @internal\n   */\n  async closeBrowser(): Promise<void> {\n    await this.send('Browser.close');\n  }\n\n  /**\n   * @internal\n   */\n  protected async onMessage(message: string): Promise<void> {\n    if (this.#delay) {\n      await new Promise(r => {\n        return setTimeout(r, this.#delay);\n      });\n    }\n    debugProtocolReceive(message);\n    const object = JSON.parse(message);\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CdpCDPSession(\n        this,\n        object.params.targetInfo.type,\n        sessionId,\n        object.sessionId,\n        this.#rawErrors,\n      );\n      this.#sessions.set(sessionId, session);\n      this.emit(CDPSessionEvent.SessionAttached, session);\n      const parentSession = this.#sessions.get(object.sessionId);\n      if (parentSession) {\n        parentSession.emit(CDPSessionEvent.SessionAttached, session);\n      }\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = this.#sessions.get(object.params.sessionId);\n      if (session) {\n        session.onClosed();\n        this.#sessions.delete(object.params.sessionId);\n        this.emit(CDPSessionEvent.SessionDetached, session);\n        const parentSession = this.#sessions.get(object.sessionId);\n        if (parentSession) {\n          parentSession.emit(CDPSessionEvent.SessionDetached, session);\n        }\n      }\n    }\n    if (object.sessionId) {\n      const session = this.#sessions.get(object.sessionId);\n      if (session) {\n        session.onMessage(object);\n      }\n    } else if (object.id) {\n      if (object.error) {\n        if (this.#rawErrors) {\n          this.#callbacks.rejectRaw(object.id, object.error);\n        } else {\n          this.#callbacks.reject(\n            object.id,\n            createProtocolErrorMessage(object),\n            object.error.message,\n          );\n        }\n      } else {\n        this.#callbacks.resolve(object.id, object.result);\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n\n  #onClose(): void {\n    if (this.#closed) {\n      return;\n    }\n    this.#closed = true;\n    this.#transport.onmessage = undefined;\n    this.#transport.onclose = undefined;\n    this.#callbacks.clear();\n    for (const session of this.#sessions.values()) {\n      session.onClosed();\n    }\n    this.#sessions.clear();\n    this.emit(CDPSessionEvent.Disconnected, undefined);\n  }\n\n  dispose(): void {\n    this.#onClose();\n    this.#transport.close();\n  }\n\n  /**\n   * @internal\n   */\n  isAutoAttached(targetId: string): boolean {\n    return !this.#manuallyAttached.has(targetId);\n  }\n\n  /**\n   * @internal\n   */\n  async _createSession(\n    targetInfo: {targetId: string},\n    isAutoAttachEmulated = true,\n  ): Promise<CdpCDPSession> {\n    if (!isAutoAttachEmulated) {\n      this.#manuallyAttached.add(targetInfo.targetId);\n    }\n    const {sessionId} = await this.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true,\n    });\n    this.#manuallyAttached.delete(targetInfo.targetId);\n    const session = this.#sessions.get(sessionId);\n    if (!session) {\n      throw new Error('CDPSession creation failed.');\n    }\n    return session;\n  }\n\n  /**\n   * @param targetInfo - The target info\n   * @returns The CDP session that is created\n   */\n  async createSession(\n    targetInfo: Protocol.Target.TargetInfo,\n  ): Promise<CDPSession> {\n    return await this._createSession(targetInfo, false);\n  }\n\n  /**\n   * @internal\n   */\n  getPendingProtocolErrors(): Error[] {\n    const result: Error[] = [];\n    result.push(...this.#callbacks.getPendingProtocolErrors());\n    for (const session of this.#sessions.values()) {\n      result.push(...session.getPendingProtocolErrors());\n    }\n    return result;\n  }\n}\n\n/**\n * @internal\n */\nexport function isTargetClosedError(error: Error): boolean {\n  return error instanceof TargetCloseError;\n}\n"],"mappings":"AAAA;;;;;AAUA,SACEA,eAAe,QAGV,sBAAsB;AAC7B,SAAQC,gBAAgB,QAAO,+BAA+B;AAE9D,SAAQC,KAAK,QAAO,oBAAoB;AACxC,SAAQC,gBAAgB,QAAO,qBAAqB;AACpD,SAAQC,YAAY,QAAO,2BAA2B;AACtD,SAAQC,0BAA0B,QAAO,sBAAsB;AAE/D,SAAQC,aAAa,QAAO,iBAAiB;AAE7C,MAAMC,iBAAiB,GAAGL,KAAK,CAAC,2BAA2B,CAAC;AAC5D,MAAMM,oBAAoB,GAAGN,KAAK,CAAC,2BAA2B,CAAC;AAE/D;;;AAGA,OAAM,MAAOO,UAAW,SAAQL,YAA8B;EAC5D,CAAAM,GAAI;EACJ,CAAAC,SAAU;EACV,CAAAC,KAAM;EACN,CAAAC,OAAQ;EACR,CAAAC,QAAS,GAAG,IAAIC,GAAG,EAAyB;EAC5C,CAAAC,MAAO,GAAG,KAAK;EACf,CAAAC,gBAAiB,GAAG,IAAIC,GAAG,EAAU;EACrC,CAAAC,SAAU;EACV,CAAAC,SAAU,GAAG,KAAK;EAElBC,YACEX,GAAW,EACXC,SAA8B,EAC9BC,KAAK,GAAG,CAAC,EACTC,OAAgB,EAChBO,SAAS,GAAG,KAAK;IAEjB,KAAK,EAAE;IACP,IAAI,CAAC,CAAAA,SAAU,GAAGA,SAAS;IAC3B,IAAI,CAAC,CAAAD,SAAU,GAAG,IAAIlB,gBAAgB,EAAE;IACxC,IAAI,CAAC,CAAAS,GAAI,GAAGA,GAAG;IACf,IAAI,CAAC,CAAAE,KAAM,GAAGA,KAAK;IACnB,IAAI,CAAC,CAAAC,OAAQ,GAAGA,OAAO,IAAI,OAAO;IAElC,IAAI,CAAC,CAAAF,SAAU,GAAGA,SAAS;IAC3B,IAAI,CAAC,CAAAA,SAAU,CAACW,SAAS,GAAG,IAAI,CAACC,SAAS,CAACC,IAAI,CAAC,IAAI,CAAC;IACrD,IAAI,CAAC,CAAAb,SAAU,CAACc,OAAO,GAAG,IAAI,CAAC,CAAAC,OAAQ,CAACF,IAAI,CAAC,IAAI,CAAC;EACpD;EAEA,OAAOG,WAAWA,CAACC,OAAmB;IACpC,OAAOA,OAAO,CAACC,UAAU,EAAE;EAC7B;EAEA;;;EAGA,IAAIjB,KAAKA,CAAA;IACP,OAAO,IAAI,CAAC,CAAAA,KAAM;EACpB;EAEA,IAAIC,OAAOA,CAAA;IACT,OAAO,IAAI,CAAC,CAAAA,OAAQ;EACtB;EAEA;;;EAGA,IAAIiB,OAAOA,CAAA;IACT,OAAO,IAAI,CAAC,CAAAd,MAAO;EACrB;EAEA;;;EAGA,IAAIe,SAASA,CAAA;IACX,OAAO,IAAI,CAAC,CAAAjB,QAAS;EACvB;EAEA;;;EAGAkB,QAAQA,CAACC,SAAiB;IACxB,OAAO,IAAI,CAAC,CAAAnB,QAAS,CAACoB,GAAG,CAACD,SAAS,CAAC,IAAI,IAAI;EAC9C;EAEA;;;;EAIAL,OAAOA,CAACK,SAAiB;IACvB,OAAO,IAAI,CAACD,QAAQ,CAACC,SAAS,CAAC;EACjC;EAEAvB,GAAGA,CAAA;IACD,OAAO,IAAI,CAAC,CAAAA,GAAI;EAClB;EAEAyB,IAAIA,CACFC,MAAS,EACTC,MAAqD,EACrDC,OAAwB;IAExB;IACA;IACA;IACA;IACA;IACA;IACA,OAAO,IAAI,CAACC,QAAQ,CAAC,IAAI,CAAC,CAAApB,SAAU,EAAEiB,MAAM,EAAEC,MAAM,EAAEG,SAAS,EAAEF,OAAO,CAAC;EAC3E;EAEA;;;EAGAC,QAAQA,CACNpB,SAA2B,EAC3BiB,MAAS,EACTC,MAAoD,EACpDJ,SAAkB,EAClBK,OAAwB;IAExB,IAAI,IAAI,CAAC,CAAAtB,MAAO,EAAE;MAChB,OAAOyB,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAC,oCAAoC,CAAC,CAAC;IACxE;IACA,OAAOxB,SAAS,CAACyB,MAAM,CAACR,MAAM,EAAEE,OAAO,EAAEzB,OAAO,IAAI,IAAI,CAAC,CAAAA,OAAQ,EAAEgC,EAAE,IAAG;MACtE,MAAMC,kBAAkB,GAAGC,IAAI,CAACC,SAAS,CAAC;QACxCZ,MAAM;QACNC,MAAM;QACNQ,EAAE;QACFZ;OACD,CAAC;MACF1B,iBAAiB,CAACuC,kBAAkB,CAAC;MACrC,IAAI,CAAC,CAAAnC,SAAU,CAACwB,IAAI,CAACW,kBAAkB,CAAC;IAC1C,CAAC,CAAuD;EAC1D;EAEA;;;EAGA,MAAMG,YAAYA,CAAA;IAChB,MAAM,IAAI,CAACd,IAAI,CAAC,eAAe,CAAC;EAClC;EAEA;;;EAGU,MAAMZ,SAASA,CAAC2B,OAAe;IACvC,IAAI,IAAI,CAAC,CAAAtC,KAAM,EAAE;MACf,MAAM,IAAI6B,OAAO,CAACU,CAAC,IAAG;QACpB,OAAOC,UAAU,CAACD,CAAC,EAAE,IAAI,CAAC,CAAAvC,KAAM,CAAC;MACnC,CAAC,CAAC;IACJ;IACAJ,oBAAoB,CAAC0C,OAAO,CAAC;IAC7B,MAAMG,MAAM,GAAGN,IAAI,CAACO,KAAK,CAACJ,OAAO,CAAC;IAClC,IAAIG,MAAM,CAACjB,MAAM,KAAK,yBAAyB,EAAE;MAC/C,MAAMH,SAAS,GAAGoB,MAAM,CAAChB,MAAM,CAACJ,SAAS;MACzC,MAAML,OAAO,GAAG,IAAItB,aAAa,CAC/B,IAAI,EACJ+C,MAAM,CAAChB,MAAM,CAACkB,UAAU,CAACC,IAAI,EAC7BvB,SAAS,EACToB,MAAM,CAACpB,SAAS,EAChB,IAAI,CAAC,CAAAb,SAAU,CAChB;MACD,IAAI,CAAC,CAAAN,QAAS,CAAC2C,GAAG,CAACxB,SAAS,EAAEL,OAAO,CAAC;MACtC,IAAI,CAAC8B,IAAI,CAAC1D,eAAe,CAAC2D,eAAe,EAAE/B,OAAO,CAAC;MACnD,MAAMgC,aAAa,GAAG,IAAI,CAAC,CAAA9C,QAAS,CAACoB,GAAG,CAACmB,MAAM,CAACpB,SAAS,CAAC;MAC1D,IAAI2B,aAAa,EAAE;QACjBA,aAAa,CAACF,IAAI,CAAC1D,eAAe,CAAC2D,eAAe,EAAE/B,OAAO,CAAC;MAC9D;IACF,CAAC,MAAM,IAAIyB,MAAM,CAACjB,MAAM,KAAK,2BAA2B,EAAE;MACxD,MAAMR,OAAO,GAAG,IAAI,CAAC,CAAAd,QAAS,CAACoB,GAAG,CAACmB,MAAM,CAAChB,MAAM,CAACJ,SAAS,CAAC;MAC3D,IAAIL,OAAO,EAAE;QACXA,OAAO,CAACiC,QAAQ,EAAE;QAClB,IAAI,CAAC,CAAA/C,QAAS,CAACgD,MAAM,CAACT,MAAM,CAAChB,MAAM,CAACJ,SAAS,CAAC;QAC9C,IAAI,CAACyB,IAAI,CAAC1D,eAAe,CAAC+D,eAAe,EAAEnC,OAAO,CAAC;QACnD,MAAMgC,aAAa,GAAG,IAAI,CAAC,CAAA9C,QAAS,CAACoB,GAAG,CAACmB,MAAM,CAACpB,SAAS,CAAC;QAC1D,IAAI2B,aAAa,EAAE;UACjBA,aAAa,CAACF,IAAI,CAAC1D,eAAe,CAAC+D,eAAe,EAAEnC,OAAO,CAAC;QAC9D;MACF;IACF;IACA,IAAIyB,MAAM,CAACpB,SAAS,EAAE;MACpB,MAAML,OAAO,GAAG,IAAI,CAAC,CAAAd,QAAS,CAACoB,GAAG,CAACmB,MAAM,CAACpB,SAAS,CAAC;MACpD,IAAIL,OAAO,EAAE;QACXA,OAAO,CAACL,SAAS,CAAC8B,MAAM,CAAC;MAC3B;IACF,CAAC,MAAM,IAAIA,MAAM,CAACR,EAAE,EAAE;MACpB,IAAIQ,MAAM,CAACW,KAAK,EAAE;QAChB,IAAI,IAAI,CAAC,CAAA5C,SAAU,EAAE;UACnB,IAAI,CAAC,CAAAD,SAAU,CAAC8C,SAAS,CAACZ,MAAM,CAACR,EAAE,EAAEQ,MAAM,CAACW,KAAK,CAAC;QACpD,CAAC,MAAM;UACL,IAAI,CAAC,CAAA7C,SAAU,CAACuB,MAAM,CACpBW,MAAM,CAACR,EAAE,EACTxC,0BAA0B,CAACgD,MAAM,CAAC,EAClCA,MAAM,CAACW,KAAK,CAACd,OAAO,CACrB;QACH;MACF,CAAC,MAAM;QACL,IAAI,CAAC,CAAA/B,SAAU,CAAC+C,OAAO,CAACb,MAAM,CAACR,EAAE,EAAEQ,MAAM,CAACc,MAAM,CAAC;MACnD;IACF,CAAC,MAAM;MACL,IAAI,CAACT,IAAI,CAACL,MAAM,CAACjB,MAAM,EAAEiB,MAAM,CAAChB,MAAM,CAAC;IACzC;EACF;EAEA,CAAAX,OAAQ0C,CAAA;IACN,IAAI,IAAI,CAAC,CAAApD,MAAO,EAAE;MAChB;IACF;IACA,IAAI,CAAC,CAAAA,MAAO,GAAG,IAAI;IACnB,IAAI,CAAC,CAAAL,SAAU,CAACW,SAAS,GAAGkB,SAAS;IACrC,IAAI,CAAC,CAAA7B,SAAU,CAACc,OAAO,GAAGe,SAAS;IACnC,IAAI,CAAC,CAAArB,SAAU,CAACkD,KAAK,EAAE;IACvB,KAAK,MAAMzC,OAAO,IAAI,IAAI,CAAC,CAAAd,QAAS,CAACwD,MAAM,EAAE,EAAE;MAC7C1C,OAAO,CAACiC,QAAQ,EAAE;IACpB;IACA,IAAI,CAAC,CAAA/C,QAAS,CAACuD,KAAK,EAAE;IACtB,IAAI,CAACX,IAAI,CAAC1D,eAAe,CAACuE,YAAY,EAAE/B,SAAS,CAAC;EACpD;EAEAgC,OAAOA,CAAA;IACL,IAAI,CAAC,CAAA9C,OAAQ,EAAE;IACf,IAAI,CAAC,CAAAf,SAAU,CAAC8D,KAAK,EAAE;EACzB;EAEA;;;EAGAC,cAAcA,CAACC,QAAgB;IAC7B,OAAO,CAAC,IAAI,CAAC,CAAA1D,gBAAiB,CAAC2D,GAAG,CAACD,QAAQ,CAAC;EAC9C;EAEA;;;EAGA,MAAME,cAAcA,CAClBtB,UAA8B,EAC9BuB,oBAAoB,GAAG,IAAI;IAE3B,IAAI,CAACA,oBAAoB,EAAE;MACzB,IAAI,CAAC,CAAA7D,gBAAiB,CAAC8D,GAAG,CAACxB,UAAU,CAACoB,QAAQ,CAAC;IACjD;IACA,MAAM;MAAC1C;IAAS,CAAC,GAAG,MAAM,IAAI,CAACE,IAAI,CAAC,uBAAuB,EAAE;MAC3DwC,QAAQ,EAAEpB,UAAU,CAACoB,QAAQ;MAC7BK,OAAO,EAAE;KACV,CAAC;IACF,IAAI,CAAC,CAAA/D,gBAAiB,CAAC6C,MAAM,CAACP,UAAU,CAACoB,QAAQ,CAAC;IAClD,MAAM/C,OAAO,GAAG,IAAI,CAAC,CAAAd,QAAS,CAACoB,GAAG,CAACD,SAAS,CAAC;IAC7C,IAAI,CAACL,OAAO,EAAE;MACZ,MAAM,IAAIe,KAAK,CAAC,6BAA6B,CAAC;IAChD;IACA,OAAOf,OAAO;EAChB;EAEA;;;;EAIA,MAAMqD,aAAaA,CACjB1B,UAAsC;IAEtC,OAAO,MAAM,IAAI,CAACsB,cAAc,CAACtB,UAAU,EAAE,KAAK,CAAC;EACrD;EAEA;;;EAGA2B,wBAAwBA,CAAA;IACtB,MAAMf,MAAM,GAAY,EAAE;IAC1BA,MAAM,CAACgB,IAAI,CAAC,GAAG,IAAI,CAAC,CAAAhE,SAAU,CAAC+D,wBAAwB,EAAE,CAAC;IAC1D,KAAK,MAAMtD,OAAO,IAAI,IAAI,CAAC,CAAAd,QAAS,CAACwD,MAAM,EAAE,EAAE;MAC7CH,MAAM,CAACgB,IAAI,CAAC,GAAGvD,OAAO,CAACsD,wBAAwB,EAAE,CAAC;IACpD;IACA,OAAOf,MAAM;EACf;;AAGF;;;AAGA,OAAM,SAAUiB,mBAAmBA,CAACpB,KAAY;EAC9C,OAAOA,KAAK,YAAY7D,gBAAgB;AAC1C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}