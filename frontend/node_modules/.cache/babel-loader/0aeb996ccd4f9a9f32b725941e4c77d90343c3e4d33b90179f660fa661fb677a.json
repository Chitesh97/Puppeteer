{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Deferred } from '../util/Deferred.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { stringifyFunction } from '../util/Function.js';\nimport { TimeoutError } from './Errors.js';\nimport { LazyArg } from './LazyArg.js';\n/**\n * @internal\n */\nexport class WaitTask {\n  #world;\n  #polling;\n  #root;\n  #fn;\n  #args;\n  #timeout;\n  #genericError = new Error('Waiting failed');\n  #timeoutError;\n  #result = Deferred.create();\n  #poller;\n  #signal;\n  #reruns = [];\n  constructor(world, options, fn, ...args) {\n    this.#world = world;\n    this.#polling = options.polling;\n    this.#root = options.root;\n    this.#signal = options.signal;\n    this.#signal?.addEventListener('abort', this.#onAbortSignal, {\n      once: true\n    });\n    switch (typeof fn) {\n      case 'string':\n        this.#fn = `() => {return (${fn});}`;\n        break;\n      default:\n        this.#fn = stringifyFunction(fn);\n        break;\n    }\n    this.#args = args;\n    this.#world.taskManager.add(this);\n    if (options.timeout) {\n      this.#timeoutError = new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`);\n      this.#timeout = setTimeout(() => {\n        void this.terminate(this.#timeoutError);\n      }, options.timeout);\n    }\n    void this.rerun();\n  }\n  get result() {\n    return this.#result.valueOrThrow();\n  }\n  async rerun() {\n    for (const prev of this.#reruns) {\n      prev.abort();\n    }\n    this.#reruns.length = 0;\n    const controller = new AbortController();\n    this.#reruns.push(controller);\n    try {\n      switch (this.#polling) {\n        case 'raf':\n          this.#poller = await this.#world.evaluateHandle(({\n            RAFPoller,\n            createFunction\n          }, fn, ...args) => {\n            const fun = createFunction(fn);\n            return new RAFPoller(() => {\n              return fun(...args);\n            });\n          }, LazyArg.create(context => {\n            return context.puppeteerUtil;\n          }), this.#fn, ...this.#args);\n          break;\n        case 'mutation':\n          this.#poller = await this.#world.evaluateHandle(({\n            MutationPoller,\n            createFunction\n          }, root, fn, ...args) => {\n            const fun = createFunction(fn);\n            return new MutationPoller(() => {\n              return fun(...args);\n            }, root || document);\n          }, LazyArg.create(context => {\n            return context.puppeteerUtil;\n          }), this.#root, this.#fn, ...this.#args);\n          break;\n        default:\n          this.#poller = await this.#world.evaluateHandle(({\n            IntervalPoller,\n            createFunction\n          }, ms, fn, ...args) => {\n            const fun = createFunction(fn);\n            return new IntervalPoller(() => {\n              return fun(...args);\n            }, ms);\n          }, LazyArg.create(context => {\n            return context.puppeteerUtil;\n          }), this.#polling, this.#fn, ...this.#args);\n          break;\n      }\n      await this.#poller.evaluate(poller => {\n        void poller.start();\n      });\n      const result = await this.#poller.evaluateHandle(poller => {\n        return poller.result();\n      });\n      this.#result.resolve(result);\n      await this.terminate();\n    } catch (error) {\n      if (controller.signal.aborted) {\n        return;\n      }\n      const badError = this.getBadError(error);\n      if (badError) {\n        this.#genericError.cause = badError;\n        await this.terminate(this.#genericError);\n      }\n    }\n  }\n  async terminate(error) {\n    this.#world.taskManager.delete(this);\n    this.#signal?.removeEventListener('abort', this.#onAbortSignal);\n    clearTimeout(this.#timeout);\n    if (error && !this.#result.finished()) {\n      this.#result.reject(error);\n    }\n    if (this.#poller) {\n      try {\n        await this.#poller.evaluate(async poller => {\n          await poller.stop();\n        });\n        if (this.#poller) {\n          await this.#poller.dispose();\n          this.#poller = undefined;\n        }\n      } catch {\n        // Ignore errors since they most likely come from low-level cleanup.\n      }\n    }\n  }\n  /**\n   * Not all errors lead to termination. They usually imply we need to rerun the task.\n   */\n  getBadError(error) {\n    if (isErrorLike(error)) {\n      // When frame is detached the task should have been terminated by the IsolatedWorld.\n      // This can fail if we were adding this task while the frame was detached,\n      // so we terminate here instead.\n      if (error.message.includes('Execution context is not available in detached frame')) {\n        return new Error('Waiting failed: Frame detached');\n      }\n      // When the page is navigated, the promise is rejected.\n      // We will try again in the new execution context.\n      if (error.message.includes('Execution context was destroyed')) {\n        return;\n      }\n      // We could have tried to evaluate in a context which was already\n      // destroyed.\n      if (error.message.includes('Cannot find context with specified id')) {\n        return;\n      }\n      // Errors coming from WebDriver BiDi. TODO: Adjust messages after\n      // https://github.com/w3c/webdriver-bidi/issues/540 is resolved.\n      if (error.message.includes('DiscardedBrowsingContextError')) {\n        return;\n      }\n      return error;\n    }\n    return new Error('WaitTask failed with an error', {\n      cause: error\n    });\n  }\n  #onAbortSignal = () => {\n    void this.terminate(this.#signal?.reason);\n  };\n}\n/**\n * @internal\n */\nexport class TaskManager {\n  #tasks = new Set();\n  add(task) {\n    this.#tasks.add(task);\n  }\n  delete(task) {\n    this.#tasks.delete(task);\n  }\n  terminateAll(error) {\n    for (const task of this.#tasks) {\n      void task.terminate(error);\n    }\n    this.#tasks.clear();\n  }\n  async rerunAll() {\n    await Promise.all([...this.#tasks].map(task => {\n      return task.rerun();\n    }));\n  }\n}","map":{"version":3,"names":["Deferred","isErrorLike","stringifyFunction","TimeoutError","LazyArg","WaitTask","world","polling","root","fn","args","timeout","genericError","Error","timeoutError","result","create","poller","signal","reruns","constructor","options","addEventListener","onAbortSignal","once","taskManager","add","setTimeout","terminate","rerun","valueOrThrow","prev","abort","length","controller","AbortController","push","evaluateHandle","RAFPoller","createFunction","fun","context","puppeteerUtil","MutationPoller","document","IntervalPoller","ms","evaluate","start","resolve","error","aborted","badError","getBadError","cause","delete","removeEventListener","clearTimeout","finished","reject","stop","dispose","undefined","message","includes","#onAbortSignal","reason","TaskManager","tasks","Set","task","terminateAll","clear","rerunAll","Promise","all","map"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/common/WaitTask.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport type {Realm} from '../api/Realm.js';\nimport type {Poller} from '../injected/Poller.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\nimport {stringifyFunction} from '../util/Function.js';\n\nimport {TimeoutError} from './Errors.js';\nimport {LazyArg} from './LazyArg.js';\nimport type {HandleFor} from './types.js';\n\n/**\n * @internal\n */\nexport interface WaitTaskOptions {\n  polling: 'raf' | 'mutation' | number;\n  root?: ElementHandle<Node>;\n  timeout: number;\n  signal?: AbortSignal;\n}\n\n/**\n * @internal\n */\nexport class WaitTask<T = unknown> {\n  #world: Realm;\n  #polling: 'raf' | 'mutation' | number;\n  #root?: ElementHandle<Node>;\n\n  #fn: string;\n  #args: unknown[];\n\n  #timeout?: NodeJS.Timeout;\n  #genericError = new Error('Waiting failed');\n  #timeoutError?: TimeoutError;\n\n  #result = Deferred.create<HandleFor<T>>();\n\n  #poller?: JSHandle<Poller<T>>;\n  #signal?: AbortSignal;\n  #reruns: AbortController[] = [];\n\n  constructor(\n    world: Realm,\n    options: WaitTaskOptions,\n    fn: ((...args: unknown[]) => Promise<T>) | string,\n    ...args: unknown[]\n  ) {\n    this.#world = world;\n    this.#polling = options.polling;\n    this.#root = options.root;\n    this.#signal = options.signal;\n    this.#signal?.addEventListener('abort', this.#onAbortSignal, {\n      once: true,\n    });\n\n    switch (typeof fn) {\n      case 'string':\n        this.#fn = `() => {return (${fn});}`;\n        break;\n      default:\n        this.#fn = stringifyFunction(fn);\n        break;\n    }\n    this.#args = args;\n\n    this.#world.taskManager.add(this);\n\n    if (options.timeout) {\n      this.#timeoutError = new TimeoutError(\n        `Waiting failed: ${options.timeout}ms exceeded`,\n      );\n      this.#timeout = setTimeout(() => {\n        void this.terminate(this.#timeoutError);\n      }, options.timeout);\n    }\n\n    void this.rerun();\n  }\n\n  get result(): Promise<HandleFor<T>> {\n    return this.#result.valueOrThrow();\n  }\n\n  async rerun(): Promise<void> {\n    for (const prev of this.#reruns) {\n      prev.abort();\n    }\n    this.#reruns.length = 0;\n    const controller = new AbortController();\n    this.#reruns.push(controller);\n    try {\n      switch (this.#polling) {\n        case 'raf':\n          this.#poller = await this.#world.evaluateHandle(\n            ({RAFPoller, createFunction}, fn, ...args) => {\n              const fun = createFunction(fn);\n              return new RAFPoller(() => {\n                return fun(...args) as Promise<T>;\n              });\n            },\n            LazyArg.create(context => {\n              return context.puppeteerUtil;\n            }),\n            this.#fn,\n            ...this.#args,\n          );\n          break;\n        case 'mutation':\n          this.#poller = await this.#world.evaluateHandle(\n            ({MutationPoller, createFunction}, root, fn, ...args) => {\n              const fun = createFunction(fn);\n              return new MutationPoller(() => {\n                return fun(...args) as Promise<T>;\n              }, root || document);\n            },\n            LazyArg.create(context => {\n              return context.puppeteerUtil;\n            }),\n            this.#root,\n            this.#fn,\n            ...this.#args,\n          );\n          break;\n        default:\n          this.#poller = await this.#world.evaluateHandle(\n            ({IntervalPoller, createFunction}, ms, fn, ...args) => {\n              const fun = createFunction(fn);\n              return new IntervalPoller(() => {\n                return fun(...args) as Promise<T>;\n              }, ms);\n            },\n            LazyArg.create(context => {\n              return context.puppeteerUtil;\n            }),\n            this.#polling,\n            this.#fn,\n            ...this.#args,\n          );\n          break;\n      }\n\n      await this.#poller.evaluate(poller => {\n        void poller.start();\n      });\n\n      const result = await this.#poller.evaluateHandle(poller => {\n        return poller.result();\n      });\n      this.#result.resolve(result);\n\n      await this.terminate();\n    } catch (error) {\n      if (controller.signal.aborted) {\n        return;\n      }\n      const badError = this.getBadError(error);\n      if (badError) {\n        this.#genericError.cause = badError;\n        await this.terminate(this.#genericError);\n      }\n    }\n  }\n\n  async terminate(error?: Error): Promise<void> {\n    this.#world.taskManager.delete(this);\n\n    this.#signal?.removeEventListener('abort', this.#onAbortSignal);\n\n    clearTimeout(this.#timeout);\n\n    if (error && !this.#result.finished()) {\n      this.#result.reject(error);\n    }\n\n    if (this.#poller) {\n      try {\n        await this.#poller.evaluate(async poller => {\n          await poller.stop();\n        });\n        if (this.#poller) {\n          await this.#poller.dispose();\n          this.#poller = undefined;\n        }\n      } catch {\n        // Ignore errors since they most likely come from low-level cleanup.\n      }\n    }\n  }\n\n  /**\n   * Not all errors lead to termination. They usually imply we need to rerun the task.\n   */\n  getBadError(error: unknown): Error | undefined {\n    if (isErrorLike(error)) {\n      // When frame is detached the task should have been terminated by the IsolatedWorld.\n      // This can fail if we were adding this task while the frame was detached,\n      // so we terminate here instead.\n      if (\n        error.message.includes(\n          'Execution context is not available in detached frame',\n        )\n      ) {\n        return new Error('Waiting failed: Frame detached');\n      }\n\n      // When the page is navigated, the promise is rejected.\n      // We will try again in the new execution context.\n      if (error.message.includes('Execution context was destroyed')) {\n        return;\n      }\n\n      // We could have tried to evaluate in a context which was already\n      // destroyed.\n      if (error.message.includes('Cannot find context with specified id')) {\n        return;\n      }\n\n      // Errors coming from WebDriver BiDi. TODO: Adjust messages after\n      // https://github.com/w3c/webdriver-bidi/issues/540 is resolved.\n      if (error.message.includes('DiscardedBrowsingContextError')) {\n        return;\n      }\n\n      return error;\n    }\n\n    return new Error('WaitTask failed with an error', {\n      cause: error,\n    });\n  }\n\n  #onAbortSignal = () => {\n    void this.terminate(this.#signal?.reason);\n  };\n}\n\n/**\n * @internal\n */\nexport class TaskManager {\n  #tasks: Set<WaitTask> = new Set<WaitTask>();\n\n  add(task: WaitTask<any>): void {\n    this.#tasks.add(task);\n  }\n\n  delete(task: WaitTask<any>): void {\n    this.#tasks.delete(task);\n  }\n\n  terminateAll(error?: Error): void {\n    for (const task of this.#tasks) {\n      void task.terminate(error);\n    }\n    this.#tasks.clear();\n  }\n\n  async rerunAll(): Promise<void> {\n    await Promise.all(\n      [...this.#tasks].map(task => {\n        return task.rerun();\n      }),\n    );\n  }\n}\n"],"mappings":"AAAA;;;;;AAUA,SAAQA,QAAQ,QAAO,qBAAqB;AAC5C,SAAQC,WAAW,QAAO,sBAAsB;AAChD,SAAQC,iBAAiB,QAAO,qBAAqB;AAErD,SAAQC,YAAY,QAAO,aAAa;AACxC,SAAQC,OAAO,QAAO,cAAc;AAapC;;;AAGA,OAAM,MAAOC,QAAQ;EACnB,CAAAC,KAAM;EACN,CAAAC,OAAQ;EACR,CAAAC,IAAK;EAEL,CAAAC,EAAG;EACH,CAAAC,IAAK;EAEL,CAAAC,OAAQ;EACR,CAAAC,YAAa,GAAG,IAAIC,KAAK,CAAC,gBAAgB,CAAC;EAC3C,CAAAC,YAAa;EAEb,CAAAC,MAAO,GAAGf,QAAQ,CAACgB,MAAM,EAAgB;EAEzC,CAAAC,MAAO;EACP,CAAAC,MAAO;EACP,CAAAC,MAAO,GAAsB,EAAE;EAE/BC,YACEd,KAAY,EACZe,OAAwB,EACxBZ,EAAiD,EACjD,GAAGC,IAAe;IAElB,IAAI,CAAC,CAAAJ,KAAM,GAAGA,KAAK;IACnB,IAAI,CAAC,CAAAC,OAAQ,GAAGc,OAAO,CAACd,OAAO;IAC/B,IAAI,CAAC,CAAAC,IAAK,GAAGa,OAAO,CAACb,IAAI;IACzB,IAAI,CAAC,CAAAU,MAAO,GAAGG,OAAO,CAACH,MAAM;IAC7B,IAAI,CAAC,CAAAA,MAAO,EAAEI,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAAC,aAAc,EAAE;MAC3DC,IAAI,EAAE;KACP,CAAC;IAEF,QAAQ,OAAOf,EAAE;MACf,KAAK,QAAQ;QACX,IAAI,CAAC,CAAAA,EAAG,GAAG,kBAAkBA,EAAE,KAAK;QACpC;MACF;QACE,IAAI,CAAC,CAAAA,EAAG,GAAGP,iBAAiB,CAACO,EAAE,CAAC;QAChC;IACJ;IACA,IAAI,CAAC,CAAAC,IAAK,GAAGA,IAAI;IAEjB,IAAI,CAAC,CAAAJ,KAAM,CAACmB,WAAW,CAACC,GAAG,CAAC,IAAI,CAAC;IAEjC,IAAIL,OAAO,CAACV,OAAO,EAAE;MACnB,IAAI,CAAC,CAAAG,YAAa,GAAG,IAAIX,YAAY,CACnC,mBAAmBkB,OAAO,CAACV,OAAO,aAAa,CAChD;MACD,IAAI,CAAC,CAAAA,OAAQ,GAAGgB,UAAU,CAAC,MAAK;QAC9B,KAAK,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC,CAAAd,YAAa,CAAC;MACzC,CAAC,EAAEO,OAAO,CAACV,OAAO,CAAC;IACrB;IAEA,KAAK,IAAI,CAACkB,KAAK,EAAE;EACnB;EAEA,IAAId,MAAMA,CAAA;IACR,OAAO,IAAI,CAAC,CAAAA,MAAO,CAACe,YAAY,EAAE;EACpC;EAEA,MAAMD,KAAKA,CAAA;IACT,KAAK,MAAME,IAAI,IAAI,IAAI,CAAC,CAAAZ,MAAO,EAAE;MAC/BY,IAAI,CAACC,KAAK,EAAE;IACd;IACA,IAAI,CAAC,CAAAb,MAAO,CAACc,MAAM,GAAG,CAAC;IACvB,MAAMC,UAAU,GAAG,IAAIC,eAAe,EAAE;IACxC,IAAI,CAAC,CAAAhB,MAAO,CAACiB,IAAI,CAACF,UAAU,CAAC;IAC7B,IAAI;MACF,QAAQ,IAAI,CAAC,CAAA3B,OAAQ;QACnB,KAAK,KAAK;UACR,IAAI,CAAC,CAAAU,MAAO,GAAG,MAAM,IAAI,CAAC,CAAAX,KAAM,CAAC+B,cAAc,CAC7C,CAAC;YAACC,SAAS;YAAEC;UAAc,CAAC,EAAE9B,EAAE,EAAE,GAAGC,IAAI,KAAI;YAC3C,MAAM8B,GAAG,GAAGD,cAAc,CAAC9B,EAAE,CAAC;YAC9B,OAAO,IAAI6B,SAAS,CAAC,MAAK;cACxB,OAAOE,GAAG,CAAC,GAAG9B,IAAI,CAAe;YACnC,CAAC,CAAC;UACJ,CAAC,EACDN,OAAO,CAACY,MAAM,CAACyB,OAAO,IAAG;YACvB,OAAOA,OAAO,CAACC,aAAa;UAC9B,CAAC,CAAC,EACF,IAAI,CAAC,CAAAjC,EAAG,EACR,GAAG,IAAI,CAAC,CAAAC,IAAK,CACd;UACD;QACF,KAAK,UAAU;UACb,IAAI,CAAC,CAAAO,MAAO,GAAG,MAAM,IAAI,CAAC,CAAAX,KAAM,CAAC+B,cAAc,CAC7C,CAAC;YAACM,cAAc;YAAEJ;UAAc,CAAC,EAAE/B,IAAI,EAAEC,EAAE,EAAE,GAAGC,IAAI,KAAI;YACtD,MAAM8B,GAAG,GAAGD,cAAc,CAAC9B,EAAE,CAAC;YAC9B,OAAO,IAAIkC,cAAc,CAAC,MAAK;cAC7B,OAAOH,GAAG,CAAC,GAAG9B,IAAI,CAAe;YACnC,CAAC,EAAEF,IAAI,IAAIoC,QAAQ,CAAC;UACtB,CAAC,EACDxC,OAAO,CAACY,MAAM,CAACyB,OAAO,IAAG;YACvB,OAAOA,OAAO,CAACC,aAAa;UAC9B,CAAC,CAAC,EACF,IAAI,CAAC,CAAAlC,IAAK,EACV,IAAI,CAAC,CAAAC,EAAG,EACR,GAAG,IAAI,CAAC,CAAAC,IAAK,CACd;UACD;QACF;UACE,IAAI,CAAC,CAAAO,MAAO,GAAG,MAAM,IAAI,CAAC,CAAAX,KAAM,CAAC+B,cAAc,CAC7C,CAAC;YAACQ,cAAc;YAAEN;UAAc,CAAC,EAAEO,EAAE,EAAErC,EAAE,EAAE,GAAGC,IAAI,KAAI;YACpD,MAAM8B,GAAG,GAAGD,cAAc,CAAC9B,EAAE,CAAC;YAC9B,OAAO,IAAIoC,cAAc,CAAC,MAAK;cAC7B,OAAOL,GAAG,CAAC,GAAG9B,IAAI,CAAe;YACnC,CAAC,EAAEoC,EAAE,CAAC;UACR,CAAC,EACD1C,OAAO,CAACY,MAAM,CAACyB,OAAO,IAAG;YACvB,OAAOA,OAAO,CAACC,aAAa;UAC9B,CAAC,CAAC,EACF,IAAI,CAAC,CAAAnC,OAAQ,EACb,IAAI,CAAC,CAAAE,EAAG,EACR,GAAG,IAAI,CAAC,CAAAC,IAAK,CACd;UACD;MACJ;MAEA,MAAM,IAAI,CAAC,CAAAO,MAAO,CAAC8B,QAAQ,CAAC9B,MAAM,IAAG;QACnC,KAAKA,MAAM,CAAC+B,KAAK,EAAE;MACrB,CAAC,CAAC;MAEF,MAAMjC,MAAM,GAAG,MAAM,IAAI,CAAC,CAAAE,MAAO,CAACoB,cAAc,CAACpB,MAAM,IAAG;QACxD,OAAOA,MAAM,CAACF,MAAM,EAAE;MACxB,CAAC,CAAC;MACF,IAAI,CAAC,CAAAA,MAAO,CAACkC,OAAO,CAAClC,MAAM,CAAC;MAE5B,MAAM,IAAI,CAACa,SAAS,EAAE;IACxB,CAAC,CAAC,OAAOsB,KAAK,EAAE;MACd,IAAIhB,UAAU,CAAChB,MAAM,CAACiC,OAAO,EAAE;QAC7B;MACF;MACA,MAAMC,QAAQ,GAAG,IAAI,CAACC,WAAW,CAACH,KAAK,CAAC;MACxC,IAAIE,QAAQ,EAAE;QACZ,IAAI,CAAC,CAAAxC,YAAa,CAAC0C,KAAK,GAAGF,QAAQ;QACnC,MAAM,IAAI,CAACxB,SAAS,CAAC,IAAI,CAAC,CAAAhB,YAAa,CAAC;MAC1C;IACF;EACF;EAEA,MAAMgB,SAASA,CAACsB,KAAa;IAC3B,IAAI,CAAC,CAAA5C,KAAM,CAACmB,WAAW,CAAC8B,MAAM,CAAC,IAAI,CAAC;IAEpC,IAAI,CAAC,CAAArC,MAAO,EAAEsC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAAjC,aAAc,CAAC;IAE/DkC,YAAY,CAAC,IAAI,CAAC,CAAA9C,OAAQ,CAAC;IAE3B,IAAIuC,KAAK,IAAI,CAAC,IAAI,CAAC,CAAAnC,MAAO,CAAC2C,QAAQ,EAAE,EAAE;MACrC,IAAI,CAAC,CAAA3C,MAAO,CAAC4C,MAAM,CAACT,KAAK,CAAC;IAC5B;IAEA,IAAI,IAAI,CAAC,CAAAjC,MAAO,EAAE;MAChB,IAAI;QACF,MAAM,IAAI,CAAC,CAAAA,MAAO,CAAC8B,QAAQ,CAAC,MAAM9B,MAAM,IAAG;UACzC,MAAMA,MAAM,CAAC2C,IAAI,EAAE;QACrB,CAAC,CAAC;QACF,IAAI,IAAI,CAAC,CAAA3C,MAAO,EAAE;UAChB,MAAM,IAAI,CAAC,CAAAA,MAAO,CAAC4C,OAAO,EAAE;UAC5B,IAAI,CAAC,CAAA5C,MAAO,GAAG6C,SAAS;QAC1B;MACF,CAAC,CAAC,MAAM;QACN;MAAA;IAEJ;EACF;EAEA;;;EAGAT,WAAWA,CAACH,KAAc;IACxB,IAAIjD,WAAW,CAACiD,KAAK,CAAC,EAAE;MACtB;MACA;MACA;MACA,IACEA,KAAK,CAACa,OAAO,CAACC,QAAQ,CACpB,sDAAsD,CACvD,EACD;QACA,OAAO,IAAInD,KAAK,CAAC,gCAAgC,CAAC;MACpD;MAEA;MACA;MACA,IAAIqC,KAAK,CAACa,OAAO,CAACC,QAAQ,CAAC,iCAAiC,CAAC,EAAE;QAC7D;MACF;MAEA;MACA;MACA,IAAId,KAAK,CAACa,OAAO,CAACC,QAAQ,CAAC,uCAAuC,CAAC,EAAE;QACnE;MACF;MAEA;MACA;MACA,IAAId,KAAK,CAACa,OAAO,CAACC,QAAQ,CAAC,+BAA+B,CAAC,EAAE;QAC3D;MACF;MAEA,OAAOd,KAAK;IACd;IAEA,OAAO,IAAIrC,KAAK,CAAC,+BAA+B,EAAE;MAChDyC,KAAK,EAAEJ;KACR,CAAC;EACJ;EAEA,CAAA3B,aAAc,GAAG0C,CAAA,KAAK;IACpB,KAAK,IAAI,CAACrC,SAAS,CAAC,IAAI,CAAC,CAAAV,MAAO,EAAEgD,MAAM,CAAC;EAC3C,CAAC;;AAGH;;;AAGA,OAAM,MAAOC,WAAW;EACtB,CAAAC,KAAM,GAAkB,IAAIC,GAAG,EAAY;EAE3C3C,GAAGA,CAAC4C,IAAmB;IACrB,IAAI,CAAC,CAAAF,KAAM,CAAC1C,GAAG,CAAC4C,IAAI,CAAC;EACvB;EAEAf,MAAMA,CAACe,IAAmB;IACxB,IAAI,CAAC,CAAAF,KAAM,CAACb,MAAM,CAACe,IAAI,CAAC;EAC1B;EAEAC,YAAYA,CAACrB,KAAa;IACxB,KAAK,MAAMoB,IAAI,IAAI,IAAI,CAAC,CAAAF,KAAM,EAAE;MAC9B,KAAKE,IAAI,CAAC1C,SAAS,CAACsB,KAAK,CAAC;IAC5B;IACA,IAAI,CAAC,CAAAkB,KAAM,CAACI,KAAK,EAAE;EACrB;EAEA,MAAMC,QAAQA,CAAA;IACZ,MAAMC,OAAO,CAACC,GAAG,CACf,CAAC,GAAG,IAAI,CAAC,CAAAP,KAAM,CAAC,CAACQ,GAAG,CAACN,IAAI,IAAG;MAC1B,OAAOA,IAAI,CAACzC,KAAK,EAAE;IACrB,CAAC,CAAC,CACH;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}