{"ast":null,"code":"const tar = require('tar-stream');\nconst pump = require('pump');\nconst fs = require('fs');\nconst path = require('path');\nconst win32 = (global.Bare ? global.Bare.platform : process.platform) === 'win32';\nexports.pack = function pack(cwd, opts) {\n  if (!cwd) cwd = '.';\n  if (!opts) opts = {};\n  const xfs = opts.fs || fs;\n  const ignore = opts.ignore || opts.filter || noop;\n  const mapStream = opts.mapStream || echo;\n  const statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);\n  const strict = opts.strict !== false;\n  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();\n  const pack = opts.pack || tar.pack();\n  const finish = opts.finish || noop;\n  let map = opts.map || noop;\n  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;\n  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;\n  if (opts.strip) map = strip(map, opts.strip);\n  if (opts.readable) {\n    dmode |= parseInt(555, 8);\n    fmode |= parseInt(444, 8);\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8);\n    fmode |= parseInt(222, 8);\n  }\n  onnextentry();\n  function onsymlink(filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err);\n      header.linkname = normalize(linkname);\n      pack.entry(header, onnextentry);\n    });\n  }\n  function onstat(err, filename, stat) {\n    if (pack.destroyed) return;\n    if (err) return pack.destroy(err);\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize();\n      return finish(pack);\n    }\n    if (stat.isSocket()) return onnextentry(); // tar does not support sockets...\n\n    let header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    };\n    if (stat.isDirectory()) {\n      header.size = 0;\n      header.type = 'directory';\n      header = map(header) || header;\n      return pack.entry(header, onnextentry);\n    }\n    if (stat.isSymbolicLink()) {\n      header.size = 0;\n      header.type = 'symlink';\n      header = map(header) || header;\n      return onsymlink(filename, header);\n    }\n\n    // TODO: add fifo etc...\n\n    header = map(header) || header;\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename));\n      return onnextentry();\n    }\n    const entry = pack.entry(header, onnextentry);\n    const rs = mapStream(xfs.createReadStream(path.join(cwd, filename), {\n      start: 0,\n      end: header.size > 0 ? header.size - 1 : header.size\n    }), header);\n    rs.on('error', function (err) {\n      // always forward errors on destroy\n      entry.destroy(err);\n    });\n    pump(rs, entry);\n  }\n  function onnextentry(err) {\n    if (err) return pack.destroy(err);\n    statNext(onstat);\n  }\n  return pack;\n};\nfunction head(list) {\n  return list.length ? list[list.length - 1] : null;\n}\nfunction processGetuid() {\n  return !global.Bare && process.getuid ? process.getuid() : -1;\n}\nfunction processUmask() {\n  return !global.Bare && process.umask ? process.umask() : 0;\n}\nexports.extract = function extract(cwd, opts) {\n  if (!cwd) cwd = '.';\n  if (!opts) opts = {};\n  cwd = path.resolve(cwd);\n  const xfs = opts.fs || fs;\n  const ignore = opts.ignore || opts.filter || noop;\n  const mapStream = opts.mapStream || echo;\n  const own = opts.chown !== false && !win32 && processGetuid() === 0;\n  const extract = opts.extract || tar.extract();\n  const stack = [];\n  const now = new Date();\n  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();\n  const strict = opts.strict !== false;\n  const validateSymLinks = opts.validateSymlinks !== false;\n  let map = opts.map || noop;\n  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;\n  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;\n  if (opts.strip) map = strip(map, opts.strip);\n  if (opts.readable) {\n    dmode |= parseInt(555, 8);\n    fmode |= parseInt(444, 8);\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8);\n    fmode |= parseInt(222, 8);\n  }\n  extract.on('entry', onentry);\n  if (opts.finish) extract.on('finish', opts.finish);\n  return extract;\n  function onentry(header, stream, next) {\n    header = map(header) || header;\n    header.name = normalize(header.name);\n    const name = path.join(cwd, path.join('/', header.name));\n    if (ignore(name, header)) {\n      stream.resume();\n      return next();\n    }\n    const dir = path.join(name, '.') === path.join(cwd, '.') ? cwd : path.dirname(name);\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err);\n      if (!valid) return next(new Error(dir + ' is not a valid path'));\n      if (header.type === 'directory') {\n        stack.push([name, header.mtime]);\n        return mkdirfix(name, {\n          fs: xfs,\n          own,\n          uid: header.uid,\n          gid: header.gid,\n          mode: header.mode\n        }, stat);\n      }\n      mkdirfix(dir, {\n        fs: xfs,\n        own,\n        uid: header.uid,\n        gid: header.gid,\n        // normally, the folders with rights and owner should be part of the TAR file\n        // if this is not the case, create folder for same user as file and with\n        // standard permissions of 0o755 (rwxr-xr-x)\n        mode: 0o755\n      }, function (err) {\n        if (err) return next(err);\n        switch (header.type) {\n          case 'file':\n            return onfile();\n          case 'link':\n            return onlink();\n          case 'symlink':\n            return onsymlink();\n        }\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'));\n        stream.resume();\n        next();\n      });\n    });\n    function stat(err) {\n      if (err) return next(err);\n      utimes(name, header, function (err) {\n        if (err) return next(err);\n        if (win32) return next();\n        chperm(name, header, next);\n      });\n    }\n    function onsymlink() {\n      if (win32) return next(); // skip symlinks on win for now before it can be tested\n      xfs.unlink(name, function () {\n        const dst = path.resolve(path.dirname(name), header.linkname);\n        if (!inCwd(dst) && validateSymLinks) return next(new Error(name + ' is not a valid symlink'));\n        xfs.symlink(header.linkname, name, stat);\n      });\n    }\n    function onlink() {\n      if (win32) return next(); // skip links on win for now before it can be tested\n      xfs.unlink(name, function () {\n        const link = path.join(cwd, path.join('/', header.linkname));\n        fs.realpath(link, function (err, dst) {\n          if (err || !inCwd(dst)) return next(new Error(name + ' is not a valid hardlink'));\n          xfs.link(dst, name, function (err) {\n            if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n              stream = xfs.createReadStream(dst);\n              return onfile();\n            }\n            stat(err);\n          });\n        });\n      });\n    }\n    function inCwd(dst) {\n      return dst.startsWith(cwd);\n    }\n    function onfile() {\n      const ws = xfs.createWriteStream(name);\n      const rs = mapStream(stream, header);\n      ws.on('error', function (err) {\n        // always forward errors on destroy\n        rs.destroy(err);\n      });\n      pump(rs, ws, function (err) {\n        if (err) return next(err);\n        ws.on('close', stat);\n      });\n    }\n  }\n  function utimesParent(name, cb) {\n    // we just set the mtime on the parent dir again everytime we write an entry\n    let top;\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop();\n    if (!top) return cb();\n    xfs.utimes(top[0], now, top[1], cb);\n  }\n  function utimes(name, header, cb) {\n    if (opts.utimes === false) return cb();\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb);\n    if (header.type === 'symlink') return utimesParent(name, cb); // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err);\n      utimesParent(name, cb);\n    });\n  }\n  function chperm(name, header, cb) {\n    const link = header.type === 'symlink';\n\n    /* eslint-disable n/no-deprecated-api */\n    const chmod = link ? xfs.lchmod : xfs.chmod;\n    const chown = link ? xfs.lchown : xfs.chown;\n    /* eslint-enable n/no-deprecated-api */\n\n    if (!chmod) return cb();\n    const mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask;\n    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown);else onchown(null);\n    function onchown(err) {\n      if (err) return cb(err);\n      if (!chmod) return cb();\n      chmod.call(xfs, name, mode, cb);\n    }\n  }\n  function mkdirfix(name, opts, cb) {\n    // when mkdir is called on an existing directory, the permissions\n    // will be overwritten (?), to avoid this we check for its existance first\n    xfs.stat(name, function (err) {\n      if (!err) return cb(null);\n      if (err.code !== 'ENOENT') return cb(err);\n      xfs.mkdir(name, {\n        mode: opts.mode,\n        recursive: true\n      }, function (err, made) {\n        if (err) return cb(err);\n        chperm(name, opts, cb);\n      });\n    });\n  }\n};\nfunction validate(fs, name, root, cb) {\n  if (name === root) return cb(null, true);\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT' && err.code !== 'EPERM') return cb(err);\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb);\n    cb(null, false);\n  });\n}\nfunction noop() {}\nfunction echo(name) {\n  return name;\n}\nfunction normalize(name) {\n  return win32 ? name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_') : name;\n}\nfunction statAll(fs, stat, cwd, ignore, entries, sort) {\n  if (!entries) entries = ['.'];\n  const queue = entries.slice(0);\n  return function loop(callback) {\n    if (!queue.length) return callback(null);\n    const next = queue.shift();\n    const nextAbs = path.join(cwd, next);\n    stat.call(fs, nextAbs, function (err, stat) {\n      // ignore errors if the files were deleted while buffering\n      if (err) return callback(entries.indexOf(next) === -1 && err.code === 'ENOENT' ? null : err);\n      if (!stat.isDirectory()) return callback(null, next, stat);\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err);\n        if (sort) files.sort();\n        for (let i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]));\n        }\n        callback(null, next, stat);\n      });\n    });\n  };\n}\nfunction strip(map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/');\n    const linkname = header.linkname;\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/');\n    }\n    return map(header);\n  };\n}","map":{"version":3,"names":["tar","require","pump","fs","path","win32","global","Bare","platform","process","exports","pack","cwd","opts","xfs","ignore","filter","noop","mapStream","echo","statNext","statAll","dereference","stat","lstat","entries","sort","strict","umask","processUmask","finish","map","dmode","fmode","strip","readable","parseInt","writable","onnextentry","onsymlink","filename","header","readlink","join","err","linkname","destroy","normalize","entry","onstat","destroyed","finalize","isSocket","name","mode","isDirectory","mtime","size","type","uid","gid","isSymbolicLink","isFile","Error","rs","createReadStream","start","end","on","head","list","length","processGetuid","getuid","extract","resolve","own","chown","stack","now","Date","validateSymLinks","validateSymlinks","onentry","stream","next","resume","dir","dirname","validate","valid","push","mkdirfix","onfile","onlink","utimes","chperm","unlink","dst","inCwd","symlink","link","realpath","code","hardlinkAsFilesFallback","startsWith","ws","createWriteStream","utimesParent","cb","top","slice","pop","chmod","lchmod","lchown","call","onchown","mkdir","recursive","made","root","st","replace","queue","loop","callback","shift","nextAbs","indexOf","readdir","files","i","level","split","isAbsolute"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/tar-fs/index.js"],"sourcesContent":["const tar = require('tar-stream')\nconst pump = require('pump')\nconst fs = require('fs')\nconst path = require('path')\n\nconst win32 = (global.Bare ? global.Bare.platform : process.platform) === 'win32'\n\nexports.pack = function pack (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  const xfs = opts.fs || fs\n  const ignore = opts.ignore || opts.filter || noop\n  const mapStream = opts.mapStream || echo\n  const statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)\n  const strict = opts.strict !== false\n  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  const pack = opts.pack || tar.pack()\n  const finish = opts.finish || noop\n\n  let map = opts.map || noop\n  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  onnextentry()\n\n  function onsymlink (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err)\n      header.linkname = normalize(linkname)\n      pack.entry(header, onnextentry)\n    })\n  }\n\n  function onstat (err, filename, stat) {\n    if (pack.destroyed) return\n    if (err) return pack.destroy(err)\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize()\n      return finish(pack)\n    }\n\n    if (stat.isSocket()) return onnextentry() // tar does not support sockets...\n\n    let header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    }\n\n    if (stat.isDirectory()) {\n      header.size = 0\n      header.type = 'directory'\n      header = map(header) || header\n      return pack.entry(header, onnextentry)\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0\n      header.type = 'symlink'\n      header = map(header) || header\n      return onsymlink(filename, header)\n    }\n\n    // TODO: add fifo etc...\n\n    header = map(header) || header\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))\n      return onnextentry()\n    }\n\n    const entry = pack.entry(header, onnextentry)\n    const rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header)\n\n    rs.on('error', function (err) { // always forward errors on destroy\n      entry.destroy(err)\n    })\n\n    pump(rs, entry)\n  }\n\n  function onnextentry (err) {\n    if (err) return pack.destroy(err)\n    statNext(onstat)\n  }\n\n  return pack\n}\n\nfunction head (list) {\n  return list.length ? list[list.length - 1] : null\n}\n\nfunction processGetuid () {\n  return (!global.Bare && process.getuid) ? process.getuid() : -1\n}\n\nfunction processUmask () {\n  return (!global.Bare && process.umask) ? process.umask() : 0\n}\n\nexports.extract = function extract (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  cwd = path.resolve(cwd)\n\n  const xfs = opts.fs || fs\n  const ignore = opts.ignore || opts.filter || noop\n  const mapStream = opts.mapStream || echo\n  const own = opts.chown !== false && !win32 && processGetuid() === 0\n  const extract = opts.extract || tar.extract()\n  const stack = []\n  const now = new Date()\n  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  const strict = opts.strict !== false\n  const validateSymLinks = opts.validateSymlinks !== false\n\n  let map = opts.map || noop\n  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  extract.on('entry', onentry)\n\n  if (opts.finish) extract.on('finish', opts.finish)\n\n  return extract\n\n  function onentry (header, stream, next) {\n    header = map(header) || header\n    header.name = normalize(header.name)\n\n    const name = path.join(cwd, path.join('/', header.name))\n\n    if (ignore(name, header)) {\n      stream.resume()\n      return next()\n    }\n\n    const dir = path.join(name, '.') === path.join(cwd, '.') ? cwd : path.dirname(name)\n\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err)\n      if (!valid) return next(new Error(dir + ' is not a valid path'))\n\n      if (header.type === 'directory') {\n        stack.push([name, header.mtime])\n        return mkdirfix(name, {\n          fs: xfs,\n          own,\n          uid: header.uid,\n          gid: header.gid,\n          mode: header.mode\n        }, stat)\n      }\n\n      mkdirfix(dir, {\n        fs: xfs,\n        own,\n        uid: header.uid,\n        gid: header.gid,\n        // normally, the folders with rights and owner should be part of the TAR file\n        // if this is not the case, create folder for same user as file and with\n        // standard permissions of 0o755 (rwxr-xr-x)\n        mode: 0o755\n      }, function (err) {\n        if (err) return next(err)\n\n        switch (header.type) {\n          case 'file': return onfile()\n          case 'link': return onlink()\n          case 'symlink': return onsymlink()\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))\n\n        stream.resume()\n        next()\n      })\n    })\n\n    function stat (err) {\n      if (err) return next(err)\n      utimes(name, header, function (err) {\n        if (err) return next(err)\n        if (win32) return next()\n        chperm(name, header, next)\n      })\n    }\n\n    function onsymlink () {\n      if (win32) return next() // skip symlinks on win for now before it can be tested\n      xfs.unlink(name, function () {\n        const dst = path.resolve(path.dirname(name), header.linkname)\n        if (!inCwd(dst) && validateSymLinks) return next(new Error(name + ' is not a valid symlink'))\n\n        xfs.symlink(header.linkname, name, stat)\n      })\n    }\n\n    function onlink () {\n      if (win32) return next() // skip links on win for now before it can be tested\n      xfs.unlink(name, function () {\n        const link = path.join(cwd, path.join('/', header.linkname))\n\n        fs.realpath(link, function (err, dst) {\n          if (err || !inCwd(dst)) return next(new Error(name + ' is not a valid hardlink'))\n\n          xfs.link(dst, name, function (err) {\n            if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n              stream = xfs.createReadStream(dst)\n              return onfile()\n            }\n\n            stat(err)\n          })\n        })\n      })\n    }\n\n    function inCwd (dst) {\n      return dst.startsWith(cwd)\n    }\n\n    function onfile () {\n      const ws = xfs.createWriteStream(name)\n      const rs = mapStream(stream, header)\n\n      ws.on('error', function (err) { // always forward errors on destroy\n        rs.destroy(err)\n      })\n\n      pump(rs, ws, function (err) {\n        if (err) return next(err)\n        ws.on('close', stat)\n      })\n    }\n  }\n\n  function utimesParent (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry\n    let top\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()\n    if (!top) return cb()\n    xfs.utimes(top[0], now, top[1], cb)\n  }\n\n  function utimes (name, header, cb) {\n    if (opts.utimes === false) return cb()\n\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)\n    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err)\n      utimesParent(name, cb)\n    })\n  }\n\n  function chperm (name, header, cb) {\n    const link = header.type === 'symlink'\n\n    /* eslint-disable n/no-deprecated-api */\n    const chmod = link ? xfs.lchmod : xfs.chmod\n    const chown = link ? xfs.lchown : xfs.chown\n    /* eslint-enable n/no-deprecated-api */\n\n    if (!chmod) return cb()\n\n    const mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask\n\n    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown)\n    else onchown(null)\n\n    function onchown (err) {\n      if (err) return cb(err)\n      if (!chmod) return cb()\n      chmod.call(xfs, name, mode, cb)\n    }\n  }\n\n  function mkdirfix (name, opts, cb) {\n    // when mkdir is called on an existing directory, the permissions\n    // will be overwritten (?), to avoid this we check for its existance first\n    xfs.stat(name, function (err) {\n      if (!err) return cb(null)\n      if (err.code !== 'ENOENT') return cb(err)\n      xfs.mkdir(name, { mode: opts.mode, recursive: true }, function (err, made) {\n        if (err) return cb(err)\n        chperm(name, opts, cb)\n      })\n    })\n  }\n}\n\nfunction validate (fs, name, root, cb) {\n  if (name === root) return cb(null, true)\n\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT' && err.code !== 'EPERM') return cb(err)\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)\n    cb(null, false)\n  })\n}\n\nfunction noop () {}\n\nfunction echo (name) {\n  return name\n}\n\nfunction normalize (name) {\n  return win32 ? name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_') : name\n}\n\nfunction statAll (fs, stat, cwd, ignore, entries, sort) {\n  if (!entries) entries = ['.']\n  const queue = entries.slice(0)\n\n  return function loop (callback) {\n    if (!queue.length) return callback(null)\n\n    const next = queue.shift()\n    const nextAbs = path.join(cwd, next)\n\n    stat.call(fs, nextAbs, function (err, stat) {\n      // ignore errors if the files were deleted while buffering\n      if (err) return callback(entries.indexOf(next) === -1 && err.code === 'ENOENT' ? null : err)\n\n      if (!stat.isDirectory()) return callback(null, next, stat)\n\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err)\n\n        if (sort) files.sort()\n\n        for (let i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))\n        }\n\n        callback(null, next, stat)\n      })\n    })\n  }\n}\n\nfunction strip (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/')\n\n    const linkname = header.linkname\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/')\n    }\n\n    return map(header)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}