{"ast":null,"code":"/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function () {\n      try {\n        inner.call(this);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    var r,\n      s = 0;\n    function next() {\n      while (r = env.stack.pop()) {\n        try {\n          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n          if (r.dispose) {\n            var result = r.dispose.call(r.value);\n            if (r.async) return s |= 2, Promise.resolve(result).then(next, function (e) {\n              fail(e);\n              return next();\n            });\n          } else s |= 1;\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { WEB_PERMISSION_TO_PROTOCOL_PERMISSION } from '../api/Browser.js';\nimport { BrowserContext } from '../api/BrowserContext.js';\nimport { assert } from '../util/assert.js';\nimport { convertCookiesPartitionKeyFromPuppeteerToCdp } from './Page.js';\n/**\n * @internal\n */\nexport class CdpBrowserContext extends BrowserContext {\n  #connection;\n  #browser;\n  #id;\n  constructor(connection, browser, contextId) {\n    super();\n    this.#connection = connection;\n    this.#browser = browser;\n    this.#id = contextId;\n  }\n  get id() {\n    return this.#id;\n  }\n  targets() {\n    return this.#browser.targets().filter(target => {\n      return target.browserContext() === this;\n    });\n  }\n  async pages() {\n    const pages = await Promise.all(this.targets().filter(target => {\n      return target.type() === 'page' || target.type() === 'other' && this.#browser._getIsPageTargetCallback()?.(target);\n    }).map(target => {\n      return target.page();\n    }));\n    return pages.filter(page => {\n      return !!page;\n    });\n  }\n  async overridePermissions(origin, permissions) {\n    const protocolPermissions = permissions.map(permission => {\n      const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);\n      if (!protocolPermission) {\n        throw new Error('Unknown permission: ' + permission);\n      }\n      return protocolPermission;\n    });\n    await this.#connection.send('Browser.grantPermissions', {\n      origin,\n      browserContextId: this.#id || undefined,\n      permissions: protocolPermissions\n    });\n  }\n  async clearPermissionOverrides() {\n    await this.#connection.send('Browser.resetPermissions', {\n      browserContextId: this.#id || undefined\n    });\n  }\n  async newPage() {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      const _guard = __addDisposableResource(env_1, await this.waitForScreenshotOperations(), false);\n      return await this.#browser._createPageInContext(this.#id);\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  browser() {\n    return this.#browser;\n  }\n  async close() {\n    assert(this.#id, 'Default BrowserContext cannot be closed!');\n    await this.#browser._disposeContext(this.#id);\n  }\n  async cookies() {\n    const {\n      cookies\n    } = await this.#connection.send('Storage.getCookies', {\n      browserContextId: this.#id\n    });\n    return cookies.map(cookie => {\n      return {\n        ...cookie,\n        partitionKey: cookie.partitionKey ? {\n          sourceOrigin: cookie.partitionKey.topLevelSite,\n          hasCrossSiteAncestor: cookie.partitionKey.hasCrossSiteAncestor\n        } : undefined\n      };\n    });\n  }\n  async setCookie(...cookies) {\n    return await this.#connection.send('Storage.setCookies', {\n      browserContextId: this.#id,\n      cookies: cookies.map(cookie => {\n        return {\n          ...cookie,\n          partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookie.partitionKey)\n        };\n      })\n    });\n  }\n  async setDownloadBehavior(downloadBehavior) {\n    await this.#connection.send('Browser.setDownloadBehavior', {\n      behavior: downloadBehavior.policy,\n      downloadPath: downloadBehavior.downloadPath,\n      browserContextId: this.#id\n    });\n  }\n}","map":{"version":3,"names":["WEB_PERMISSION_TO_PROTOCOL_PERMISSION","BrowserContext","assert","convertCookiesPartitionKeyFromPuppeteerToCdp","CdpBrowserContext","connection","browser","id","constructor","contextId","targets","filter","target","browserContext","pages","Promise","all","type","_getIsPageTargetCallback","map","page","overridePermissions","origin","permissions","protocolPermissions","permission","protocolPermission","get","Error","send","browserContextId","undefined","clearPermissionOverrides","newPage","_guard","__addDisposableResource","env_1","waitForScreenshotOperations","_createPageInContext","close","_disposeContext","cookies","cookie","partitionKey","sourceOrigin","topLevelSite","hasCrossSiteAncestor","setCookie","setDownloadBehavior","downloadBehavior","behavior","policy","downloadPath"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/puppeteer-core/src/cdp/BrowserContext.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  WEB_PERMISSION_TO_PROTOCOL_PERMISSION,\n  type Permission,\n} from '../api/Browser.js';\nimport {BrowserContext} from '../api/BrowserContext.js';\nimport type {Page} from '../api/Page.js';\nimport type {Cookie, CookieData} from '../common/Cookie.js';\nimport type {DownloadBehavior} from '../common/DownloadBehavior.js';\nimport {assert} from '../util/assert.js';\n\nimport type {CdpBrowser} from './Browser.js';\nimport type {Connection} from './Connection.js';\nimport {convertCookiesPartitionKeyFromPuppeteerToCdp} from './Page.js';\nimport type {CdpTarget} from './Target.js';\n\n/**\n * @internal\n */\nexport class CdpBrowserContext extends BrowserContext {\n  #connection: Connection;\n  #browser: CdpBrowser;\n  #id?: string;\n\n  constructor(connection: Connection, browser: CdpBrowser, contextId?: string) {\n    super();\n    this.#connection = connection;\n    this.#browser = browser;\n    this.#id = contextId;\n  }\n\n  override get id(): string | undefined {\n    return this.#id;\n  }\n\n  override targets(): CdpTarget[] {\n    return this.#browser.targets().filter(target => {\n      return target.browserContext() === this;\n    });\n  }\n\n  override async pages(): Promise<Page[]> {\n    const pages = await Promise.all(\n      this.targets()\n        .filter(target => {\n          return (\n            target.type() === 'page' ||\n            (target.type() === 'other' &&\n              this.#browser._getIsPageTargetCallback()?.(target))\n          );\n        })\n        .map(target => {\n          return target.page();\n        }),\n    );\n    return pages.filter((page): page is Page => {\n      return !!page;\n    });\n  }\n\n  override async overridePermissions(\n    origin: string,\n    permissions: Permission[],\n  ): Promise<void> {\n    const protocolPermissions = permissions.map(permission => {\n      const protocolPermission =\n        WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);\n      if (!protocolPermission) {\n        throw new Error('Unknown permission: ' + permission);\n      }\n      return protocolPermission;\n    });\n    await this.#connection.send('Browser.grantPermissions', {\n      origin,\n      browserContextId: this.#id || undefined,\n      permissions: protocolPermissions,\n    });\n  }\n\n  override async clearPermissionOverrides(): Promise<void> {\n    await this.#connection.send('Browser.resetPermissions', {\n      browserContextId: this.#id || undefined,\n    });\n  }\n\n  override async newPage(): Promise<Page> {\n    using _guard = await this.waitForScreenshotOperations();\n    return await this.#browser._createPageInContext(this.#id);\n  }\n\n  override browser(): CdpBrowser {\n    return this.#browser;\n  }\n\n  override async close(): Promise<void> {\n    assert(this.#id, 'Default BrowserContext cannot be closed!');\n    await this.#browser._disposeContext(this.#id);\n  }\n\n  override async cookies(): Promise<Cookie[]> {\n    const {cookies} = await this.#connection.send('Storage.getCookies', {\n      browserContextId: this.#id,\n    });\n    return cookies.map(cookie => {\n      return {\n        ...cookie,\n        partitionKey: cookie.partitionKey\n          ? {\n              sourceOrigin: cookie.partitionKey.topLevelSite,\n              hasCrossSiteAncestor: cookie.partitionKey.hasCrossSiteAncestor,\n            }\n          : undefined,\n      };\n    });\n  }\n\n  override async setCookie(...cookies: CookieData[]): Promise<void> {\n    return await this.#connection.send('Storage.setCookies', {\n      browserContextId: this.#id,\n      cookies: cookies.map(cookie => {\n        return {\n          ...cookie,\n          partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(\n            cookie.partitionKey,\n          ),\n        };\n      }),\n    });\n  }\n\n  public async setDownloadBehavior(\n    downloadBehavior: DownloadBehavior,\n  ): Promise<void> {\n    await this.#connection.send('Browser.setDownloadBehavior', {\n      behavior: downloadBehavior.policy,\n      downloadPath: downloadBehavior.downloadPath,\n      browserContextId: this.#id,\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}