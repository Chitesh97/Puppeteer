{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\nconst STREAM_DESTROYED = new Error('Stream was destroyed');\nconst PREMATURE_CLOSE = new Error('Premature close');\nconst FIFO = require('fast-fifo');\nconst TextDecoder = require('text-decoder');\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask;\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = (1 << 29) - 1;\n\n// Shared state\nconst OPENING = 0b0001;\nconst PREDESTROYING = 0b0010;\nconst DESTROYING = 0b0100;\nconst DESTROYED = 0b1000;\nconst NOT_OPENING = MAX ^ OPENING;\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING;\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE = 0b00000000000001 << 4;\nconst READ_UPDATING = 0b00000000000010 << 4;\nconst READ_PRIMARY = 0b00000000000100 << 4;\nconst READ_QUEUED = 0b00000000001000 << 4;\nconst READ_RESUMED = 0b00000000010000 << 4;\nconst READ_PIPE_DRAINED = 0b00000000100000 << 4;\nconst READ_ENDING = 0b00000001000000 << 4;\nconst READ_EMIT_DATA = 0b00000010000000 << 4;\nconst READ_EMIT_READABLE = 0b00000100000000 << 4;\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4;\nconst READ_DONE = 0b00010000000000 << 4;\nconst READ_NEXT_TICK = 0b00100000000000 << 4;\nconst READ_NEEDS_PUSH = 0b01000000000000 << 4;\nconst READ_READ_AHEAD = 0b10000000000000 << 4;\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;\nconst READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;\nconst READ_NON_PRIMARY = MAX ^ READ_PRIMARY;\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);\nconst READ_PUSHED = MAX ^ READ_NEEDS_PUSH;\nconst READ_PAUSED = MAX ^ READ_RESUMED;\nconst READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);\nconst READ_NOT_ENDING = MAX ^ READ_ENDING;\nconst READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;\nconst READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;\nconst READ_NOT_UPDATING = MAX ^ READ_UPDATING;\nconst READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;\nconst READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE = 0b00000000001 << 18;\nconst WRITE_UPDATING = 0b00000000010 << 18;\nconst WRITE_PRIMARY = 0b00000000100 << 18;\nconst WRITE_QUEUED = 0b00000001000 << 18;\nconst WRITE_UNDRAINED = 0b00000010000 << 18;\nconst WRITE_DONE = 0b00000100000 << 18;\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18;\nconst WRITE_NEXT_TICK = 0b00010000000 << 18;\nconst WRITE_WRITING = 0b00100000000 << 18;\nconst WRITE_FINISHING = 0b01000000000 << 18;\nconst WRITE_CORKED = 0b10000000000 << 18;\nconst WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);\nconst WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);\nconst WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;\nconst WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;\nconst WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;\nconst WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE;\nconst NOT_ACTIVE = MAX ^ ACTIVE;\nconst DONE = READ_DONE | WRITE_DONE;\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;\nconst OPEN_STATUS = DESTROY_STATUS | OPENING;\nconst AUTO_DESTROY = DESTROY_STATUS | DONE;\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;\nconst IS_OPENING = OPEN_STATUS | TICKING;\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');\nclass WritableState {\n  constructor(stream, {\n    highWaterMark = 16384,\n    map = null,\n    mapWritable,\n    byteLength,\n    byteLengthWritable\n  } = {}) {\n    this.stream = stream;\n    this.queue = new FIFO();\n    this.highWaterMark = highWaterMark;\n    this.buffered = 0;\n    this.error = null;\n    this.pipeline = null;\n    this.drains = null; // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength;\n    this.map = mapWritable || map;\n    this.afterWrite = afterWrite.bind(this);\n    this.afterUpdateNextTick = updateWriteNT.bind(this);\n  }\n  get ended() {\n    return (this.stream._duplexState & WRITE_DONE) !== 0;\n  }\n  push(data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false;\n    if (this.map !== null) data = this.map(data);\n    this.buffered += this.byteLength(data);\n    this.queue.push(data);\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED;\n      return true;\n    }\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;\n    return false;\n  }\n  shift() {\n    const data = this.queue.shift();\n    this.buffered -= this.byteLength(data);\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;\n    return data;\n  }\n  end(data) {\n    if (typeof data === 'function') this.stream.once('finish', data);else if (data !== undefined && data !== null) this.push(data);\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;\n  }\n  autoBatch(data, cb) {\n    const buffer = [];\n    const stream = this.stream;\n    buffer.push(data);\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift());\n    }\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);\n    stream._writev(buffer, cb);\n  }\n  update() {\n    const stream = this.stream;\n    stream._duplexState |= WRITE_UPDATING;\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift();\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING;\n        stream._write(data, this.afterWrite);\n      }\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n    } while (this.continueUpdate() === true);\n    stream._duplexState &= WRITE_NOT_UPDATING;\n  }\n  updateNonPrimary() {\n    const stream = this.stream;\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE;\n      stream._final(afterFinal.bind(this));\n      return;\n    }\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE;\n        stream._destroy(afterDestroy.bind(this));\n      }\n      return;\n    }\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;\n      stream._open(afterOpen.bind(this));\n    }\n  }\n  continueUpdate() {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;\n    return true;\n  }\n  updateCallback() {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();else this.updateNextTick();\n  }\n  updateNextTick() {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;\n    this.stream._duplexState |= WRITE_NEXT_TICK;\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick);\n  }\n}\nclass ReadableState {\n  constructor(stream, {\n    highWaterMark = 16384,\n    map = null,\n    mapReadable,\n    byteLength,\n    byteLengthReadable\n  } = {}) {\n    this.stream = stream;\n    this.queue = new FIFO();\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;\n    this.buffered = 0;\n    this.readAhead = highWaterMark > 0;\n    this.error = null;\n    this.pipeline = null;\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength;\n    this.map = mapReadable || map;\n    this.pipeTo = null;\n    this.afterRead = afterRead.bind(this);\n    this.afterUpdateNextTick = updateReadNT.bind(this);\n  }\n  get ended() {\n    return (this.stream._duplexState & READ_DONE) !== 0;\n  }\n  pipe(pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');\n    if (typeof cb !== 'function') cb = null;\n    this.stream._duplexState |= READ_PIPE_DRAINED;\n    this.pipeTo = pipeTo;\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb);\n    if (cb) this.stream.on('error', noop); // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline;\n      if (cb) pipeTo.on('error', noop); // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)); // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null); // onclose has a weird bool arg\n      pipeTo.on('error', onerror);\n      pipeTo.on('close', onclose);\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));\n    }\n    pipeTo.on('drain', afterDrain.bind(this));\n    this.stream.emit('piping', pipeTo);\n    pipeTo.emit('pipe', this.stream);\n  }\n  push(data) {\n    const stream = this.stream;\n    if (data === null) {\n      this.highWaterMark = 0;\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;\n      return false;\n    }\n    if (this.map !== null) {\n      data = this.map(data);\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED;\n        return this.buffered < this.highWaterMark;\n      }\n    }\n    this.buffered += this.byteLength(data);\n    this.queue.push(data);\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;\n    return this.buffered < this.highWaterMark;\n  }\n  shift() {\n    const data = this.queue.shift();\n    this.buffered -= this.byteLength(data);\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;\n    return data;\n  }\n  unshift(data) {\n    const pending = [this.map !== null ? this.map(data) : data];\n    while (this.buffered > 0) pending.push(this.shift());\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i];\n      this.buffered += this.byteLength(data);\n      this.queue.push(data);\n    }\n    this.push(pending[pending.length - 1]);\n  }\n  read() {\n    const stream = this.stream;\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift();\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);\n      return data;\n    }\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD;\n      this.updateNextTick();\n    }\n    return null;\n  }\n  drain() {\n    const stream = this.stream;\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift();\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);\n    }\n  }\n  update() {\n    const stream = this.stream;\n    stream._duplexState |= READ_UPDATING;\n    do {\n      this.drain();\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;\n        stream._read(this.afterRead);\n        this.drain();\n      }\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE;\n        stream.emit('readable');\n      }\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n    } while (this.continueUpdate() === true);\n    stream._duplexState &= READ_NOT_UPDATING;\n  }\n  updateNonPrimary() {\n    const stream = this.stream;\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;\n      stream.emit('end');\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;\n      if (this.pipeTo !== null) this.pipeTo.end();\n    }\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE;\n        stream._destroy(afterDestroy.bind(this));\n      }\n      return;\n    }\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;\n      stream._open(afterOpen.bind(this));\n    }\n  }\n  continueUpdate() {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;\n    this.stream._duplexState &= READ_NOT_NEXT_TICK;\n    return true;\n  }\n  updateCallback() {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();else this.updateNextTick();\n  }\n  updateNextTickIfOpen() {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return;\n    this.stream._duplexState |= READ_NEXT_TICK;\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);\n  }\n  updateNextTick() {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;\n    this.stream._duplexState |= READ_NEXT_TICK;\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);\n  }\n}\nclass TransformState {\n  constructor(stream) {\n    this.data = null;\n    this.afterTransform = afterTransform.bind(stream);\n    this.afterFinal = null;\n  }\n}\nclass Pipeline {\n  constructor(src, dst, cb) {\n    this.from = src;\n    this.to = dst;\n    this.afterPipe = cb;\n    this.error = null;\n    this.pipeToFinished = false;\n  }\n  finished() {\n    this.pipeToFinished = true;\n  }\n  done(stream, err) {\n    if (err) this.error = err;\n    if (stream === this.to) {\n      this.to = null;\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'));\n        }\n        return;\n      }\n    }\n    if (stream === this.from) {\n      this.from = null;\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'));\n        }\n        return;\n      }\n    }\n    if (this.afterPipe !== null) this.afterPipe(this.error);\n    this.to = this.from = this.afterPipe = null;\n  }\n}\nfunction afterDrain() {\n  this.stream._duplexState |= READ_PIPE_DRAINED;\n  this.updateCallback();\n}\nfunction afterFinal(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE;\n    stream.emit('finish');\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING;\n  }\n  stream._duplexState &= WRITE_NOT_FINISHING;\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();else this.updateNextTick();\n}\nfunction afterDestroy(err) {\n  const stream = this.stream;\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error;\n  if (err) stream.emit('error', err);\n  stream._duplexState |= DESTROYED;\n  stream.emit('close');\n  const rs = stream._readableState;\n  const ws = stream._writableState;\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err);\n  }\n}\nfunction afterWrite(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  stream._duplexState &= WRITE_NOT_ACTIVE;\n  if (this.drains !== null) tickDrains(this.drains);\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED;\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain');\n    }\n  }\n  this.updateCallback();\n}\nfunction afterRead(err) {\n  if (err) this.stream.destroy(err);\n  this.stream._duplexState &= READ_NOT_ACTIVE;\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;\n  this.updateCallback();\n}\nfunction updateReadNT() {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK;\n    this.update();\n  }\n}\nfunction updateWriteNT() {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;\n    this.update();\n  }\n}\nfunction tickDrains(drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true);\n      i--;\n    }\n  }\n}\nfunction afterOpen(err) {\n  const stream = this.stream;\n  if (err) stream.destroy(err);\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;\n    stream.emit('open');\n  }\n  stream._duplexState &= NOT_ACTIVE;\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback();\n  }\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback();\n  }\n}\nfunction afterTransform(err, data) {\n  if (data !== undefined && data !== null) this.push(data);\n  this._writableState.afterWrite(err);\n}\nfunction newListener(name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;\n      this._readableState.updateNextTick();\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE;\n      this._readableState.updateNextTick();\n    }\n  }\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN;\n      this._writableState.updateNextTick();\n    }\n  }\n}\nclass Stream extends EventEmitter {\n  constructor(opts) {\n    super();\n    this._duplexState = 0;\n    this._readableState = null;\n    this._writableState = null;\n    if (opts) {\n      if (opts.open) this._open = opts.open;\n      if (opts.destroy) this._destroy = opts.destroy;\n      if (opts.predestroy) this._predestroy = opts.predestroy;\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this));\n      }\n    }\n    this.on('newListener', newListener);\n  }\n  _open(cb) {\n    cb(null);\n  }\n  _destroy(cb) {\n    cb(null);\n  }\n  _predestroy() {\n    // does nothing\n  }\n  get readable() {\n    return this._readableState !== null ? true : undefined;\n  }\n  get writable() {\n    return this._writableState !== null ? true : undefined;\n  }\n  get destroyed() {\n    return (this._duplexState & DESTROYED) !== 0;\n  }\n  get destroying() {\n    return (this._duplexState & DESTROY_STATUS) !== 0;\n  }\n  destroy(err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED;\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0;\n        this._readableState.error = err;\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0;\n        this._writableState.error = err;\n      }\n      this._duplexState |= PREDESTROYING;\n      this._predestroy();\n      this._duplexState &= NOT_PREDESTROYING;\n      if (this._readableState !== null) this._readableState.updateNextTick();\n      if (this._writableState !== null) this._writableState.updateNextTick();\n    }\n  }\n}\nclass Readable extends Stream {\n  constructor(opts) {\n    super(opts);\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;\n    this._readableState = new ReadableState(this, opts);\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;\n      if (opts.read) this._read = opts.read;\n      if (opts.eagerOpen) this._readableState.updateNextTick();\n      if (opts.encoding) this.setEncoding(opts.encoding);\n    }\n  }\n  setEncoding(encoding) {\n    const dec = new TextDecoder(encoding);\n    const map = this._readableState.map || echo;\n    this._readableState.map = mapOrSkip;\n    return this;\n    function mapOrSkip(data) {\n      const next = dec.push(data);\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);\n    }\n  }\n  _read(cb) {\n    cb(null);\n  }\n  pipe(dest, cb) {\n    this._readableState.updateNextTick();\n    this._readableState.pipe(dest, cb);\n    return dest;\n  }\n  read() {\n    this._readableState.updateNextTick();\n    return this._readableState.read();\n  }\n  push(data) {\n    this._readableState.updateNextTickIfOpen();\n    return this._readableState.push(data);\n  }\n  unshift(data) {\n    this._readableState.updateNextTickIfOpen();\n    return this._readableState.unshift(data);\n  }\n  resume() {\n    this._duplexState |= READ_RESUMED_READ_AHEAD;\n    this._readableState.updateNextTick();\n    return this;\n  }\n  pause() {\n    this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;\n    return this;\n  }\n  static _fromAsyncIterator(ite, opts) {\n    let destroy;\n    const rs = new Readable({\n      ...opts,\n      read(cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb);\n      },\n      predestroy() {\n        destroy = ite.return();\n      },\n      destroy(cb) {\n        if (!destroy) return cb(null);\n        destroy.then(cb.bind(null, null)).catch(cb);\n      }\n    });\n    return rs;\n    function push(data) {\n      if (data.done) rs.push(null);else rs.push(data.value);\n    }\n  }\n  static from(data, opts) {\n    if (isReadStreamx(data)) return data;\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data];\n    let i = 0;\n    return new Readable({\n      ...opts,\n      read(cb) {\n        this.push(i === data.length ? null : data[i++]);\n        cb(null);\n      }\n    });\n  }\n  static isBackpressured(rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;\n  }\n  static isPaused(rs) {\n    return (rs._duplexState & READ_RESUMED) === 0;\n  }\n  [asyncIterator]() {\n    const stream = this;\n    let error = null;\n    let promiseResolve = null;\n    let promiseReject = null;\n    this.on('error', err => {\n      error = err;\n    });\n    this.on('readable', onreadable);\n    this.on('close', onclose);\n    return {\n      [asyncIterator]() {\n        return this;\n      },\n      next() {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve;\n          promiseReject = reject;\n          const data = stream.read();\n          if (data !== null) ondata(data);else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);\n        });\n      },\n      return() {\n        return destroy(null);\n      },\n      throw(err) {\n        return destroy(err);\n      }\n    };\n    function onreadable() {\n      if (promiseResolve !== null) ondata(stream.read());\n    }\n    function onclose() {\n      if (promiseResolve !== null) ondata(null);\n    }\n    function ondata(data) {\n      if (promiseReject === null) return;\n      if (error) promiseReject(error);else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);else promiseResolve({\n        value: data,\n        done: data === null\n      });\n      promiseReject = promiseResolve = null;\n    }\n    function destroy(err) {\n      stream.destroy(err);\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({\n          value: undefined,\n          done: true\n        });\n        stream.once('close', function () {\n          if (err) reject(err);else resolve({\n            value: undefined,\n            done: true\n          });\n        });\n      });\n    }\n  }\n}\nclass Writable extends Stream {\n  constructor(opts) {\n    super(opts);\n    this._duplexState |= OPENING | READ_DONE;\n    this._writableState = new WritableState(this, opts);\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev;\n      if (opts.write) this._write = opts.write;\n      if (opts.final) this._final = opts.final;\n      if (opts.eagerOpen) this._writableState.updateNextTick();\n    }\n  }\n  cork() {\n    this._duplexState |= WRITE_CORKED;\n  }\n  uncork() {\n    this._duplexState &= WRITE_NOT_CORKED;\n    this._writableState.updateNextTick();\n  }\n  _writev(batch, cb) {\n    cb(null);\n  }\n  _write(data, cb) {\n    this._writableState.autoBatch(data, cb);\n  }\n  _final(cb) {\n    cb(null);\n  }\n  static isBackpressured(ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;\n  }\n  static drained(ws) {\n    if (ws.destroyed) return Promise.resolve(false);\n    const state = ws._writableState;\n    const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;\n    const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);\n    if (writes === 0) return Promise.resolve(true);\n    if (state.drains === null) state.drains = [];\n    return new Promise(resolve => {\n      state.drains.push({\n        writes,\n        resolve\n      });\n    });\n  }\n  write(data) {\n    this._writableState.updateNextTick();\n    return this._writableState.push(data);\n  }\n  end(data) {\n    this._writableState.updateNextTick();\n    this._writableState.end(data);\n    return this;\n  }\n}\nclass Duplex extends Readable {\n  // and Writable\n  constructor(opts) {\n    super(opts);\n    this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;\n    this._writableState = new WritableState(this, opts);\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev;\n      if (opts.write) this._write = opts.write;\n      if (opts.final) this._final = opts.final;\n    }\n  }\n  cork() {\n    this._duplexState |= WRITE_CORKED;\n  }\n  uncork() {\n    this._duplexState &= WRITE_NOT_CORKED;\n    this._writableState.updateNextTick();\n  }\n  _writev(batch, cb) {\n    cb(null);\n  }\n  _write(data, cb) {\n    this._writableState.autoBatch(data, cb);\n  }\n  _final(cb) {\n    cb(null);\n  }\n  write(data) {\n    this._writableState.updateNextTick();\n    return this._writableState.push(data);\n  }\n  end(data) {\n    this._writableState.updateNextTick();\n    this._writableState.end(data);\n    return this;\n  }\n}\nclass Transform extends Duplex {\n  constructor(opts) {\n    super(opts);\n    this._transformState = new TransformState(this);\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform;\n      if (opts.flush) this._flush = opts.flush;\n    }\n  }\n  _write(data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data;\n    } else {\n      this._transform(data, this._transformState.afterTransform);\n    }\n  }\n  _read(cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data;\n      this._transformState.data = null;\n      cb(null);\n      this._transform(data, this._transformState.afterTransform);\n    } else {\n      cb(null);\n    }\n  }\n  destroy(err) {\n    super.destroy(err);\n    if (this._transformState.data !== null) {\n      this._transformState.data = null;\n      this._transformState.afterTransform();\n    }\n  }\n  _transform(data, cb) {\n    cb(null, data);\n  }\n  _flush(cb) {\n    cb(null);\n  }\n  _final(cb) {\n    this._transformState.afterFinal = cb;\n    this._flush(transformAfterFlush.bind(this));\n  }\n}\nclass PassThrough extends Transform {}\nfunction transformAfterFlush(err, data) {\n  const cb = this._transformState.afterFinal;\n  if (err) return cb(err);\n  if (data !== null && data !== undefined) this.push(data);\n  this.push(null);\n  cb(null);\n}\nfunction pipelinePromise(...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, err => {\n      if (err) return reject(err);\n      resolve();\n    });\n  });\n}\nfunction pipeline(stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];\n  const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');\n  let src = all[0];\n  let dest = null;\n  let error = null;\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i];\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror);\n    } else {\n      errorHandle(src, true, i > 1, onerror);\n      src.pipe(dest);\n    }\n    src = dest;\n  }\n  if (done) {\n    let fin = false;\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);\n    dest.on('error', err => {\n      if (error === null) error = err;\n    });\n    dest.on('finish', () => {\n      fin = true;\n      if (!autoDestroy) done(error);\n    });\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)));\n    }\n  }\n  return dest;\n  function errorHandle(s, rd, wr, onerror) {\n    s.on('error', onerror);\n    s.on('close', onclose);\n    function onclose() {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE);\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE);\n    }\n  }\n  function onerror(err) {\n    if (!err || error) return;\n    error = err;\n    for (const s of all) {\n      s.destroy(err);\n    }\n  }\n}\nfunction echo(s) {\n  return s;\n}\nfunction isStream(stream) {\n  return !!stream._readableState || !!stream._writableState;\n}\nfunction isStreamx(stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream);\n}\nfunction isEnded(stream) {\n  return !!stream._readableState && stream._readableState.ended;\n}\nfunction isFinished(stream) {\n  return !!stream._writableState && stream._writableState.ended;\n}\nfunction getStreamError(stream, opts = {}) {\n  const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;\n\n  // avoid implicit errors by default\n  return !opts.all && err === STREAM_DESTROYED ? null : err;\n}\nfunction isReadStreamx(stream) {\n  return isStreamx(stream) && stream.readable;\n}\nfunction isDisturbed(stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;\n}\nfunction isTypedArray(data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';\n}\nfunction defaultByteLength(data) {\n  return isTypedArray(data) ? data.byteLength : 1024;\n}\nfunction noop() {}\nfunction abort() {\n  this.destroy(new Error('Stream aborted.'));\n}\nfunction isWritev(s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;\n}\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n};","map":{"version":3,"names":["EventEmitter","require","STREAM_DESTROYED","Error","PREMATURE_CLOSE","FIFO","TextDecoder","qmt","queueMicrotask","fn","global","process","nextTick","MAX","OPENING","PREDESTROYING","DESTROYING","DESTROYED","NOT_OPENING","NOT_PREDESTROYING","READ_ACTIVE","READ_UPDATING","READ_PRIMARY","READ_QUEUED","READ_RESUMED","READ_PIPE_DRAINED","READ_ENDING","READ_EMIT_DATA","READ_EMIT_READABLE","READ_EMITTED_READABLE","READ_DONE","READ_NEXT_TICK","READ_NEEDS_PUSH","READ_READ_AHEAD","READ_FLOWING","READ_ACTIVE_AND_NEEDS_PUSH","READ_PRIMARY_AND_ACTIVE","READ_EMIT_READABLE_AND_QUEUED","READ_RESUMED_READ_AHEAD","READ_NOT_ACTIVE","READ_NON_PRIMARY","READ_NON_PRIMARY_AND_PUSHED","READ_PUSHED","READ_PAUSED","READ_NOT_QUEUED","READ_NOT_ENDING","READ_PIPE_NOT_DRAINED","READ_NOT_NEXT_TICK","READ_NOT_UPDATING","READ_NO_READ_AHEAD","READ_PAUSED_NO_READ_AHEAD","WRITE_ACTIVE","WRITE_UPDATING","WRITE_PRIMARY","WRITE_QUEUED","WRITE_UNDRAINED","WRITE_DONE","WRITE_EMIT_DRAIN","WRITE_NEXT_TICK","WRITE_WRITING","WRITE_FINISHING","WRITE_CORKED","WRITE_NOT_ACTIVE","WRITE_NON_PRIMARY","WRITE_NOT_FINISHING","WRITE_DRAINED","WRITE_NOT_QUEUED","WRITE_NOT_NEXT_TICK","WRITE_NOT_UPDATING","WRITE_NOT_CORKED","ACTIVE","NOT_ACTIVE","DONE","DESTROY_STATUS","OPEN_STATUS","AUTO_DESTROY","NON_PRIMARY","ACTIVE_OR_TICKING","TICKING","IS_OPENING","READ_PRIMARY_STATUS","READ_STATUS","READ_ENDING_STATUS","READ_READABLE_STATUS","SHOULD_NOT_READ","READ_BACKPRESSURE_STATUS","READ_UPDATE_SYNC_STATUS","READ_NEXT_TICK_OR_OPENING","WRITE_PRIMARY_STATUS","WRITE_QUEUED_AND_UNDRAINED","WRITE_QUEUED_AND_ACTIVE","WRITE_DRAIN_STATUS","WRITE_STATUS","WRITE_PRIMARY_AND_ACTIVE","WRITE_ACTIVE_AND_WRITING","WRITE_FINISHING_STATUS","WRITE_BACKPRESSURE_STATUS","WRITE_UPDATE_SYNC_STATUS","WRITE_DROP_DATA","asyncIterator","Symbol","WritableState","constructor","stream","highWaterMark","map","mapWritable","byteLength","byteLengthWritable","queue","buffered","error","pipeline","drains","defaultByteLength","afterWrite","bind","afterUpdateNextTick","updateWriteNT","ended","_duplexState","push","data","shift","end","once","undefined","autoBatch","cb","buffer","_writableState","_writev","update","_write","updateNonPrimary","continueUpdate","_final","afterFinal","_destroy","afterDestroy","_open","afterOpen","updateCallback","updateNextTick","ReadableState","mapReadable","byteLengthReadable","readAhead","pipeTo","afterRead","updateReadNT","pipe","Pipeline","on","noop","isStreamx","finished","onerror","done","onclose","afterDrain","emit","unshift","pending","i","length","read","write","drain","_read","updateNextTickIfOpen","TransformState","afterTransform","src","dst","from","to","afterPipe","pipeToFinished","err","destroy","rs","_readableState","ws","resolve","tickDrains","writes","newListener","name","Stream","opts","open","predestroy","_predestroy","signal","addEventListener","abort","readable","writable","destroyed","destroying","Readable","eagerOpen","encoding","setEncoding","dec","echo","mapOrSkip","next","remaining","dest","resume","pause","_fromAsyncIterator","ite","then","catch","return","value","isReadStreamx","Array","isArray","isBackpressured","isPaused","promiseResolve","promiseReject","onreadable","Promise","reject","ondata","throw","Writable","writev","final","cork","uncork","batch","drained","state","isWritev","Math","min","Duplex","Transform","_transformState","transform","_transform","flush","_flush","transformAfterFlush","PassThrough","pipelinePromise","streams","all","pop","errorHandle","fin","autoDestroy","s","rd","wr","isStream","isEnded","isFinished","getStreamError","isDisturbed","isTypedArray","prototype","module","exports"],"sources":["/Users/goyac1/Desktop/Projects/puppeteer/node_modules/streamx/index.js"],"sourcesContent":["const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}